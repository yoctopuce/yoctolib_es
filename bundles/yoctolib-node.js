'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _yocto_api = require('yoctolib-es/yocto_api');

for (let _key in _yocto_api) {
  if (_key === "default") continue;
  Object.defineProperty(exports, _key, {
    enumerable: true,
    get: function () {
      return _yocto_api[_key];
    }
  });
}

var _yocto_accelerometer = require('yoctolib-es/yocto_accelerometer');

for (let _key2 in _yocto_accelerometer) {
  if (_key2 === "default") continue;
  Object.defineProperty(exports, _key2, {
    enumerable: true,
    get: function () {
      return _yocto_accelerometer[_key2];
    }
  });
}

var _yocto_altitude = require('yoctolib-es/yocto_altitude');

for (let _key3 in _yocto_altitude) {
  if (_key3 === "default") continue;
  Object.defineProperty(exports, _key3, {
    enumerable: true,
    get: function () {
      return _yocto_altitude[_key3];
    }
  });
}

var _yocto_anbutton = require('yoctolib-es/yocto_anbutton');

for (let _key4 in _yocto_anbutton) {
  if (_key4 === "default") continue;
  Object.defineProperty(exports, _key4, {
    enumerable: true,
    get: function () {
      return _yocto_anbutton[_key4];
    }
  });
}

for (let _key5 in _yocto_api) {
  if (_key5 === "default") continue;
  Object.defineProperty(exports, _key5, {
    enumerable: true,
    get: function () {
      return _yocto_api[_key5];
    }
  });
}

var _yocto_audioin = require('yoctolib-es/yocto_audioin');

for (let _key6 in _yocto_audioin) {
  if (_key6 === "default") continue;
  Object.defineProperty(exports, _key6, {
    enumerable: true,
    get: function () {
      return _yocto_audioin[_key6];
    }
  });
}

var _yocto_audioout = require('yoctolib-es/yocto_audioout');

for (let _key7 in _yocto_audioout) {
  if (_key7 === "default") continue;
  Object.defineProperty(exports, _key7, {
    enumerable: true,
    get: function () {
      return _yocto_audioout[_key7];
    }
  });
}

var _yocto_bluetoothlink = require('yoctolib-es/yocto_bluetoothlink');

for (let _key8 in _yocto_bluetoothlink) {
  if (_key8 === "default") continue;
  Object.defineProperty(exports, _key8, {
    enumerable: true,
    get: function () {
      return _yocto_bluetoothlink[_key8];
    }
  });
}

var _yocto_buzzer = require('yoctolib-es/yocto_buzzer');

for (let _key9 in _yocto_buzzer) {
  if (_key9 === "default") continue;
  Object.defineProperty(exports, _key9, {
    enumerable: true,
    get: function () {
      return _yocto_buzzer[_key9];
    }
  });
}

var _yocto_carbondioxide = require('yoctolib-es/yocto_carbondioxide');

for (let _key10 in _yocto_carbondioxide) {
  if (_key10 === "default") continue;
  Object.defineProperty(exports, _key10, {
    enumerable: true,
    get: function () {
      return _yocto_carbondioxide[_key10];
    }
  });
}

var _yocto_cellular = require('yoctolib-es/yocto_cellular');

for (let _key11 in _yocto_cellular) {
  if (_key11 === "default") continue;
  Object.defineProperty(exports, _key11, {
    enumerable: true,
    get: function () {
      return _yocto_cellular[_key11];
    }
  });
}

var _yocto_colorled = require('yoctolib-es/yocto_colorled');

for (let _key12 in _yocto_colorled) {
  if (_key12 === "default") continue;
  Object.defineProperty(exports, _key12, {
    enumerable: true,
    get: function () {
      return _yocto_colorled[_key12];
    }
  });
}

var _yocto_compass = require('yoctolib-es/yocto_compass');

for (let _key13 in _yocto_compass) {
  if (_key13 === "default") continue;
  Object.defineProperty(exports, _key13, {
    enumerable: true,
    get: function () {
      return _yocto_compass[_key13];
    }
  });
}

var _yocto_current = require('yoctolib-es/yocto_current');

for (let _key14 in _yocto_current) {
  if (_key14 === "default") continue;
  Object.defineProperty(exports, _key14, {
    enumerable: true,
    get: function () {
      return _yocto_current[_key14];
    }
  });
}

var _yocto_currentloopoutput = require('yoctolib-es/yocto_currentloopoutput');

for (let _key15 in _yocto_currentloopoutput) {
  if (_key15 === "default") continue;
  Object.defineProperty(exports, _key15, {
    enumerable: true,
    get: function () {
      return _yocto_currentloopoutput[_key15];
    }
  });
}

var _yocto_datalogger = require('yoctolib-es/yocto_datalogger');

for (let _key16 in _yocto_datalogger) {
  if (_key16 === "default") continue;
  Object.defineProperty(exports, _key16, {
    enumerable: true,
    get: function () {
      return _yocto_datalogger[_key16];
    }
  });
}

var _yocto_digitalio = require('yoctolib-es/yocto_digitalio');

for (let _key17 in _yocto_digitalio) {
  if (_key17 === "default") continue;
  Object.defineProperty(exports, _key17, {
    enumerable: true,
    get: function () {
      return _yocto_digitalio[_key17];
    }
  });
}

var _yocto_display = require('yoctolib-es/yocto_display');

for (let _key18 in _yocto_display) {
  if (_key18 === "default") continue;
  Object.defineProperty(exports, _key18, {
    enumerable: true,
    get: function () {
      return _yocto_display[_key18];
    }
  });
}

var _yocto_dualpower = require('yoctolib-es/yocto_dualpower');

for (let _key19 in _yocto_dualpower) {
  if (_key19 === "default") continue;
  Object.defineProperty(exports, _key19, {
    enumerable: true,
    get: function () {
      return _yocto_dualpower[_key19];
    }
  });
}

var _yocto_files = require('yoctolib-es/yocto_files');

for (let _key20 in _yocto_files) {
  if (_key20 === "default") continue;
  Object.defineProperty(exports, _key20, {
    enumerable: true,
    get: function () {
      return _yocto_files[_key20];
    }
  });
}

var _yocto_genericsensor = require('yoctolib-es/yocto_genericsensor');

for (let _key21 in _yocto_genericsensor) {
  if (_key21 === "default") continue;
  Object.defineProperty(exports, _key21, {
    enumerable: true,
    get: function () {
      return _yocto_genericsensor[_key21];
    }
  });
}

var _yocto_gps = require('yoctolib-es/yocto_gps');

for (let _key22 in _yocto_gps) {
  if (_key22 === "default") continue;
  Object.defineProperty(exports, _key22, {
    enumerable: true,
    get: function () {
      return _yocto_gps[_key22];
    }
  });
}

var _yocto_groundspeed = require('yoctolib-es/yocto_groundspeed');

for (let _key23 in _yocto_groundspeed) {
  if (_key23 === "default") continue;
  Object.defineProperty(exports, _key23, {
    enumerable: true,
    get: function () {
      return _yocto_groundspeed[_key23];
    }
  });
}

var _yocto_gyro = require('yoctolib-es/yocto_gyro');

for (let _key24 in _yocto_gyro) {
  if (_key24 === "default") continue;
  Object.defineProperty(exports, _key24, {
    enumerable: true,
    get: function () {
      return _yocto_gyro[_key24];
    }
  });
}

var _yocto_hubport = require('yoctolib-es/yocto_hubport');

for (let _key25 in _yocto_hubport) {
  if (_key25 === "default") continue;
  Object.defineProperty(exports, _key25, {
    enumerable: true,
    get: function () {
      return _yocto_hubport[_key25];
    }
  });
}

var _yocto_humidity = require('yoctolib-es/yocto_humidity');

for (let _key26 in _yocto_humidity) {
  if (_key26 === "default") continue;
  Object.defineProperty(exports, _key26, {
    enumerable: true,
    get: function () {
      return _yocto_humidity[_key26];
    }
  });
}

var _yocto_latitude = require('yoctolib-es/yocto_latitude');

for (let _key27 in _yocto_latitude) {
  if (_key27 === "default") continue;
  Object.defineProperty(exports, _key27, {
    enumerable: true,
    get: function () {
      return _yocto_latitude[_key27];
    }
  });
}

var _yocto_led = require('yoctolib-es/yocto_led');

for (let _key28 in _yocto_led) {
  if (_key28 === "default") continue;
  Object.defineProperty(exports, _key28, {
    enumerable: true,
    get: function () {
      return _yocto_led[_key28];
    }
  });
}

var _yocto_lightsensor = require('yoctolib-es/yocto_lightsensor');

for (let _key29 in _yocto_lightsensor) {
  if (_key29 === "default") continue;
  Object.defineProperty(exports, _key29, {
    enumerable: true,
    get: function () {
      return _yocto_lightsensor[_key29];
    }
  });
}

var _yocto_longitude = require('yoctolib-es/yocto_longitude');

for (let _key30 in _yocto_longitude) {
  if (_key30 === "default") continue;
  Object.defineProperty(exports, _key30, {
    enumerable: true,
    get: function () {
      return _yocto_longitude[_key30];
    }
  });
}

var _yocto_magnetometer = require('yoctolib-es/yocto_magnetometer');

for (let _key31 in _yocto_magnetometer) {
  if (_key31 === "default") continue;
  Object.defineProperty(exports, _key31, {
    enumerable: true,
    get: function () {
      return _yocto_magnetometer[_key31];
    }
  });
}

var _yocto_motor = require('yoctolib-es/yocto_motor');

for (let _key32 in _yocto_motor) {
  if (_key32 === "default") continue;
  Object.defineProperty(exports, _key32, {
    enumerable: true,
    get: function () {
      return _yocto_motor[_key32];
    }
  });
}

var _yocto_network = require('yoctolib-es/yocto_network');

for (let _key33 in _yocto_network) {
  if (_key33 === "default") continue;
  Object.defineProperty(exports, _key33, {
    enumerable: true,
    get: function () {
      return _yocto_network[_key33];
    }
  });
}

var _yocto_oscontrol = require('yoctolib-es/yocto_oscontrol');

for (let _key34 in _yocto_oscontrol) {
  if (_key34 === "default") continue;
  Object.defineProperty(exports, _key34, {
    enumerable: true,
    get: function () {
      return _yocto_oscontrol[_key34];
    }
  });
}

var _yocto_power = require('yoctolib-es/yocto_power');

for (let _key35 in _yocto_power) {
  if (_key35 === "default") continue;
  Object.defineProperty(exports, _key35, {
    enumerable: true,
    get: function () {
      return _yocto_power[_key35];
    }
  });
}

var _yocto_poweroutput = require('yoctolib-es/yocto_poweroutput');

for (let _key36 in _yocto_poweroutput) {
  if (_key36 === "default") continue;
  Object.defineProperty(exports, _key36, {
    enumerable: true,
    get: function () {
      return _yocto_poweroutput[_key36];
    }
  });
}

var _yocto_pressure = require('yoctolib-es/yocto_pressure');

for (let _key37 in _yocto_pressure) {
  if (_key37 === "default") continue;
  Object.defineProperty(exports, _key37, {
    enumerable: true,
    get: function () {
      return _yocto_pressure[_key37];
    }
  });
}

var _yocto_pwminput = require('yoctolib-es/yocto_pwminput');

for (let _key38 in _yocto_pwminput) {
  if (_key38 === "default") continue;
  Object.defineProperty(exports, _key38, {
    enumerable: true,
    get: function () {
      return _yocto_pwminput[_key38];
    }
  });
}

var _yocto_pwmoutput = require('yoctolib-es/yocto_pwmoutput');

for (let _key39 in _yocto_pwmoutput) {
  if (_key39 === "default") continue;
  Object.defineProperty(exports, _key39, {
    enumerable: true,
    get: function () {
      return _yocto_pwmoutput[_key39];
    }
  });
}

var _yocto_pwmpowersource = require('yoctolib-es/yocto_pwmpowersource');

for (let _key40 in _yocto_pwmpowersource) {
  if (_key40 === "default") continue;
  Object.defineProperty(exports, _key40, {
    enumerable: true,
    get: function () {
      return _yocto_pwmpowersource[_key40];
    }
  });
}

var _yocto_quadraturedecoder = require('yoctolib-es/yocto_quadraturedecoder');

for (let _key41 in _yocto_quadraturedecoder) {
  if (_key41 === "default") continue;
  Object.defineProperty(exports, _key41, {
    enumerable: true,
    get: function () {
      return _yocto_quadraturedecoder[_key41];
    }
  });
}

var _yocto_realtimeclock = require('yoctolib-es/yocto_realtimeclock');

for (let _key42 in _yocto_realtimeclock) {
  if (_key42 === "default") continue;
  Object.defineProperty(exports, _key42, {
    enumerable: true,
    get: function () {
      return _yocto_realtimeclock[_key42];
    }
  });
}

var _yocto_refframe = require('yoctolib-es/yocto_refframe');

for (let _key43 in _yocto_refframe) {
  if (_key43 === "default") continue;
  Object.defineProperty(exports, _key43, {
    enumerable: true,
    get: function () {
      return _yocto_refframe[_key43];
    }
  });
}

var _yocto_relay = require('yoctolib-es/yocto_relay');

for (let _key44 in _yocto_relay) {
  if (_key44 === "default") continue;
  Object.defineProperty(exports, _key44, {
    enumerable: true,
    get: function () {
      return _yocto_relay[_key44];
    }
  });
}

var _yocto_segmenteddisplay = require('yoctolib-es/yocto_segmenteddisplay');

for (let _key45 in _yocto_segmenteddisplay) {
  if (_key45 === "default") continue;
  Object.defineProperty(exports, _key45, {
    enumerable: true,
    get: function () {
      return _yocto_segmenteddisplay[_key45];
    }
  });
}

var _yocto_serialport = require('yoctolib-es/yocto_serialport');

for (let _key46 in _yocto_serialport) {
  if (_key46 === "default") continue;
  Object.defineProperty(exports, _key46, {
    enumerable: true,
    get: function () {
      return _yocto_serialport[_key46];
    }
  });
}

var _yocto_servo = require('yoctolib-es/yocto_servo');

for (let _key47 in _yocto_servo) {
  if (_key47 === "default") continue;
  Object.defineProperty(exports, _key47, {
    enumerable: true,
    get: function () {
      return _yocto_servo[_key47];
    }
  });
}

var _yocto_temperature = require('yoctolib-es/yocto_temperature');

for (let _key48 in _yocto_temperature) {
  if (_key48 === "default") continue;
  Object.defineProperty(exports, _key48, {
    enumerable: true,
    get: function () {
      return _yocto_temperature[_key48];
    }
  });
}

var _yocto_tilt = require('yoctolib-es/yocto_tilt');

for (let _key49 in _yocto_tilt) {
  if (_key49 === "default") continue;
  Object.defineProperty(exports, _key49, {
    enumerable: true,
    get: function () {
      return _yocto_tilt[_key49];
    }
  });
}

var _yocto_voc = require('yoctolib-es/yocto_voc');

for (let _key50 in _yocto_voc) {
  if (_key50 === "default") continue;
  Object.defineProperty(exports, _key50, {
    enumerable: true,
    get: function () {
      return _yocto_voc[_key50];
    }
  });
}

var _yocto_voltage = require('yoctolib-es/yocto_voltage');

for (let _key51 in _yocto_voltage) {
  if (_key51 === "default") continue;
  Object.defineProperty(exports, _key51, {
    enumerable: true,
    get: function () {
      return _yocto_voltage[_key51];
    }
  });
}

var _yocto_wakeupmonitor = require('yoctolib-es/yocto_wakeupmonitor');

for (let _key52 in _yocto_wakeupmonitor) {
  if (_key52 === "default") continue;
  Object.defineProperty(exports, _key52, {
    enumerable: true,
    get: function () {
      return _yocto_wakeupmonitor[_key52];
    }
  });
}

var _yocto_wakeupschedule = require('yoctolib-es/yocto_wakeupschedule');

for (let _key53 in _yocto_wakeupschedule) {
  if (_key53 === "default") continue;
  Object.defineProperty(exports, _key53, {
    enumerable: true,
    get: function () {
      return _yocto_wakeupschedule[_key53];
    }
  });
}

var _yocto_watchdog = require('yoctolib-es/yocto_watchdog');

for (let _key54 in _yocto_watchdog) {
  if (_key54 === "default") continue;
  Object.defineProperty(exports, _key54, {
    enumerable: true,
    get: function () {
      return _yocto_watchdog[_key54];
    }
  });
}

var _yocto_wireless = require('yoctolib-es/yocto_wireless');

for (let _key55 in _yocto_wireless) {
  if (_key55 === "default") continue;
  Object.defineProperty(exports, _key55, {
    enumerable: true,
    get: function () {
      return _yocto_wireless[_key55];
    }
  });
}
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Accelerometer functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YAccelerometer = exports.Y_ZVALUE_INVALID = exports.Y_YVALUE_INVALID = exports.Y_XVALUE_INVALID = exports.Y_GRAVITYCANCELLATION_INVALID = exports.Y_GRAVITYCANCELLATION_ON = exports.Y_GRAVITYCANCELLATION_OFF = undefined;
exports.yFindAccelerometer = yFindAccelerometer;
exports.yFirstAccelerometer = yFirstAccelerometer;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YAccelerometer return codes)
//--- (end of YAccelerometer return codes)
//--- (YAccelerometer definitions)
const Y_GRAVITYCANCELLATION_OFF = exports.Y_GRAVITYCANCELLATION_OFF = 0;
const Y_GRAVITYCANCELLATION_ON = exports.Y_GRAVITYCANCELLATION_ON = 1;
const Y_GRAVITYCANCELLATION_INVALID = exports.Y_GRAVITYCANCELLATION_INVALID = -1;
const Y_XVALUE_INVALID = exports.Y_XVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_YVALUE_INVALID = exports.Y_YVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_ZVALUE_INVALID = exports.Y_ZVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YAccelerometer definitions)

//--- (YAccelerometer class start)
/**
 * YAccelerometer Class: Accelerometer function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of YAccelerometer class start)

class YAccelerometer extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YAccelerometer constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Accelerometer';
        /** @member {number} **/
        this._xValue = Y_XVALUE_INVALID;
        /** @member {number} **/
        this._yValue = Y_YVALUE_INVALID;
        /** @member {number} **/
        this._zValue = Y_ZVALUE_INVALID;
        /** @member {number} **/
        this._gravityCancellation = Y_GRAVITYCANCELLATION_INVALID;
        this.imm_setConst({
            XVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            YVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            ZVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            GRAVITYCANCELLATION_OFF: 0,
            GRAVITYCANCELLATION_ON: 1,
            GRAVITYCANCELLATION_INVALID: -1
        });
        //--- (end of YAccelerometer constructor)
    }

    //--- (YAccelerometer implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'xValue':
                this._xValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'yValue':
                this._yValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'zValue':
                this._zValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'gravityCancellation':
                this._gravityCancellation = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the X component of the acceleration, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the X component of the acceleration, as a
     * floating point number
     *
     * On failure, throws an exception or returns YAccelerometer.XVALUE_INVALID.
     */
    get_xValue() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_XVALUE_INVALID;
                }
            }
            return _this._xValue;
        })();
    }

    /**
     * Returns the Y component of the acceleration, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the Y component of the acceleration, as a
     * floating point number
     *
     * On failure, throws an exception or returns YAccelerometer.YVALUE_INVALID.
     */
    get_yValue() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_YVALUE_INVALID;
                }
            }
            return _this2._yValue;
        })();
    }

    /**
     * Returns the Z component of the acceleration, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the Z component of the acceleration, as a
     * floating point number
     *
     * On failure, throws an exception or returns YAccelerometer.ZVALUE_INVALID.
     */
    get_zValue() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ZVALUE_INVALID;
                }
            }
            return _this3._zValue;
        })();
    }

    get_gravityCancellation() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_GRAVITYCANCELLATION_INVALID;
                }
            }
            return _this4._gravityCancellation;
        })();
    }

    set_gravityCancellation(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this5._setAttr('gravityCancellation', rest_val);
        })();
    }

    /**
     * Retrieves an accelerometer for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the accelerometer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAccelerometer.isOnline() to test if the accelerometer is
     * indeed online at a given time. In case of ambiguity when looking for
     * an accelerometer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the accelerometer
     *
     * @return {YAccelerometer} a YAccelerometer object allowing you to drive the accelerometer.
     */
    static FindAccelerometer(func) {
        /** @type {YAccelerometer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Accelerometer', func);
        if (obj == null) {
            obj = new YAccelerometer(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Accelerometer', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an accelerometer for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the accelerometer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAccelerometer.isOnline() to test if the accelerometer is
     * indeed online at a given time. In case of ambiguity when looking for
     * an accelerometer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the accelerometer
     *
     * @return {YAccelerometer} a YAccelerometer object allowing you to drive the accelerometer.
     */
    static FindAccelerometerInContext(yctx, func) {
        /** @type {YAccelerometer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Accelerometer', func);
        if (obj == null) {
            obj = new YAccelerometer(yctx, func);
            _yocto_api.YFunction._AddToCache('Accelerometer', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of accelerometers started using yFirstAccelerometer().
     *
     * @return {YAccelerometer} a pointer to a YAccelerometer object, corresponding to
     *         an accelerometer currently online, or a null pointer
     *         if there are no more accelerometers to enumerate.
     */
    /* */nextAccelerometer() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YAccelerometer.FindAccelerometerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of accelerometers currently accessible.
     * Use the method YAccelerometer.nextAccelerometer() to iterate on
     * next accelerometers.
     *
     * @return {YAccelerometer} a pointer to a YAccelerometer object, corresponding to
     *         the first accelerometer currently online, or a null pointer
     *         if there are none.
     */
    static FirstAccelerometer() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Accelerometer');
        if (next_hwid == null) return null;
        return YAccelerometer.FindAccelerometer(next_hwid);
    }

    /**
     * Starts the enumeration of accelerometers currently accessible.
     * Use the method YAccelerometer.nextAccelerometer() to iterate on
     * next accelerometers.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YAccelerometer} a pointer to a YAccelerometer object, corresponding to
     *         the first accelerometer currently online, or a null pointer
     *         if there are none.
     */
    static FirstAccelerometerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Accelerometer');
        if (next_hwid == null) return null;
        return YAccelerometer.FindAccelerometerInContext(yctx, next_hwid);
    }

    //--- (end of YAccelerometer implementation)
}

exports.YAccelerometer = YAccelerometer; //--- (Accelerometer functions)

/**
 * comment from .yc definition
 */

function yFindAccelerometer(func) {
    return YAccelerometer.FindAccelerometer(func);
}

/**
 * comment from .yc definition
 */
function yFirstAccelerometer() {
    return YAccelerometer.FirstAccelerometer();
}

//--- (end of Accelerometer functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Altitude functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YAltitude = exports.Y_TECHNOLOGY_INVALID = exports.Y_QNH_INVALID = undefined;
exports.yFindAltitude = yFindAltitude;
exports.yFirstAltitude = yFirstAltitude;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YAltitude return codes)
//--- (end of YAltitude return codes)
//--- (YAltitude definitions)
const Y_QNH_INVALID = exports.Y_QNH_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_TECHNOLOGY_INVALID = exports.Y_TECHNOLOGY_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YAltitude definitions)

//--- (YAltitude class start)
/**
 * YAltitude Class: Altitude function interface
 *
 * The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude
 * sensors. It inherits from the YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to configure the barometric pressure adjusted to
 * sea level (QNH) for barometric sensors.
 */
//--- (end of YAltitude class start)

class YAltitude extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YAltitude constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Altitude';
        /** @member {number} **/
        this._qnh = Y_QNH_INVALID;
        /** @member {string} **/
        this._technology = Y_TECHNOLOGY_INVALID;
        this.imm_setConst({
            QNH_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            TECHNOLOGY_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YAltitude constructor)
    }

    //--- (YAltitude implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'qnh':
                this._qnh = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'technology':
                this._technology = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the current estimated altitude. This allows to compensate for
     * ambient pressure variations and to work in relative mode.
     *
     * @param newval {number} : a floating point number corresponding to the current estimated altitude
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_currentValue(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this._setAttr('currentValue', rest_val);
        })();
    }

    /**
     * Changes the barometric pressure adjusted to sea level used to compute
     * the altitude (QNH). This enables you to compensate for atmospheric pressure
     * changes due to weather conditions.
     *
     * @param newval {number} : a floating point number corresponding to the barometric pressure adjusted
     * to sea level used to compute
     *         the altitude (QNH)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_qnh(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this2._setAttr('qnh', rest_val);
        })();
    }

    /**
     * Returns the barometric pressure adjusted to sea level used to compute
     * the altitude (QNH).
     *
     * @return {number} a floating point number corresponding to the barometric pressure adjusted to sea
     * level used to compute
     *         the altitude (QNH)
     *
     * On failure, throws an exception or returns YAltitude.QNH_INVALID.
     */
    get_qnh() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_QNH_INVALID;
                }
            }
            return _this3._qnh;
        })();
    }

    /**
     * Returns the technology used by the sesnor to compute
     * altitude. Possibles values are  "barometric" and "gps"
     *
     * @return {string} a string corresponding to the technology used by the sesnor to compute
     *         altitude
     *
     * On failure, throws an exception or returns YAltitude.TECHNOLOGY_INVALID.
     */
    get_technology() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TECHNOLOGY_INVALID;
                }
            }
            return _this4._technology;
        })();
    }

    /**
     * Retrieves an altimeter for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the altimeter is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAltitude.isOnline() to test if the altimeter is
     * indeed online at a given time. In case of ambiguity when looking for
     * an altimeter by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the altimeter
     *
     * @return {YAltitude} a YAltitude object allowing you to drive the altimeter.
     */
    static FindAltitude(func) {
        /** @type {YAltitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Altitude', func);
        if (obj == null) {
            obj = new YAltitude(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Altitude', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an altimeter for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the altimeter is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAltitude.isOnline() to test if the altimeter is
     * indeed online at a given time. In case of ambiguity when looking for
     * an altimeter by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the altimeter
     *
     * @return {YAltitude} a YAltitude object allowing you to drive the altimeter.
     */
    static FindAltitudeInContext(yctx, func) {
        /** @type {YAltitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Altitude', func);
        if (obj == null) {
            obj = new YAltitude(yctx, func);
            _yocto_api.YFunction._AddToCache('Altitude', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of altimeters started using yFirstAltitude().
     *
     * @return {YAltitude} a pointer to a YAltitude object, corresponding to
     *         an altimeter currently online, or a null pointer
     *         if there are no more altimeters to enumerate.
     */
    /* */nextAltitude() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YAltitude.FindAltitudeInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of altimeters currently accessible.
     * Use the method YAltitude.nextAltitude() to iterate on
     * next altimeters.
     *
     * @return {YAltitude} a pointer to a YAltitude object, corresponding to
     *         the first altimeter currently online, or a null pointer
     *         if there are none.
     */
    static FirstAltitude() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Altitude');
        if (next_hwid == null) return null;
        return YAltitude.FindAltitude(next_hwid);
    }

    /**
     * Starts the enumeration of altimeters currently accessible.
     * Use the method YAltitude.nextAltitude() to iterate on
     * next altimeters.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YAltitude} a pointer to a YAltitude object, corresponding to
     *         the first altimeter currently online, or a null pointer
     *         if there are none.
     */
    static FirstAltitudeInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Altitude');
        if (next_hwid == null) return null;
        return YAltitude.FindAltitudeInContext(yctx, next_hwid);
    }

    //--- (end of YAltitude implementation)
}

exports.YAltitude = YAltitude; //--- (Altitude functions)

/**
 * comment from .yc definition
 */

function yFindAltitude(func) {
    return YAltitude.FindAltitude(func);
}

/**
 * comment from .yc definition
 */
function yFirstAltitude() {
    return YAltitude.FirstAltitude();
}

//--- (end of Altitude functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for AnButton functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YAnButton = exports.Y_PULSETIMER_INVALID = exports.Y_PULSECOUNTER_INVALID = exports.Y_LASTTIMERELEASED_INVALID = exports.Y_LASTTIMEPRESSED_INVALID = exports.Y_SENSITIVITY_INVALID = exports.Y_CALIBRATIONMIN_INVALID = exports.Y_CALIBRATIONMAX_INVALID = exports.Y_RAWVALUE_INVALID = exports.Y_CALIBRATEDVALUE_INVALID = exports.Y_ISPRESSED_INVALID = exports.Y_ISPRESSED_TRUE = exports.Y_ISPRESSED_FALSE = exports.Y_ANALOGCALIBRATION_INVALID = exports.Y_ANALOGCALIBRATION_ON = exports.Y_ANALOGCALIBRATION_OFF = undefined;
exports.yFindAnButton = yFindAnButton;
exports.yFirstAnButton = yFirstAnButton;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YAnButton return codes)
//--- (end of YAnButton return codes)
//--- (YAnButton definitions)
const Y_ANALOGCALIBRATION_OFF = exports.Y_ANALOGCALIBRATION_OFF = 0;
const Y_ANALOGCALIBRATION_ON = exports.Y_ANALOGCALIBRATION_ON = 1;
const Y_ANALOGCALIBRATION_INVALID = exports.Y_ANALOGCALIBRATION_INVALID = -1;
const Y_ISPRESSED_FALSE = exports.Y_ISPRESSED_FALSE = 0;
const Y_ISPRESSED_TRUE = exports.Y_ISPRESSED_TRUE = 1;
const Y_ISPRESSED_INVALID = exports.Y_ISPRESSED_INVALID = -1;
const Y_CALIBRATEDVALUE_INVALID = exports.Y_CALIBRATEDVALUE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_RAWVALUE_INVALID = exports.Y_RAWVALUE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_CALIBRATIONMAX_INVALID = exports.Y_CALIBRATIONMAX_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_CALIBRATIONMIN_INVALID = exports.Y_CALIBRATIONMIN_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_SENSITIVITY_INVALID = exports.Y_SENSITIVITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LASTTIMEPRESSED_INVALID = exports.Y_LASTTIMEPRESSED_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_LASTTIMERELEASED_INVALID = exports.Y_LASTTIMERELEASED_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_PULSECOUNTER_INVALID = exports.Y_PULSECOUNTER_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_PULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YAnButton definitions)

//--- (YAnButton class start)
/**
 * YAnButton Class: AnButton function interface
 *
 * Yoctopuce application programming interface allows you to measure the state
 * of a simple button as well as to read an analog potentiometer (variable resistance).
 * This can be use for instance with a continuous rotating knob, a throttle grip
 * or a joystick. The module is capable to calibrate itself on min and max values,
 * in order to compute a calibrated value that varies proportionally with the
 * potentiometer position, regardless of its total resistance.
 */
//--- (end of YAnButton class start)

class YAnButton extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YAnButton constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'AnButton';
        /** @member {number} **/
        this._calibratedValue = Y_CALIBRATEDVALUE_INVALID;
        /** @member {number} **/
        this._rawValue = Y_RAWVALUE_INVALID;
        /** @member {number} **/
        this._analogCalibration = Y_ANALOGCALIBRATION_INVALID;
        /** @member {number} **/
        this._calibrationMax = Y_CALIBRATIONMAX_INVALID;
        /** @member {number} **/
        this._calibrationMin = Y_CALIBRATIONMIN_INVALID;
        /** @member {number} **/
        this._sensitivity = Y_SENSITIVITY_INVALID;
        /** @member {number} **/
        this._isPressed = Y_ISPRESSED_INVALID;
        /** @member {number} **/
        this._lastTimePressed = Y_LASTTIMEPRESSED_INVALID;
        /** @member {number} **/
        this._lastTimeReleased = Y_LASTTIMERELEASED_INVALID;
        /** @member {number} **/
        this._pulseCounter = Y_PULSECOUNTER_INVALID;
        /** @member {number} **/
        this._pulseTimer = Y_PULSETIMER_INVALID;
        this.imm_setConst({
            CALIBRATEDVALUE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            RAWVALUE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            ANALOGCALIBRATION_OFF: 0,
            ANALOGCALIBRATION_ON: 1,
            ANALOGCALIBRATION_INVALID: -1,
            CALIBRATIONMAX_INVALID: _yocto_api.YAPI.INVALID_UINT,
            CALIBRATIONMIN_INVALID: _yocto_api.YAPI.INVALID_UINT,
            SENSITIVITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            ISPRESSED_FALSE: 0,
            ISPRESSED_TRUE: 1,
            ISPRESSED_INVALID: -1,
            LASTTIMEPRESSED_INVALID: _yocto_api.YAPI.INVALID_LONG,
            LASTTIMERELEASED_INVALID: _yocto_api.YAPI.INVALID_LONG,
            PULSECOUNTER_INVALID: _yocto_api.YAPI.INVALID_LONG,
            PULSETIMER_INVALID: _yocto_api.YAPI.INVALID_LONG
        });
        //--- (end of YAnButton constructor)
    }

    //--- (YAnButton implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'calibratedValue':
                this._calibratedValue = parseInt(val);
                return 1;
            case 'rawValue':
                this._rawValue = parseInt(val);
                return 1;
            case 'analogCalibration':
                this._analogCalibration = parseInt(val);
                return 1;
            case 'calibrationMax':
                this._calibrationMax = parseInt(val);
                return 1;
            case 'calibrationMin':
                this._calibrationMin = parseInt(val);
                return 1;
            case 'sensitivity':
                this._sensitivity = parseInt(val);
                return 1;
            case 'isPressed':
                this._isPressed = parseInt(val);
                return 1;
            case 'lastTimePressed':
                this._lastTimePressed = parseInt(val);
                return 1;
            case 'lastTimeReleased':
                this._lastTimeReleased = parseInt(val);
                return 1;
            case 'pulseCounter':
                this._pulseCounter = parseInt(val);
                return 1;
            case 'pulseTimer':
                this._pulseTimer = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current calibrated input value (between 0 and 1000, included).
     *
     * @return {number} an integer corresponding to the current calibrated input value (between 0 and 1000, included)
     *
     * On failure, throws an exception or returns YAnButton.CALIBRATEDVALUE_INVALID.
     */
    get_calibratedValue() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALIBRATEDVALUE_INVALID;
                }
            }
            return _this._calibratedValue;
        })();
    }

    /**
     * Returns the current measured input value as-is (between 0 and 4095, included).
     *
     * @return {number} an integer corresponding to the current measured input value as-is (between 0 and
     * 4095, included)
     *
     * On failure, throws an exception or returns YAnButton.RAWVALUE_INVALID.
     */
    get_rawValue() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RAWVALUE_INVALID;
                }
            }
            return _this2._rawValue;
        })();
    }

    /**
     * Tells if a calibration process is currently ongoing.
     *
     * @return {number} either YAnButton.ANALOGCALIBRATION_OFF or YAnButton.ANALOGCALIBRATION_ON
     *
     * On failure, throws an exception or returns YAnButton.ANALOGCALIBRATION_INVALID.
     */
    get_analogCalibration() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ANALOGCALIBRATION_INVALID;
                }
            }
            return _this3._analogCalibration;
        })();
    }

    /**
     * Starts or stops the calibration process. Remember to call the saveToFlash()
     * method of the module at the end of the calibration if the modification must be kept.
     *
     * @param newval {number} : either YAnButton.ANALOGCALIBRATION_OFF or YAnButton.ANALOGCALIBRATION_ON
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_analogCalibration(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('analogCalibration', rest_val);
        })();
    }

    /**
     * Returns the maximal value measured during the calibration (between 0 and 4095, included).
     *
     * @return {number} an integer corresponding to the maximal value measured during the calibration
     * (between 0 and 4095, included)
     *
     * On failure, throws an exception or returns YAnButton.CALIBRATIONMAX_INVALID.
     */
    get_calibrationMax() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALIBRATIONMAX_INVALID;
                }
            }
            return _this5._calibrationMax;
        })();
    }

    /**
     * Changes the maximal calibration value for the input (between 0 and 4095, included), without actually
     * starting the automated calibration.  Remember to call the saveToFlash()
     * method of the module if the modification must be kept.
     *
     * @param newval {number} : an integer corresponding to the maximal calibration value for the input
     * (between 0 and 4095, included), without actually
     *         starting the automated calibration
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_calibrationMax(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('calibrationMax', rest_val);
        })();
    }

    /**
     * Returns the minimal value measured during the calibration (between 0 and 4095, included).
     *
     * @return {number} an integer corresponding to the minimal value measured during the calibration
     * (between 0 and 4095, included)
     *
     * On failure, throws an exception or returns YAnButton.CALIBRATIONMIN_INVALID.
     */
    get_calibrationMin() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALIBRATIONMIN_INVALID;
                }
            }
            return _this7._calibrationMin;
        })();
    }

    /**
     * Changes the minimal calibration value for the input (between 0 and 4095, included), without actually
     * starting the automated calibration.  Remember to call the saveToFlash()
     * method of the module if the modification must be kept.
     *
     * @param newval {number} : an integer corresponding to the minimal calibration value for the input
     * (between 0 and 4095, included), without actually
     *         starting the automated calibration
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_calibrationMin(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('calibrationMin', rest_val);
        })();
    }

    /**
     * Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.
     *
     * @return {number} an integer corresponding to the sensibility for the input (between 1 and 1000) for
     * triggering user callbacks
     *
     * On failure, throws an exception or returns YAnButton.SENSITIVITY_INVALID.
     */
    get_sensitivity() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SENSITIVITY_INVALID;
                }
            }
            return _this9._sensitivity;
        })();
    }

    /**
     * Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.
     * The sensibility is used to filter variations around a fixed value, but does not preclude the
     * transmission of events when the input value evolves constantly in the same direction.
     * Special case: when the value 1000 is used, the callback will only be thrown when the logical state
     * of the input switches from pressed to released and back.
     * Remember to call the saveToFlash() method of the module if the modification must be kept.
     *
     * @param newval {number} : an integer corresponding to the sensibility for the input (between 1 and
     * 1000) for triggering user callbacks
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_sensitivity(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('sensitivity', rest_val);
        })();
    }

    /**
     * Returns true if the input (considered as binary) is active (closed contact), and false otherwise.
     *
     * @return {number} either YAnButton.ISPRESSED_FALSE or YAnButton.ISPRESSED_TRUE, according to true if
     * the input (considered as binary) is active (closed contact), and false otherwise
     *
     * On failure, throws an exception or returns YAnButton.ISPRESSED_INVALID.
     */
    get_isPressed() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ISPRESSED_INVALID;
                }
            }
            return _this11._isPressed;
        })();
    }

    /**
     * Returns the number of elapsed milliseconds between the module power on and the last time
     * the input button was pressed (the input contact transitioned from open to closed).
     *
     * @return {number} an integer corresponding to the number of elapsed milliseconds between the module
     * power on and the last time
     *         the input button was pressed (the input contact transitioned from open to closed)
     *
     * On failure, throws an exception or returns YAnButton.LASTTIMEPRESSED_INVALID.
     */
    get_lastTimePressed() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LASTTIMEPRESSED_INVALID;
                }
            }
            return _this12._lastTimePressed;
        })();
    }

    /**
     * Returns the number of elapsed milliseconds between the module power on and the last time
     * the input button was released (the input contact transitioned from closed to open).
     *
     * @return {number} an integer corresponding to the number of elapsed milliseconds between the module
     * power on and the last time
     *         the input button was released (the input contact transitioned from closed to open)
     *
     * On failure, throws an exception or returns YAnButton.LASTTIMERELEASED_INVALID.
     */
    get_lastTimeReleased() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LASTTIMERELEASED_INVALID;
                }
            }
            return _this13._lastTimeReleased;
        })();
    }

    /**
     * Returns the pulse counter value
     *
     * @return {number} an integer corresponding to the pulse counter value
     *
     * On failure, throws an exception or returns YAnButton.PULSECOUNTER_INVALID.
     */
    get_pulseCounter() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSECOUNTER_INVALID;
                }
            }
            return _this14._pulseCounter;
        })();
    }

    set_pulseCounter(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this15._setAttr('pulseCounter', rest_val);
        })();
    }

    /**
     * Returns the timer of the pulses counter (ms)
     *
     * @return {number} an integer corresponding to the timer of the pulses counter (ms)
     *
     * On failure, throws an exception or returns YAnButton.PULSETIMER_INVALID.
     */
    get_pulseTimer() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._cacheExpiration <= _this16._yapi.GetTickCount()) {
                if ((yield _this16.load(_this16._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSETIMER_INVALID;
                }
            }
            return _this16._pulseTimer;
        })();
    }

    /**
     * Retrieves an analog input for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the analog input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAnButton.isOnline() to test if the analog input is
     * indeed online at a given time. In case of ambiguity when looking for
     * an analog input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the analog input
     *
     * @return {YAnButton} a YAnButton object allowing you to drive the analog input.
     */
    static FindAnButton(func) {
        /** @type {YAnButton} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('AnButton', func);
        if (obj == null) {
            obj = new YAnButton(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('AnButton', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an analog input for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the analog input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAnButton.isOnline() to test if the analog input is
     * indeed online at a given time. In case of ambiguity when looking for
     * an analog input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the analog input
     *
     * @return {YAnButton} a YAnButton object allowing you to drive the analog input.
     */
    static FindAnButtonInContext(yctx, func) {
        /** @type {YAnButton} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'AnButton', func);
        if (obj == null) {
            obj = new YAnButton(yctx, func);
            _yocto_api.YFunction._AddToCache('AnButton', func, obj);
        }
        return obj;
    }

    /**
     * Returns the pulse counter value as well as its timer.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    resetCounter() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            return yield _this17.set_pulseCounter(0);
        })();
    }

    /**
     * Continues the enumeration of analog inputs started using yFirstAnButton().
     *
     * @return {YAnButton} a pointer to a YAnButton object, corresponding to
     *         an analog input currently online, or a null pointer
     *         if there are no more analog inputs to enumerate.
     */
    /* */nextAnButton() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YAnButton.FindAnButtonInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of analog inputs currently accessible.
     * Use the method YAnButton.nextAnButton() to iterate on
     * next analog inputs.
     *
     * @return {YAnButton} a pointer to a YAnButton object, corresponding to
     *         the first analog input currently online, or a null pointer
     *         if there are none.
     */
    static FirstAnButton() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('AnButton');
        if (next_hwid == null) return null;
        return YAnButton.FindAnButton(next_hwid);
    }

    /**
     * Starts the enumeration of analog inputs currently accessible.
     * Use the method YAnButton.nextAnButton() to iterate on
     * next analog inputs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YAnButton} a pointer to a YAnButton object, corresponding to
     *         the first analog input currently online, or a null pointer
     *         if there are none.
     */
    static FirstAnButtonInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('AnButton');
        if (next_hwid == null) return null;
        return YAnButton.FindAnButtonInContext(yctx, next_hwid);
    }

    //--- (end of YAnButton implementation)
}

exports.YAnButton = YAnButton; //--- (AnButton functions)

/**
 * comment from .yc definition
 */

function yFindAnButton(func) {
    return YAnButton.FindAnButton(func);
}

/**
 * comment from .yc definition
 */
function yFirstAnButton() {
    return YAnButton.FirstAnButton();
}

//--- (end of AnButton functions)
/*********************************************************************
 *
 * $Id: yocto_api.es7 22052 2015-11-20 16:17:46Z mvuilleu $
 *
 * High-level programming interface, common to all modules
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate http
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/
'use strict';

//--- (generated code: YFunction definitions)
// Yoctopuce error codes, also used by default as function return value

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.yFindModule = yFindModule;
exports.yFirstModule = yFirstModule;
exports.yFindSensor = yFindSensor;
exports.yFirstSensor = yFirstSensor;
exports.yGetAPIVersion = yGetAPIVersion;
exports.yInitAPI = yInitAPI;
exports.yFreeAPI = yFreeAPI;
exports.yDisableExceptions = yDisableExceptions;
exports.yEnableExceptions = yEnableExceptions;
exports.yRegisterHub = yRegisterHub;
exports.yPreregisterHub = yPreregisterHub;
exports.yUnregisterHub = yUnregisterHub;
exports.yUpdateDeviceList = yUpdateDeviceList;
exports.yHandleEvents = yHandleEvents;
exports.ySleep = ySleep;
exports.yGetTickCount = yGetTickCount;
exports.yCheckLogicalName = yCheckLogicalName;
exports.yRegisterDeviceArrivalCallback = yRegisterDeviceArrivalCallback;
exports.yRegisterDeviceChangeCallback = yRegisterDeviceChangeCallback;
exports.yRegisterDeviceRemovalCallback = yRegisterDeviceRemovalCallback;
exports.yRegisterCalibrationHandler = yRegisterCalibrationHandler;

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

const YAPI_SUCCESS = exports.YAPI_SUCCESS = 0; // everything worked all right
const YAPI_NOT_INITIALIZED = exports.YAPI_NOT_INITIALIZED = -1; // call yInitAPI() first !
const YAPI_INVALID_ARGUMENT = exports.YAPI_INVALID_ARGUMENT = -2; // one of the arguments passed to the function is invalid
const YAPI_NOT_SUPPORTED = exports.YAPI_NOT_SUPPORTED = -3; // the operation attempted is (currently) not supported
const YAPI_DEVICE_NOT_FOUND = exports.YAPI_DEVICE_NOT_FOUND = -4; // the requested device is not reachable
const YAPI_VERSION_MISMATCH = exports.YAPI_VERSION_MISMATCH = -5; // the device firmware is incompatible with this API version
const YAPI_DEVICE_BUSY = exports.YAPI_DEVICE_BUSY = -6; // the device is busy with another task and cannot answer
const YAPI_TIMEOUT = exports.YAPI_TIMEOUT = -7; // the device took too long to provide an answer
const YAPI_IO_ERROR = exports.YAPI_IO_ERROR = -8; // there was an I/O problem while talking to the device
const YAPI_NO_MORE_DATA = exports.YAPI_NO_MORE_DATA = -9; // there is no more data to read from
const YAPI_EXHAUSTED = exports.YAPI_EXHAUSTED = -10; // you have run out of a limited resource, check the documentation
const YAPI_DOUBLE_ACCES = exports.YAPI_DOUBLE_ACCES = -11; // you have two process that try to access to the same device
const YAPI_UNAUTHORIZED = exports.YAPI_UNAUTHORIZED = -12; // unauthorized access to password-protected device
const YAPI_RTC_NOT_READY = exports.YAPI_RTC_NOT_READY = -13; // real-time clock has not been initialized (or time was lost)
const YAPI_FILE_NOT_FOUND = exports.YAPI_FILE_NOT_FOUND = -14; // the file is not found

const YAPI_INVALID_INT = exports.YAPI_INVALID_INT = 0x7fffffff;
const YAPI_INVALID_UINT = exports.YAPI_INVALID_UINT = -1;
const YAPI_INVALID_LONG = exports.YAPI_INVALID_LONG = 0x7fffffffffffffff;
const YAPI_INVALID_DOUBLE = exports.YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
const YAPI_INVALID_STRING = exports.YAPI_INVALID_STRING = '!INVALID!';
const Y_FUNCTIONDESCRIPTOR_INVALID = exports.Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
const Y_HARDWAREID_INVALID = exports.Y_HARDWAREID_INVALID = YAPI_INVALID_STRING;
const Y_FUNCTIONID_INVALID = exports.Y_FUNCTIONID_INVALID = YAPI_INVALID_STRING;
const Y_FRIENDLYNAME_INVALID = exports.Y_FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
const Y_LOGICALNAME_INVALID = exports.Y_LOGICALNAME_INVALID = YAPI_INVALID_STRING;
const Y_ADVERTISEDVALUE_INVALID = exports.Y_ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
//--- (end of generated code: YFunction definitions)

//--- (generated code: YModule definitions)
const Y_PERSISTENTSETTINGS_LOADED = exports.Y_PERSISTENTSETTINGS_LOADED = 0;
const Y_PERSISTENTSETTINGS_SAVED = exports.Y_PERSISTENTSETTINGS_SAVED = 1;
const Y_PERSISTENTSETTINGS_MODIFIED = exports.Y_PERSISTENTSETTINGS_MODIFIED = 2;
const Y_PERSISTENTSETTINGS_INVALID = exports.Y_PERSISTENTSETTINGS_INVALID = -1;
const Y_BEACON_OFF = exports.Y_BEACON_OFF = 0;
const Y_BEACON_ON = exports.Y_BEACON_ON = 1;
const Y_BEACON_INVALID = exports.Y_BEACON_INVALID = -1;
const Y_PRODUCTNAME_INVALID = exports.Y_PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
const Y_SERIALNUMBER_INVALID = exports.Y_SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
const Y_PRODUCTID_INVALID = exports.Y_PRODUCTID_INVALID = YAPI_INVALID_UINT;
const Y_PRODUCTRELEASE_INVALID = exports.Y_PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
const Y_FIRMWARERELEASE_INVALID = exports.Y_FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
const Y_LUMINOSITY_INVALID = exports.Y_LUMINOSITY_INVALID = YAPI_INVALID_UINT;
const Y_UPTIME_INVALID = exports.Y_UPTIME_INVALID = YAPI_INVALID_LONG;
const Y_USBCURRENT_INVALID = exports.Y_USBCURRENT_INVALID = YAPI_INVALID_UINT;
const Y_REBOOTCOUNTDOWN_INVALID = exports.Y_REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
const Y_USERVAR_INVALID = exports.Y_USERVAR_INVALID = YAPI_INVALID_INT;
//--- (end of generated code: YModule definitions)

//--- (generated code: YSensor definitions)
const Y_UNIT_INVALID = exports.Y_UNIT_INVALID = YAPI_INVALID_STRING;
const Y_CURRENTVALUE_INVALID = exports.Y_CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_LOWESTVALUE_INVALID = exports.Y_LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_HIGHESTVALUE_INVALID = exports.Y_HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_CURRENTRAWVALUE_INVALID = exports.Y_CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_LOGFREQUENCY_INVALID = exports.Y_LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
const Y_REPORTFREQUENCY_INVALID = exports.Y_REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
const Y_CALIBRATIONPARAM_INVALID = exports.Y_CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
const Y_RESOLUTION_INVALID = exports.Y_RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
const Y_SENSORSTATE_INVALID = exports.Y_SENSORSTATE_INVALID = YAPI_INVALID_INT;
//--- (end of generated code: YSensor definitions)

const Y_DATA_INVALID = exports.Y_DATA_INVALID = YAPI_INVALID_DOUBLE;
const Y_DURATION_INVALID = exports.Y_DURATION_INVALID = YAPI_INVALID_INT;

// yInitAPI constants (not really useful in Javascript, but defined for code portability)
const Y_DETECT_NONE = exports.Y_DETECT_NONE = 0;
const Y_DETECT_USB = exports.Y_DETECT_USB = 1;
const Y_DETECT_NET = exports.Y_DETECT_NET = 2;
const Y_DETECT_ALL = exports.Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;

// calibration types
const YOCTO_CALIB_TYPE_OFS = 30;

const NOTIFY_NETPKT_NAME = '0';
const NOTIFY_NETPKT_CHILD = '2';
const NOTIFY_NETPKT_FUNCNAME = '4';
const NOTIFY_NETPKT_FUNCVAL = '5';
const NOTIFY_NETPKT_LOG = '7';
const NOTIFY_NETPKT_FUNCNAMEYDX = '8';
const NOTIFY_NETPKT_FLUSHV2YDX = 't';
const NOTIFY_NETPKT_FUNCV2YDX = 'u';
const NOTIFY_NETPKT_TIMEV2YDX = 'v';
const NOTIFY_NETPKT_DEVLOGYDX = 'w';
const NOTIFY_NETPKT_TIMEVALYDX = 'x';
const NOTIFY_NETPKT_FUNCVALYDX = 'y';
const NOTIFY_NETPKT_TIMEAVGYDX = 'z';
const NOTIFY_NETPKT_NOT_SYNC = '@';
const NOTIFY_NETPKT_STOP = 10; // =\n

const NOTIFY_V2_LEGACY = 0; // unused (reserved for compatibility with legacy notifications)
const NOTIFY_V2_6RAWBYTES = 1; // largest type: data is always 6 bytes
const NOTIFY_V2_TYPEDDATA = 2; // other types: first data byte holds the decoding format
const NOTIFY_V2_FLUSHGROUP = 3; // no data associated

const PUBVAL_LEGACY = 0; // 0-6 ASCII characters (normally sent as YSTREAM_NOTICE)
const PUBVAL_1RAWBYTE = 1; // 1 raw byte  (=2 characters)
const PUBVAL_2RAWBYTES = 2; // 2 raw bytes (=4 characters)
const PUBVAL_3RAWBYTES = 3; // 3 raw bytes (=6 characters)
const PUBVAL_4RAWBYTES = 4; // 4 raw bytes (=8 characters)
const PUBVAL_5RAWBYTES = 5; // 5 raw bytes (=10 characters)
const PUBVAL_6RAWBYTES = 6; // 6 hex bytes (=12 characters) (sent as V2_6RAWBYTES)
const PUBVAL_C_LONG = 7; // 32-bit C signed integer
const PUBVAL_C_FLOAT = 8; // 32-bit C float
const PUBVAL_YOCTO_FLOAT_E3 = 9; // 32-bit Yocto fixed-point format (e-3)
const PUBVAL_YOCTO_FLOAT_E6 = 10; // 32-bit Yocto fixed-point format (e-6)

const YOCTO_PUBVAL_LEN = 16;
const YOCTO_PUBVAL_SIZE = 6;

const Y_BASETYPES = { Function: 0, Sensor: 1 };

class YErrorMsg {
    constructor() {
        let str_msg = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

        this.msg = str_msg;
    }
}

exports.YErrorMsg = YErrorMsg; //
// YFunctionType Class (used internally)
//
// Instances of this class stores everything we know about a given type of function:
// Mapping between function logical names and Hardware ID as discovered on hubs,
// and existing instances of YFunction (either already connected or simply requested).
// To keep it simple, this implementation separates completely the name resolution
// mechanism, implemented using the yellow pages, and the storage and retrieval of
// existing YFunction instances.
//

class YFunctionType {
    constructor(obj_yapi, str_classname) {
        // private
        /** @member {YAPIContext} **/
        this._yapi = obj_yapi;
        /** @member {string} **/
        this._className = str_classname;
        /** @member {Object} **/
        this._connectedFns = {}; // functions requested and available, by Hardware Id
        /** @member {Object} **/
        this._requestedFns = {}; // functions requested but not yet known, by any type of name
        /** @member {Object} **/
        this._hwIdByName = {}; // hash table of function Hardware Id by logical name
        /** @member {Object} **/
        this._nameByHwId = {}; // hash table of function logical name by Hardware Id
        /** @member {Object} **/
        this._valueByHwId = {}; // hash table of function advertised value by logical name
        /** @member {number} **/
        this._baseType = 0; // default to no abstract base type (generic YFunction)
    }

    /** Index a single function given by HardwareId and logical name; store any advertised value
     *
     * @param {string} str_hwid
     * @param {string} str_name
     * @param {string|null} str_val
     * @param {number|null} int_basetype
     * @returns {boolean} true iff there was a logical name discrepancy
     */
    imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
        var currname = this._nameByHwId[str_hwid];
        var res = false;
        if (currname == undefined || currname == '') {
            if (str_name != '') {
                this._nameByHwId[str_hwid] = str_name;
                res = true;
            }
        } else if (currname != str_name) {
            if (this._hwIdByName[currname] == str_hwid) delete this._hwIdByName[currname];
            if (str_name != '') {
                this._nameByHwId[str_hwid] = str_name;
            } else {
                delete this._nameByHwId[str_hwid];
            }
            res = true;
        }
        if (str_name != '') {
            this._hwIdByName[str_name] = str_hwid;
        }
        if (str_val != undefined) {
            this._valueByHwId[str_hwid] = str_val;
        } else {
            if (this._valueByHwId[str_hwid] == undefined) {
                this._valueByHwId[str_hwid] = '';
            }
        }
        if (int_basetype != undefined) {
            if (this._baseType == 0) {
                this._baseType = int_basetype;
            }
        }
        return res;
    }

    /** Forget a disconnected function given by HardwareId
     *
     * @param {string} str_hwid
     */
    imm_forgetFunction(str_hwid) {
        var currname = this._nameByHwId[str_hwid];
        if (currname != undefined) {
            if (currname != '' && this._hwIdByName[currname] == str_hwid) {
                delete this._hwIdByName[currname];
            }
            delete this._nameByHwId[str_hwid];
        }
        if (this._valueByHwId[str_hwid] != undefined) {
            delete this._valueByHwId[str_hwid];
        }
    }

    /** Find the exact Hardware Id of the specified function, if currently connected
     * If device is not known as connected, return a clean error
     * This function will not cause any network access
     *
     * @param {string} str_func
     * @return {object}
     */
    imm_resolve(str_func) {
        var dotpos = str_func.indexOf('.');
        var res;
        if (dotpos < 0) {
            // First case: str_func is the logicalname of a function
            res = this._hwIdByName[str_func];
            if (res != undefined) {
                return { errorType: YAPI_SUCCESS,
                    errorMsg: 'no error',
                    result: String(res) };
            }

            // fallback to assuming that str_func is a logicalname or serial number of a module
            // with an implicit function name (like serial.module for instance)
            dotpos = str_func.length;
            str_func += '.' + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
        }

        // Second case: str_func is in the form: device_id.function_id

        // quick lookup for a known pure hardware id
        if (this._valueByHwId[str_func] != undefined) {
            return { errorType: YAPI_SUCCESS,
                errorMsg: 'no error',
                result: String(str_func) };
        }
        if (dotpos > 0) {
            // either the device id is a logical name, or the function is unknown
            var devid = str_func.substr(0, dotpos);
            var funcid = str_func.substr(dotpos + 1);
            var dev = this._yapi.imm_getDevice(devid);
            if (!dev) {
                return { errorType: YAPI_DEVICE_NOT_FOUND,
                    errorMsg: 'Device [' + devid + '] not online',
                    result: null };
            }
            var serial = dev.imm_getSerialNumber();
            res = serial + '.' + funcid;
            if (this._valueByHwId[res] != undefined) {
                return { errorType: YAPI_SUCCESS,
                    errorMsg: 'no error',
                    result: String(res) };
            }

            // not found neither, may be funcid is a function logicalname
            var i,
                nfun = dev.imm_functionCount();
            for (i = 0; i < nfun; i++) {
                res = serial + '.' + dev.imm_functionId(i);
                var name = this._nameByHwId[res];
                if (name != undefined && name == funcid) {
                    return { errorType: YAPI_SUCCESS,
                        errorMsg: 'no error',
                        result: String(res) };
                }
            }
        } else {
            funcid = str_func.substr(1);
            for (var hwid_str in this._connectedFns) {
                var pos = hwid_str.indexOf('.');
                var str_function = hwid_str.substr(pos + 1);
                if (str_function == funcid) {
                    return { errorType: YAPI_SUCCESS,
                        errorMsg: 'no error',
                        result: String(hwid_str) };
                }
            }
        }
        return { errorType: YAPI_DEVICE_NOT_FOUND,
            errorMsg: 'No function [' + funcid + '] found on device [' + serial + ']',
            result: null };
    }

    /** Find the friendly name (use logical name if available) of the specified function, if currently connected
     * If device is not known as connected, return a clean error
     * This function will not cause any network access
     *
     * @param {string} str_func
     * @return {object}
     */
    imm_getFriendlyName(str_func) {
        var resolved = this.imm_resolve(str_func);
        var name;
        if (resolved.errorType != YAPI_SUCCESS) {
            return resolved;
        }
        if (this._className == 'Module') {
            var friend = resolved.result;
            name = this._nameByHwId[resolved.result];
            if (name != undefined && name != '') {
                friend = this._nameByHwId[resolved.result];
            }
            return { errorType: YAPI_SUCCESS,
                errorMsg: 'no error',
                result: String(friend) };
        } else {
            var pos = resolved.result.indexOf('.');
            var str_serialMod = resolved.result.substr(0, pos);
            var str_friendModFull = this._yapi.imm_getFriendlyNameFunction('Module', str_serialMod).result;
            var int_friendModDot = str_friendModFull.indexOf('.');
            var str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
            var str_friendFunc = resolved.result.substr(pos + 1);
            name = this._nameByHwId[resolved.result];
            if (name != undefined && name != '') {
                str_friendFunc = name;
            }
            return { errorType: YAPI_SUCCESS,
                errorMsg: 'no error',
                result: String(str_friendMod + '.' + str_friendFunc) };
        }
    }

    /** Associates a given function object to a function id
     *
     * @param {string} str_func
     * @param {YFunction} obj_func
     */
    imm_setFunction(str_func, obj_func) {
        var funres = this.imm_resolve(str_func);
        if (funres.result != undefined) {
            // the function has been located on a device
            this._connectedFns[funres.result] = obj_func;
        } else {
            // the function is still abstract
            this._requestedFns[str_func] = obj_func;
        }
    }

    /** Retrieve a function object by hardware id, updating the indexes on the fly if needed
     *
     * @param {string} str_func
     * @return {YFunction}
     */
    imm_getFunction(str_func) {
        var funres = this.imm_resolve(str_func);
        if (funres.errorType == YAPI_SUCCESS) {
            // the function has been located on a device
            var conn_fn = this._connectedFns[funres.result];
            if (conn_fn != undefined) return conn_fn;

            var req_fn = this._requestedFns[str_func];
            if (req_fn != undefined) {
                this._connectedFns[funres.result] = req_fn;
                delete this._requestedFns[str_func];
            }
            return req_fn;
        } else {
            // the function is still abstract
            return this._requestedFns[str_func];
        }
    }

    /** Stores a function advertised value by hardware id, and tell if an event should be queued for it
     *
     * @param {string} str_hwid
     * @param {string} str_pubval
     * @return {boolean}
     */
    imm_setFunctionValue(str_hwid, str_pubval) {
        var currval = this._valueByHwId[str_hwid];
        if (!(currval == undefined) && currval == str_pubval) {
            return false;
        }
        this._valueByHwId[str_hwid] = str_pubval;
        return true;
    }

    /** Retrieve a function advertised value by hardware id
     *
     * @param {string} str_hwid
     * @return {string}
     */
    imm_getFunctionValue(str_hwid) {
        return this._valueByHwId[str_hwid];
    }

    /** Return the basetype of this function class
     *
     * @return {string}
     */
    imm_getBaseType() {
        return this._baseType;
    }

    /** Find the hardwareId of the first instance of a given function class
     *
     * @return {string|null}
     */
    imm_getFirstHardwareId() {
        var res = null;
        //noinspection LoopStatementThatDoesntLoopJS
        for (res in this._valueByHwId) break;
        return res;
    }

    /** Find the hardwareId for the next instance of a given function class
     *
     * @param {string} str_hwid
     * @return {string|null}
     */
    imm_getNextHardwareId(str_hwid) {
        for (var iter_hwid in this._valueByHwId) {
            if (str_hwid == '!') return iter_hwid;
            if (str_hwid == iter_hwid) str_hwid = '!';
        }
        return null; // no more instance found
    }
}

class YHTTPRequest {
    /** Object storing the result of any HTTP Query, with status code and error message
     *
     * @param bin_res {Uint8Array}
     * @param int_errType {number}
     * @param str_errMsg {string}
     */
    constructor(bin_res) {
        let int_errType = arguments.length <= 1 || arguments[1] === undefined ? YAPI_SUCCESS : arguments[1];
        let str_errMsg = arguments.length <= 2 || arguments[2] === undefined ? 'no error' : arguments[2];

        /** @member {Uint8Array} **/
        this.bin_result = bin_res;
        /** @member {number} **/
        this.errorType = int_errType;
        /** @member {string} **/
        this.errorMsg = str_errMsg;
        /** @member {function} **/
        this.acceptor = null;
    }
}

class YFuncRequest {
    /** Object storing the result of a function request, with status code and error message
     *
     * @param obj_res {Object}
     * @param int_errType {number}
     * @param str_errMsg {string}
     */
    constructor(obj_res) {
        let int_errType = arguments.length <= 1 || arguments[1] === undefined ? YAPI_SUCCESS : arguments[1];
        let str_errMsg = arguments.length <= 2 || arguments[2] === undefined ? 'no error' : arguments[2];

        /** @member {Object} **/
        this.obj_result = obj_res;
        /** @member {number} **/
        this.errorType = int_errType;
        /** @member {string} **/
        this.errorMsg = str_errMsg;
    }
}

// Pseudo class to describe value parsed from JSON
class _YY_LoadVal {
    constructor() {
        // hub api
        /** @member {string} **/
        this.serialNumber = '';
        /** @member {string} **/
        this.logicalName = '';
        /** @member {string} **/
        this.productName = '';
        /** @member {number} **/
        this.productId = 0;
        /** @member {number} **/
        this.beacon = 0;
        /** @member {Object} **/
        this.services = {
            whitePages: [{ networkUrl: '' }],
            yellowPages: []
        };
        // datalogger
        /** @member {string} **/
        this.calib = '';
        /** @member {string} **/
        this.unit = '';
        /** @member {string} **/
        this.cal = '';
        /** @member {string[]} **/
        this.streams = [];
        // node.js ServerResponse
        /** @member {number} **/
        this.statusCode = 0;
    }
}

//
// YDevice Class (used internally)
//
// This class is used to store everything we know about connected Yocto-Devices.
// Instances are created when devices are discovered in the white pages
// (or registered manually, for root hubs) and then used to keep track of
// device naming changes. When a device or a function is renamed, this
// object forces the local indexes to be immediately updated, even if not
// yet fully propagated through the yellow pages of the device hub.
//
// In order to regroup multiple function queries on the same physical device,
// this class implements a device-wide API string cache (agnostic of API content).
// This is in addition to the function-specific cache implemented in YFunction.
//
class YDevice {
    // Device constructor. Automatically call the YAPI functin to reindex device
    constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
        // private attributes
        /** @member {YAPIContext} **/
        this._yapi = obj_yapi;
        /** @member {string} **/
        this._rootUrl = str_rooturl;
        /** @member {string} **/
        this._serialNumber = '';
        /** @member {string} **/
        this._logicalName = '';
        /** @member {string} **/
        this._productName = '';
        /** @member {number} **/
        this._productId = 0;
        /** @member {number} **/
        this._beacon = 0;
        /** @member {number} **/
        this._devYdx = -1;
        /** @member {number} **/
        this._lastErrorType = YAPI_SUCCESS;
        /** @member {string} **/
        this._lastErrorMsg = 'no error';
        /** @member {Object} **/
        this._cache = { _expiration: 0, _json: new Uint8Array(0) };
        /** @member {string[][]} **/
        this._functions = [];
        /** @member {number} **/
        this._busy = 0;
        /** @member {Promise} **/
        this._pendingQueries = Promise.resolve();
        /** @member {number} **/
        this._deviceTime = 0;

        if (obj_wpRec != undefined) {
            // preload values from white pages, if provided
            this._serialNumber = obj_wpRec.serialNumber;
            this._logicalName = obj_wpRec.logicalName;
            this._productName = obj_wpRec.productName;
            this._productId = obj_wpRec.productId;
            this._beacon = obj_wpRec.beacon;
            this._devYdx = obj_wpRec.index == undefined ? -1 : obj_wpRec.index;
            this.imm_updateFromYP(obj_ypRecs);
            this._yapi.imm_reindexDevice(this);
        }
        // when obj_wpRec is not provided, caller MUSTR
        // call async method refresh()
    }

    _throw(int_errType, str_errMsg, obj_retVal) {
        this._lastErrorType = int_errType;
        this._lastErrorMsg = str_errMsg;
        this._yapi._throw(int_errType, str_errMsg, obj_retVal);
    }

    /** Return the root URL used to access a device (including the trailing slash)
     *
     * @returns {string}
     */
    imm_getRootUrl() {
        return this._rootUrl;
    }

    /** Return the serial number of the device, as found during discovery
     *
     * @returns {string}
     */
    imm_getSerialNumber() {
        return this._serialNumber;
    }

    /** Return the logical name of the device, as found during discovery
     *
     * @returns {string}
     */
    imm_getLogicalName() {
        return this._logicalName;
    }

    /** Return the product name of the device, as found during discovery
     *
     * @returns {string}
     */
    imm_getProductName() {
        return this._productName;
    }

    /** Return the product Id of the device, as found during discovery
     *
     * @returns {number}
     */
    imm_getProductId() {
        return this._productId;
    }

    /** Return the beacon state of the device, as found during discovery
     *
     * @returns {number}
     */
    imm_getBeacon() {
        return this._beacon;
    }

    // Return the value of the last timestamp sent by the device, if any
    imm_getDeviceTime() {
        return this._deviceTime;
    }

    /** Return the value of the last timestamp sent by the device, if any
     *
     * @param float_timestamp {number}
     */
    imm_setDeviceTime(float_timestamp) {
        this._deviceTime = float_timestamp;
    }

    /** Return the hub-specific devYdx of the device, as found during discovery
     *
     * @returns {number}
     */
    imm_getDevYdx() {
        return this._devYdx;
    }

    /** Return a string that describes the device (serial number, logical name or root URL)
     *
     * @returns {string}
     */
    imm_describe() {
        var res = this._rootUrl;
        if (this._serialNumber != '') {
            res = this._serialNumber;
            if (this._logicalName != '') {
                res = res + ' (' + this._logicalName + ')';
            }
        }
        return this._productName + ' ' + res;
    }

    /** Update device cache and YAPI function lists from yp records
     *
     * @param obj_ypRecs {Object}
     */
    imm_updateFromYP(obj_ypRecs) {
        var funidx = 0;
        for (var categ in obj_ypRecs) {
            for (var key in obj_ypRecs[categ]) {
                var rec = obj_ypRecs[categ][key];
                var hwid = rec['hardwareId'];
                var dotpos = hwid.indexOf('.');
                if (hwid.substr(0, dotpos) == this._serialNumber) {
                    var funydx = rec['index'];
                    if (funydx == undefined) funydx = funidx;
                    this._functions[funydx] = [hwid.substr(dotpos + 1), rec['logicalName']];
                    funidx++;
                }
            }
        }
    }

    /** Update device cache and YAPI function lists accordingly
     *
     * @param yreq {YHTTPRequest}
     * @param loadval {Object}
     */
    imm_updateFromReq(yreq, loadval) {
        this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
        this._cache._json = yreq.bin_result;

        var func;
        var reindex = false;
        if (this._productName == '') {
            // parse module and function names for the first time
            for (func in loadval) {
                if (func == 'module') {
                    this._serialNumber = loadval.module.serialNumber;
                    this._logicalName = loadval.module.logicalName;
                    this._productName = loadval.module.productName;
                    this._productId = loadval.module.productId;
                    this._beacon = loadval.module.beacon;
                } else if (func == 'services') {
                    this.imm_updateFromYP(loadval.services.yellowPages);
                }
            }
            reindex = true;
        } else {
            // parse module and refresh names if needed
            var renamed = false;
            for (func in loadval) {
                if (func == 'module') {
                    if (this._logicalName != loadval.module.logicalName) {
                        this._logicalName = loadval.module.logicalName;
                        reindex = true;
                    }
                    this._beacon = loadval.module.beacon;
                } else if (func != 'services') {
                    var name = loadval[func]['logicalName'];
                    if (name == undefined) name = loadval.module.logicalName;
                    var pubval = loadval[func]['advertisedValue'];
                    if (pubval != undefined) {
                        this._yapi.imm_setFunctionValue(loadval.module.serialNumber + '.' + func, pubval);
                    }
                    var funydx;
                    for (funydx in this._functions) {
                        if (this._functions[funydx][0] == func) {
                            if (this._functions[funydx][1] != name) {
                                this._functions[funydx][1] = name;
                                reindex = true;
                            }
                            break;
                        }
                    }
                }
            }
        }
        if (reindex) {
            this._yapi.imm_reindexDevice(this);
        }
    }

    // Force the REST API string in cache to expire immediately
    imm_dropCache() {
        this._cache._expiration = 0;
    }

    /** Retrieve the number of functions (beside "module") in the device
     *
     * @returns {Number}
     */
    imm_functionCount() {
        return this._functions.length;
    }

    /** Retrieve the Id of the nth function (beside "module") in the device
     *
     * @param int_idx {number}
     * @returns {string}
     */
    imm_functionId(int_idx) {
        if (int_idx < this._functions.length) {
            return this._functions[int_idx][0];
        }
        return '';
    }

    /** Retrieve the base type of the nth function (beside "module") in the device
     *
     * @param int_idx {number}
     * @returns {string}
     */
    imm_functionBaseType(int_idx) {
        if (int_idx < this._functions.length) {
            var ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + '.' + this._functions[int_idx][0]);
            for (var name in Y_BASETYPES) {
                if (Y_BASETYPES[name] == ftype) {
                    return name;
                }
            }
        }
        return 'Function';
    }

    /** Retrieve the type of the nth function (beside 'module') in the device
     *
     * @param int_idx {number}
     * @returns {string}
     */
    imm_functionType(int_idx) {
        if (int_idx < this._functions.length) {
            var funid = this._functions[int_idx][0];
            var i;
            for (i = 0; i < funid.length; i++) {
                if (funid[i] >= '0' && funid[i] <= '9') {
                    break;
                }
            }
            return funid[0].toUpperCase() + funid.substr(1, i - 1);
        }
        return '';
    }

    /** Retrieve the logical name of the nth function (beside "module") in the device
     *
     * @param int_idx {number}
     * @returns {string}
     */
    imm_functionName(int_idx) {
        if (int_idx < this._functions.length) {
            return this._functions[int_idx][1];
        }
        return '';
    }

    /** Retrieve the advertised value of the nth function (beside "module") in the device
     *
     * @param int_idx {number}
     * @returns {string}
     */
    imm_functionValue(int_idx) {
        if (int_idx < this._functions.length) {
            return this._yapi.imm_getFunctionValue(this._serialNumber + '.' + this._functions[int_idx][0]);
        }
        return '';
    }

    /** Get the whole REST API string for a device, from cache if possible
     *
     * @param int_msValidity {number}
     * @returns {YHTTPRequest}
     */
    requestAPI(int_msValidity) {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cache._expiration > _this._yapi.GetTickCount()) {
                return new YHTTPRequest(_this._cache._json);
            }
            /** @type {YHTTPRequest} **/
            let yreq = yield _this._yapi.devRequest(_this._rootUrl, 'GET /api.json');
            if (yreq.errorType != YAPI_SUCCESS) return yreq;
            if (!int_msValidity) {
                int_msValidity = _this._yapi.defaultCacheValidity;
            }
            _this._cache._expiration = _this._yapi.GetTickCount() + int_msValidity;
            _this._cache._json = yreq.bin_result;
            return yreq;
        })();
    }

    /** Reload a device API (store in cache), and update YAPI function lists accordingly
     *
     * @returns {number}
     */
    refresh() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {YHTTPRequest} **/
            let yreq = yield _this2.requestAPI(_this2._yapi.defaultCacheValidity);
            if (yreq.errorType != YAPI_SUCCESS) {
                return _this2._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }

            let loadval = null;
            try {
                loadval = JSON.parse(_this2._yapi.imm_bin2str(yreq.bin_result));
            } catch (err) {}
            if (!loadval) {
                return _this2._throw(YAPI_IO_ERROR, 'Request failed, could not parse API result for ' + _this2._rootUrl, YAPI_IO_ERROR);
            }
            _this2.imm_updateFromReq(yreq, loadval);
            return YAPI_SUCCESS;
        })();
    }
}

//--- (generated code: YFirmwareUpdate definitions)
//--- (end of generated code: YFirmwareUpdate definitions)

//--- (generated code: YFirmwareUpdate class start)
/**
 * YFirmwareUpdate Class: Control interface for the firmware update process
 *
 * The YFirmwareUpdate class let you control the firmware update of a Yoctopuce
 * module. This class should not be instantiate directly, instead the method
 * updateFirmware should be called to get an instance of YFirmwareUpdate.
 */
//--- (end of generated code: YFirmwareUpdate class start)
class YFirmwareUpdate {
    constructor(obj_yapi, str_serial, str_path, bin_settings) {
        /** @member {YAPIContext} **/
        this._yapi = obj_yapi;
        //--- (generated code: YFirmwareUpdate constructor)
        /** @member {string} **/
        this._serial = '';
        /** @member {Uint8Array} **/
        this._settings = new Uint8Array(0);
        /** @member {string} **/
        this._firmwarepath = '';
        /** @member {string} **/
        this._progress_msg = '';
        /** @member {number} **/
        this._progress_c = 0;
        /** @member {number} **/
        this._progress = 0;
        /** @member {number} **/
        this._restore_step = 0;
        //--- (end of generated code: YFirmwareUpdate constructor)
        /** @member {string} **/
        this._serial = str_serial;
        /** @member {Uint8Array} **/
        this._settings = bin_settings;
        /** @member {string} **/
        this._firmwarepath = str_path;
    }

    _processMore(i) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            _this3._progress = -1;
            _this3._progress_msg = 'not supported in JS';
        })();
    }

    /**
     * Test if the byn file is valid for this module. It's possible to pass an directory instead of a file.
     * In this case this method return the path of the most recent appropriate byn file. This method will
     * ignore firmware that are older than mintrelase.
     *
     * @param serial {string} : the serial number of the module to update
     * @param path {string} : the path of a byn file or a directory that contains byn files
     * @param minrelease {number} : a positive integer
     *
     * @return {string} : the path of the byn file to use or an empty string if no byn files match the requirement
     *
     * On failure, returns a string that start with "error:".
     */
    static CheckFirmware(serial, path, minrelease) {
        return _asyncToGenerator(function* () {
            // FIXME: to be implemented
            return 'error: Not yet supported in Javascript';
        })();
    }

    static GetAllBootLoaders() {
        return _asyncToGenerator(function* () {
            // FIXME: to be implemented
            return [];
        })();
    }

    //--- (generated code: YFirmwareUpdate implementation)

    // cannot be generated for JS:
    // async _processMore(newupdate)

    // cannot be generated for JS:
    // static GetAllBootLoaders()

    // cannot be generated for JS:
    // static GetAllBootLoadersInContext(yctx)

    // cannot be generated for JS:
    // static CheckFirmware(serial,path,minrelease)

    /**
     * Returns the progress of the firmware update, on a scale from 0 to 100. When the object is
     * instantiated, the progress is zero. The value is updated during the firmware update process until
     * the value of 100 is reached. The 100 value means that the firmware update was completed
     * successfully. If an error occurs during the firmware update, a negative value is returned, and the
     * error message can be retrieved with get_progressMessage.
     *
     * @return {number} an integer in the range 0 to 100 (percentage of completion)
     *         or a negative error code in case of failure.
     */
    get_progress() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._progress >= 0) {
                yield _this4._processMore(0);
            }
            return _this4._progress;
        })();
    }

    /**
     * Returns the last progress message of the firmware update process. If an error occurs during the
     * firmware update process, the error message is returned
     *
     * @return {string} a string  with the latest progress message, or the error message.
     */
    get_progressMessage() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            return _this5._progress_msg;
        })();
    }

    /**
     * Starts the firmware update process. This method starts the firmware update process in background. This method
     * returns immediately. You can monitor the progress of the firmware update with the get_progress()
     * and get_progressMessage() methods.
     *
     * @return {number} an integer in the range 0 to 100 (percentage of completion),
     *         or a negative error code in case of failure.
     *
     * On failure returns a negative error code.
     */
    startUpdate() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let err;
            /** @type {number} **/
            let leng;
            err = _this6._yapi.imm_bin2str(_this6._settings);
            leng = err.length;
            if (leng >= 6 && 'error:' == err.substr(0, 6)) {
                _this6._progress = -1;
                _this6._progress_msg = err.substr(6, leng - 6);
            } else {
                _this6._progress = 0;
                _this6._progress_c = 0;
                yield _this6._processMore(1);
            }
            return _this6._progress;
        })();
    }

    //--- (end of generated code: YFirmwareUpdate implementation)
}

//--- (generated code: YFunction class start)
/**
 * YFunction Class: Common function interface
 *
 * This is the parent class for all public objects representing device functions documented in
 * the high-level programming API. This abstract class does all the real job, but without
 * knowledge of the specific function attributes.
 *
 * Instantiating a child class of YFunction does not cause any communication.
 * The instance simply keeps track of its function identifier, and will dynamically bind
 * to a matching device at the time it is really being used to read or set an attribute.
 * In order to allow true hot-plug replacement of one device by another, the binding stay
 * dynamic through the life of the object.
 *
 * The YFunction class implements a generic high-level cache for the attribute values of
 * the specified function, pre-parsed from the REST API string.
 */
//--- (end of generated code: YFunction class start)
class YFunction {
    constructor(obj_yapi, str_func) {
        // private
        /** @member {YAPIContext} **/
        this._yapi = obj_yapi;
        /** @member {string} **/
        this._className = 'Function';
        /** @member {string} **/
        this._func = str_func;
        /** @member {number} **/
        this._lastErrorType = YAPI_SUCCESS;
        /** @member {string} **/
        this._lastErrorMsg = 'no error';
        /** @member {Object} **/
        this._dataStreams = {};
        /** @member {Object} **/
        this._userData = null;
        /** @member {Object} **/
        this._cache = { _expiration: 0 };
        //--- (generated code: YFunction constructor)
        /** @member {string} **/
        this._logicalName = Y_LOGICALNAME_INVALID;
        /** @member {string} **/
        this._advertisedValue = Y_ADVERTISEDVALUE_INVALID;
        /** @member {function} **/
        this._valueCallbackFunction = null;
        /** @member {number} **/
        this._cacheExpiration = 0;
        /** @member {string} **/
        this._serial = '';
        /** @member {string} **/
        this._funId = '';
        /** @member {string} **/
        this._hwId = '';
        /** @member {string} **/
        this.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
        /** @member {string} **/
        this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
        /** @member {string} **/
        this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
        /** @member {string} **/
        this.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
        /** @member {string} **/
        this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
        /** @member {string} **/
        this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
        //--- (end of generated code: YFunction constructor)
    }

    _throw(int_errType, str_errMsg, obj_retVal) {
        this._lastErrorType = int_errType;
        this._lastErrorMsg = str_errMsg;
        this._yapi._throw(int_errType, str_errMsg, obj_retVal);
    }

    imm_setConst(obj) {
        for (let key in obj) {
            this[key] = obj[key];
            this.constructor[key] = obj[key];
        }
    }

    //--- (generated code: YFunction implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case '_expiration':
                this._cacheExpiration = val;
                return 1;
            case 'logicalName':
                this._logicalName = val;
                return 1;
            case 'advertisedValue':
                this._advertisedValue = val;
                return 1;
        }
        return 0;
    }

    /**
     * Returns the logical name of the function.
     *
     * @return {string} a string corresponding to the logical name of the function
     *
     * On failure, throws an exception or returns YFunction.LOGICALNAME_INVALID.
     */
    get_logicalName() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_LOGICALNAME_INVALID;
                }
            }
            return _this7._logicalName;
        })();
    }

    /**
     * Changes the logical name of the function. You can use yCheckLogicalName()
     * prior to this call to make sure that your parameter is valid.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the logical name of the function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_logicalName(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            if (!_this8._yapi.CheckLogicalName(newval)) {
                return _this8._throw(_this8._yapi.INVALID_ARGUMENT, 'Invalid name :' + newval, _this8._yapi.INVALID_ARGUMENT);
            }
            rest_val = newval;
            return yield _this8._setAttr('logicalName', rest_val);
        })();
    }

    /**
     * Returns a short string representing the current state of the function.
     *
     * @return {string} a string corresponding to a short string representing the current state of the function
     *
     * On failure, throws an exception or returns YFunction.ADVERTISEDVALUE_INVALID.
     */
    get_advertisedValue() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_ADVERTISEDVALUE_INVALID;
                }
            }
            return _this9._advertisedValue;
        })();
    }

    set_advertisedValue(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this10._setAttr('advertisedValue', rest_val);
        })();
    }

    /**
     * Retrieves a function for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the function is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YFunction.isOnline() to test if the function is
     * indeed online at a given time. In case of ambiguity when looking for
     * a function by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the function
     *
     * @return {YFunction} a YFunction object allowing you to drive the function.
     */
    static FindFunction(func) {
        /** @type {YFunction} **/
        let obj;
        obj = YFunction._FindFromCache('Function', func);
        if (obj == null) {
            obj = new YFunction(YAPI, func);
            YFunction._AddToCache('Function', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a function for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the function is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YFunction.isOnline() to test if the function is
     * indeed online at a given time. In case of ambiguity when looking for
     * a function by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the function
     *
     * @return {YFunction} a YFunction object allowing you to drive the function.
     */
    static FindFunctionInContext(yctx, func) {
        /** @type {YFunction} **/
        let obj;
        obj = YFunction._FindFromCacheInContext(yctx, 'Function', func);
        if (obj == null) {
            obj = new YFunction(yctx, func);
            YFunction._AddToCache('Function', func, obj);
        }
        return obj;
    }

    /**
     * Registers the callback function that is invoked on every change of advertised value.
     * The callback is invoked only during the execution of ySleep or yHandleEvents.
     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
     * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
     *
     * @param callback {function} : the callback function to call, or a null pointer. The callback
     * function should take two
     *         arguments: the function object of which the value has changed, and the character string describing
     *         the new advertised value.
     * @noreturn
     */
    registerValueCallback(callback) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let val;
            if (callback != null) {
                yield YFunction._UpdateValueCallbackList(_this11, true);
            } else {
                yield YFunction._UpdateValueCallbackList(_this11, false);
            }
            _this11._valueCallbackFunction = callback;
            // Immediately invoke value callback with current value
            if (callback != null && (yield _this11.isOnline())) {
                val = _this11._advertisedValue;
                if (!(val == '')) {
                    yield _this11._invokeValueCallback(val);
                }
            }
            return 0;
        })();
    }

    _invokeValueCallback(value) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._valueCallbackFunction != null) {
                yield _this12._valueCallbackFunction(_this12, value);
            } else {}
            return 0;
        })();
    }

    /**
     * Disable the propagation of every new advertised value to the parent hub.
     * You can use this function to save bandwidth and CPU on computers with limited
     * resources, or to prevent unwanted invocations of the HTTP callback.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    muteValueCallbacks() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            return yield _this13.set_advertisedValue('SILENT');
        })();
    }

    /**
     * Re-enable the propagation of every new advertised value to the parent hub.
     * This function reverts the effect of a previous call to muteValueCallbacks().
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    unmuteValueCallbacks() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            return yield _this14.set_advertisedValue('');
        })();
    }

    _parserHelper() {
        return _asyncToGenerator(function* () {
            return 0;
        })();
    }

    /**
     * comment from .yc definition
     */
    /* */nextFunction() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YFunction.FindFunctionInContext(this._yapi, next_hwid);
    }

    /** Retrieve the first function object in a given context (starts enum
     *
     * @returns {YFunction}
     */
    static FirstFunction() {
        /** @type {string|null} **/
        let next_hwid = YAPI.imm_getFirstHardwareId('Function');
        if (next_hwid == null) return null;
        return YFunction.FindFunction(next_hwid);
    }

    /** Retrieve the first function object in a given context (starts enum
     *
     * @param yctx {YAPIContext}
     * @returns {YFunction}
     */
    static FirstFunctionInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Function');
        if (next_hwid == null) return null;
        return YFunction.FindFunctionInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YFunction implementation)

    /** Retrieve a function instance from cache
     *
     * @param yctx {YAPIContext}
     * @param className {string}
     * @param func {string}
     * @returns {YFunction}
     */
    static _FindFromCacheInContext(yctx, className, func) {
        return yctx.imm_getFunction(className, func);
    }

    /** Retrieve a function instance from cache
     *
     * @param className {string}
     * @param func {string}
     * @returns {YFunction}
     */
    static _FindFromCache(className, func) {
        return YAPI.imm_getFunction(className, func);
    }

    /** Add a function instance to cache
     *
     * @param className {string}
     * @param func {string}
     * @param obj {YFunction}
     */
    static _AddToCache(className, func, obj) {
        obj._yapi.imm_setFunction(className, func, obj);
    }

    /** Clear the function instance cache
     *
     * @param obj_yapi {YAPIContext}
     */
    static _ClearCache() {
        let obj_yapi = arguments.length <= 0 || arguments[0] === undefined ? YAPI : arguments[0];

        obj_yapi.imm_init();
    }

    /** Add or remove a value change callback
     *
     * @param obj_func {YFunction}
     * @param bool_add {Boolean}
     */
    static _UpdateValueCallbackList(obj_func, bool_add) {
        return _asyncToGenerator(function* () {
            yield obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
        })();
    }

    /** Add or remove a timed report callback
     *
     * @param obj_func {YFunction}
     * @param bool_add {Boolean}
     */
    static _UpdateTimedReportCallbackList(obj_func, bool_add) {
        return _asyncToGenerator(function* () {
            yield obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
        })();
    }

    /**
     * Returns a short text that describes unambiguously the instance of the function in the form
     * TYPE(NAME)=SERIAL&#46;FUNCTIONID.
     * More precisely,
     * TYPE       is the type of the function,
     * NAME       it the name used for the first access to the function,
     * SERIAL     is the serial number of the module if the module is connected or "unresolved", and
     * FUNCTIONID is  the hardware identifier of the function if the module is connected.
     * For example, this method returns Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1 if the
     * module is already connected or Relay(BadCustomeName.relay1)=unresolved if the module has
     * not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in
     * a debugger.
     *
     * @return {string} a string that describes the function
     *         (ex: Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1)
     */
    describe() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._hwId != '') {
                return _this15._className + '(' + _this15._func + ')=' + _this15._hwId;
            }
            var resolve = _this15._yapi.imm_resolveFunction(_this15._className, _this15._func);
            if (resolve.errorType != YAPI_SUCCESS && resolve.result != _this15._func) {
                return _this15._className + '(' + _this15._func + ')=unresolved';
            }
            return _this15._className + '(' + _this15._func + ')=' + resolve.result;
        })();
    }

    /**
     * Returns the unique hardware identifier of the function in the form SERIAL.FUNCTIONID.
     * The unique hardware identifier is composed of the device serial
     * number and of the hardware identifier of the function (for example RELAYLO1-123456.relay1).
     *
     * @return {string|null} a string that uniquely identifies the function (ex: RELAYLO1-123456.relay1)
     *
     * On failure, throws an exception or returns  YFunction.HARDWAREID_INVALID.
     */
    get_hardwareId() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._hwId != '') {
                return _this16._hwId;
            }
            var resolve = _this16._yapi.imm_resolveFunction(_this16._className, _this16._func);
            if (resolve.errorType != YAPI_SUCCESS) {
                yield _this16.isOnline();
                resolve = _this16._yapi.imm_resolveFunction(_this16._className, _this16._func);
                if (resolve.errorType != YAPI_SUCCESS) {
                    return _this16._throw(resolve.errorType, resolve.errorMsg, Y_HARDWAREID_INVALID);
                }
            }
            return resolve.result;
        })();
    }

    /**
     * Returns the hardware identifier of the function, without reference to the module. For example
     * relay1
     *
     * @return {string} a string that identifies the function (ex: relay1)
     *
     * On failure, throws an exception or returns  YFunction.FUNCTIONID_INVALID.
     */
    get_functionId() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (_this17._funId != '') {
                return _this17._funId;
            }
            var resolve = _this17._yapi.imm_resolveFunction(_this17._className, _this17._func);
            if (resolve.errorType != YAPI_SUCCESS) {
                yield _this17.isOnline();
                resolve = _this17._yapi.imm_resolveFunction(_this17._className, _this17._func);
                if (resolve.errorType != YAPI_SUCCESS) {
                    return _this17._throw(resolve.errorType, resolve.errorMsg, Y_FUNCTIONID_INVALID);
                }
            }
            var pos = resolve.result.indexOf('.');
            return resolve.result.substr(pos + 1);
        })();
    }

    /**
     * Returns a global identifier of the function in the format MODULE_NAME&#46;FUNCTION_NAME.
     * The returned string uses the logical names of the module and of the function if they are defined,
     * otherwise the serial number of the module and the hardware identifier of the function
     * (for example: MyCustomName.relay1)
     *
     * @return {string|null} a string that uniquely identifies the function using logical names
     *         (ex: MyCustomName.relay1)
     *
     * On failure, throws an exception or returns  YFunction.FRIENDLYNAME_INVALID.
     */
    get_friendlyName() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            var resolve = _this18._yapi.imm_getFriendlyNameFunction(_this18._className, _this18._func);
            if (resolve.errorType != YAPI_SUCCESS) {
                yield _this18.isOnline();
                resolve = _this18._yapi.imm_getFriendlyNameFunction(_this18._className, _this18._func);
                if (resolve.errorType != YAPI_SUCCESS) {
                    return _this18._throw(resolve.errorType, resolve.errorMsg, Y_FRIENDLYNAME_INVALID);
                }
            }
            return resolve.result;
        })();
    }

    /** Store and parse a an API request for current function
     *
     * @param {YFuncRequest} yreq
     * @param {number} msValidity
     */
    _parse(yreq, msValidity) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            // save the whole structure for backward-compatibility
            yreq.obj_result['_expiration'] = _this19._yapi.GetTickCount() + msValidity;
            _this19._serial = yreq.obj_result.deviceid;
            _this19._funId = yreq.obj_result.functionid;
            _this19._hwId = yreq.obj_result.hwid;
            _this19._cache = yreq.obj_result;
            // process each attribute in turn for class-oriented processing
            for (var key in yreq.obj_result) {
                _this19.imm_parseAttr(key, yreq.obj_result[key]);
            }
            yield _this19._parserHelper();
        })();
    }

    // Helper for the VirtualHub (backward-compatible)
    _g(str_attr) {
        this.imm_parseAttr(str_attr, this._cache[str_attr]);
        return this['_' + str_attr];
    }

    /** Return the value of an attribute from function cache, after reloading it from device if needed
     * Note: the function cache is a typed (parsed) cache, contrarily to the agnostic device cache
     *
     * @param {string} str_attr
     * @return {string|null}
     */
    _getAttr(str_attr) {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            if (_this20._cacheExpiration <= _this20._yapi.GetTickCount()) {
                // no valid cached value, reload from device
                if ((yield _this20.load(_this20._yapi.defaultCacheValidity)) != YAPI_SUCCESS) return null;
            }
            if (typeof _this20._cache[str_attr] == 'undefined') {
                _this20._throw(YAPI_VERSION_MISMATCH, 'No such attribute ' + str_attr + ' in function', null);
            }
            return _this20._cache[str_attr];
        })();
    }

    /** Return the value of an attribute from function cache, after reloading it from device if needed
     * Note: the function cache is a typed (parsed) cache, contrarily to the agnostic device cache
     *
     * @param {string} str_attr
     * @return {string|null}
     */
    _getFixedAttr(str_attr) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            if (_this21._cacheExpiration == 0) {
                // no cached value, load from device
                if ((yield _this21.load(_this21._yapi.defaultCacheValidity)) != YAPI_SUCCESS) return null;
            }
            if (typeof _this21._cache[str_attr] == 'undefined') {
                _this21._throw(YAPI_VERSION_MISMATCH, 'No such attribute ' + str_attr + ' in function', null);
            }
            return _this21._cache[str_attr];
        })();
    }

    /** Escape a string for posting it as an URL
     *
     * @param {string} str_newval
     * @return {string}
     */
    imm_escapeAttr(str_newval) {
        return escape(str_newval).replace(/[+]/g, '%2B').replace(/%20/g, '+').replace(/%21/g, '!').replace(/%24/g, '$').replace(/%27/g, '\'').replace(/%28/g, '(').replace(/%29/g, ')').replace(/%2[cC]/g, ',').replace(/%2[fF]/g, '/').replace(/%3[aA]/g, ':').replace(/%3[bB]/g, ';').replace(/%3[fF]/g, '?').replace(/%5[bB]/g, '[').replace(/%5[dD]/g, ']');
    }

    /** Change the value of an attribute on a device, and invalidate the cache
     *
     * @param {string} str_attr
     * @param {string} str_newval
     * @return {number}
     */
    _setAttr(str_attr, str_newval) {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            if (str_newval == undefined) {
                return _this22._throw(YAPI_INVALID_ARGUMENT, 'Undefined value to set for attribute ' + str_attr, null);
            }
            var attrname = encodeURIComponent(str_attr);
            var attrval = _this22.imm_escapeAttr(str_newval);
            var extra = '/' + attrname + '?' + attrname + '=' + attrval + '&.';
            if (_this22._cacheExpiration != 0) {
                _this22._cacheExpiration = _this22._yapi.GetTickCount();
                _this22._cache._expiration = _this22._cacheExpiration;
            }
            yield _this22._yapi.funcRequest(_this22._className, _this22._func, extra);

            return YAPI_SUCCESS;
        })();
    }

    /** Execute an arbitrary HTTP GET request on the device and return the binary content
     *
     * @param {string} str_path
     * @return {Uint8Array}
     */
    _download(str_path) {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            // get the device serial number
            /** @type {string} **/
            let devid = _this23._serial;
            if (devid == '') {
                devid = yield _this23.module().get_serialNumber();
            }
            if (devid == Y_SERIALNUMBER_INVALID) {
                return new Uint8Array(0);
            }
            /** @type {YHTTPRequest} **/
            let yreq = yield _this23._yapi.devRequest(devid, 'GET /' + str_path);
            if (yreq.errorType != YAPI_SUCCESS) {
                return _this23._throw(yreq.errorType, yreq.errorMsg, '');
            }
            return yreq.bin_result;
        })();
    }

    /** Upload a file to the filesystem, to the specified full path name.
     * If a file already exists with the same path name, its content is overwritten.
     *
     * @param {string} str_path
     * @param {Uint8Array|string|number[]} bin_content
     * @return {object}
     */
    _upload(str_path, bin_content) {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            // get the device serial number
            var devid = _this24._serial;
            if (devid == '') {
                devid = yield _this24.module().get_serialNumber();
            }
            if (devid == Y_SERIALNUMBER_INVALID) {
                return _this24.get_errorType();
            }
            var httpreq = 'POST /upload.html';
            var len = bin_content.length;
            // convert to Uint8Array if needed
            if (typeof bin_content == 'string' || bin_content instanceof String) {
                bin_content = _this24._yapi.imm_str2bin(bin_content);
            } else if (bin_content instanceof Array) {
                bin_content = new Uint8Array(bin_content);
            }
            return yield _this24._yapi.devRequest(devid, httpreq, bin_content);
        })();
    }

    /**
     * Waits for all pending asynchronous commands on the module to complete, and invoke
     * the user-provided callback function. The callback function can therefore freely
     * issue issue requets to the module without risk of communication delay.
     *
     * Note that with the new async/await support, the this function is now seldom useful.
     *
     * @param callback {function} : callback function that is invoked when all pending commands on
     *         the module are completed.
     *         The callback function receives two arguments: the caller-specific
     *         context object and the receiving function object.
     * @param context {object} : caller-specific object that is passed as-is to the callback function
     *
     * @return nothing.
     */
    wait_async(callback) {
        let context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        // get the device serial number
        var devid = this._serial;
        if (devid == '') {
            // serial not yet known, get it then call wait_async again
            this.module().get_serialNumber().then(() => this.wait_async(callback, context));
            return YAPI_SUCCESS;
        }
        if (devid == Y_SERIALNUMBER_INVALID) {
            callback(context, this);
            return YAPI_SUCCESS;
        }
        var lockdev = this._yapi.imm_getDevice(devid);

        // queue the call to user callback function in the pending queries promise chain
        var delayedCode = () => {
            callback(context, this);
        };
        lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
        return YAPI_SUCCESS;
    }

    /** Get a value from a JSON buffer
     *
     * @param bin_jsonbuff {Uint8Array}
     * @param str_key {string}
     * @return {string}
     **/
    imm_json_get_key(bin_jsonbuff, str_key) {
        var loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
        if (typeof loadval[str_key] != 'undefined') {
            return loadval[str_key];
        }
        return '';
    }

    /** Get a string from a JSON buffer
     *
     * @param bin_jsonbuff {Uint8Array}
     * @return {string}
     **/
    imm_json_get_string(bin_jsonbuff) {
        return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    }

    /** Get an array of strings from a JSON buffer
     *
     * @param bin_jsonbuff {Uint8Array}
     * @return {string[]}
     **/
    imm_json_get_array(bin_jsonbuff) {
        var loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
        var res = [];
        for (var idx in loadval) {
            res.push(JSON.stringify(loadval[idx]));
        }
        return res;
    }

    /** Get an array of strings from a JSON buffer
     *
     * @param str_json {string}
     * @param str_path {string}
     * @return {string}
     **/
    imm_get_json_path(str_json, str_path) {
        var json = JSON.parse(str_json);
        var paths = str_path.split('|');
        for (var i = 0; i < paths.length; i++) {
            var tmp = paths[i];
            json = json[tmp];
            if (json == undefined) {
                return '';
            }
        }
        return JSON.stringify(json);
    }

    /** Get a string from a JSON string
     *
     * @param str_json {string}
     * @return {string}
     **/
    imm_decode_json_string(str_json) {
        return JSON.parse(str_json);
    }

    // Method used to cache DataStream objects (new DataLogger)
    //
    /** Method used to cache DataStream objects (new DataLogger)
     *
     * @param obj_dataset {YDataSet}
     * @param str_def {string}
     * @return {YDataStream}
     **/
    imm_findDataStream(obj_dataset, str_def) {
        /** @type {string} **/
        let key = obj_dataset.imm_get_functionId() + ':' + str_def;
        if (this._dataStreams[key]) return this._dataStreams[key];

        /** @type {YDataStream} **/
        var newDataStream = new YDataStream(this, obj_dataset, this._yapi.imm_decodeWords(str_def));
        this._dataStreams[key] = newDataStream;
        return newDataStream;
    }

    // Method used to clear cache of DataStream object (undocumented)
    clearDataStreamCache() {
        var _this25 = this;

        return _asyncToGenerator(function* () {
            _this25._dataStreams = {};
        })();
    }

    /**
     * Checks if the function is currently reachable, without raising any error.
     * If there is a cached value for the function in cache, that has not yet
     * expired, the device is considered reachable.
     * No exception is raised if there is an error while trying to contact the
     * device hosting the function.
     *
     * @return {boolean} true if the function can be reached, and false otherwise
     */
    isOnline() {
        var _this26 = this;

        return _asyncToGenerator(function* () {
            // A valid value in cache means that the device is online
            if (_this26._cacheExpiration > _this26._yapi.GetTickCount()) return true;

            // Check that the function is available without throwing exceptions
            /** @type {YFuncRequest} **/
            let yreq = yield _this26._yapi.funcRequest(_this26._className, _this26._func, '', _this26._yapi.defaultCacheValidity);
            if (yreq.errorType != YAPI_SUCCESS) {
                if (yreq.errorType == YAPI_DEVICE_BUSY) {
                    return true;
                } else {
                    return false;
                }
            }
            // save result in cache anyway
            yield _this26._parse(yreq, _this26._yapi.defaultCacheValidity);

            return true;
        })();
    }

    /**
     * Returns the numerical error code of the latest error with the function.
     * This method is mostly useful when using the Yoctopuce library with
     * exceptions disabled.
     *
     * @return {number} a number corresponding to the code of the latest error that occurred while
     *         using the function object
     */
    /**/get_errorType() {
        return this._lastErrorType;
    }

    /**
     * Returns the error message of the latest error with the function.
     * This method is mostly useful when using the Yoctopuce library with
     * exceptions disabled.
     *
     * @return {string} a string corresponding to the latest error message that occured while
     *         using the function object
     */
    /**/get_errorMessage() {
        return this._lastErrorMsg;
    }

    /**
     * Preloads the function cache with a specified validity duration.
     * By default, whenever accessing a device, all function attributes
     * are kept in cache for the standard duration (5 ms). This method can be
     * used to temporarily mark the cache as valid for a longer period, in order
     * to reduce network traffic for instance.
     *
     * @param msValidity {number} : an integer corresponding to the validity attributed to the
     *         loaded function parameters, in milliseconds
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    load(msValidity) {
        var _this27 = this;

        return _asyncToGenerator(function* () {
            /** @type {YFuncRequest} **/
            let yreq = yield _this27._yapi.funcRequest(_this27._className, _this27._func, '', msValidity);
            if (yreq.errorType != YAPI_SUCCESS) {
                return _this27._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }
            yield _this27._parse(yreq, msValidity);

            return YAPI_SUCCESS;
        })();
    }

    /**
     * Invalidates the cache. Invalidates the cache of the function attributes. Forces the
     * next call to get_xxx() or loadxxx() to use values that come from the device.
     *
     * @noreturn
     */
    clearCache() {
        var _this28 = this;

        return _asyncToGenerator(function* () {
            var devreq = yield _this28._yapi._funcDev(_this28._className, _this28._func);
            if (devreq.errorType != YAPI_SUCCESS) {
                return;
            }
            devreq.result.device.imm_dropCache();
            if (_this28._cacheExpiration > 0) {
                _this28._cacheExpiration = _this28._yapi.GetTickCount();
            }
        })();
    }

    /**
     * Gets the YModule object for the device on which the function is located.
     * If the function cannot be located on any module, the returned instance of
     * YModule is not shown as on-line.
     *
     * @return {YModule} an instance of YModule
     */
    module() {
        var _this29 = this;

        return _asyncToGenerator(function* () {
            // try to resolve the function name to a device id without query
            if (_this29._serial != '') {
                return yield yFindModule(_this29._serial + '.module', _this29._yapi);
            }
            var hwid = _this29._func;
            var resolve;
            if (hwid.indexOf('.') < 0) {
                resolve = _this29._yapi.imm_resolveFunction(_this29._className, _this29._func);
                if (resolve.errorType == YAPI_SUCCESS) hwid = resolve.result;
            }
            var dotidx = hwid.indexOf('.');
            if (dotidx >= 0) {
                // resolution worked
                return yield YModule.FindModuleInContext(_this29._yapi, hwid.substr(0, dotidx) + '.module');
            }

            // device not resolved for now, force a communication for a last chance resolution
            if ((yield _this29.load(_this29._yapi.defaultCacheValidity)) == YAPI_SUCCESS) {
                resolve = _this29._yapi.imm_resolveFunction(_this29._className, _this29._func);
                if (resolve.result != undefined) hwid = resolve.result;
            }
            dotidx = hwid.indexOf('.');
            if (dotidx >= 0) {
                // resolution worked
                return yield YModule.FindModuleInContext(_this29._yapi, hwid.substr(0, dotidx) + '.module');
            }
            // return a true yFindModule object even if it is not a module valid for communicating
            return yield YModule.FindModuleInContext(_this29._yapi, 'module_of_' + _this29.className + '_' + _this29._func);
        })();
    }

    /**
     * Gets the YModule object for the device on which the function is located.
     * If the function cannot be located on any module, the returned instance of
     * YModule is not shown as on-line.
     *
     * @return {YModule} an instance of YModule
     */
    get_module() {
        var _this30 = this;

        return _asyncToGenerator(function* () {
            return yield _this30.module();
        })();
    }

    /**
     * Returns a unique identifier of type YFUN_DESCR corresponding to the function.
     * This identifier can be used to test if two instances of YFunction reference the same
     * physical function on the same physical device.
     *
     * @return {string} an identifier of type YFUN_DESCR.
     *
     * If the function has never been contacted, the returned value is YFunction.FUNCTIONDESCRIPTOR_INVALID.
     */
    get_functionDescriptor() {
        var _this31 = this;

        return _asyncToGenerator(function* () {
            // try to resolve the function name to a device id without query
            if (_this31._hwId != '') {
                return _this31._hwId;
            }
            var hwid = _this31._func;
            if (hwid.indexOf('.') < 0) {
                var resolve = _this31._yapi.imm_resolveFunction(_this31._className, _this31._func);
                if (resolve.errorType != YAPI_SUCCESS) hwid = resolve.result;
            }
            var dotidx = hwid.indexOf('.');
            if (dotidx >= 0) {
                return hwid;
            }
            return Y_FUNCTIONDESCRIPTOR_INVALID;
        })();
    }

    /**
     * Returns the value of the userData attribute, as previously stored using method
     * set_userData.
     * This attribute is never touched directly by the API, and is at disposal of the caller to
     * store a context.
     *
     * @return {Object} the object stored previously by the caller.
     */
    get_userData() {
        var _this32 = this;

        return _asyncToGenerator(function* () {
            return _this32._userData;
        })();
    }

    /**
     * Stores a user context provided as argument in the userData attribute of the function.
     * This attribute is never touched by the API, and is at disposal of the caller to store a context.
     *
     * @param data {Object} : any kind of object to be stored
     * @noreturn
     */
    set_userData(data) {
        var _this33 = this;

        return _asyncToGenerator(function* () {
            _this33._userData = data;
        })();
    }

}

exports.YFunction = YFunction; //--- (generated code: YModule class start)
/**
 * YModule Class: Module control interface
 *
 * This interface is identical for all Yoctopuce USB modules.
 * It can be used to control the module global parameters, and
 * to enumerate the functions provided by each module.
 */
//--- (end of generated code: YModule class start)

class YModule extends YFunction {
    constructor(obj_yapi, str_func) {
        //--- (generated code: YModule constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Module';
        /** @member {string} **/
        this._productName = Y_PRODUCTNAME_INVALID;
        /** @member {string} **/
        this._serialNumber = Y_SERIALNUMBER_INVALID;
        /** @member {number} **/
        this._productId = Y_PRODUCTID_INVALID;
        /** @member {number} **/
        this._productRelease = Y_PRODUCTRELEASE_INVALID;
        /** @member {string} **/
        this._firmwareRelease = Y_FIRMWARERELEASE_INVALID;
        /** @member {number} **/
        this._persistentSettings = Y_PERSISTENTSETTINGS_INVALID;
        /** @member {number} **/
        this._luminosity = Y_LUMINOSITY_INVALID;
        /** @member {number} **/
        this._beacon = Y_BEACON_INVALID;
        /** @member {number} **/
        this._upTime = Y_UPTIME_INVALID;
        /** @member {number} **/
        this._usbCurrent = Y_USBCURRENT_INVALID;
        /** @member {number} **/
        this._rebootCountdown = Y_REBOOTCOUNTDOWN_INVALID;
        /** @member {number} **/
        this._userVar = Y_USERVAR_INVALID;
        /** @member {function} **/
        this._logCallback = null;
        this.imm_setConst({
            PRODUCTNAME_INVALID: YAPI_INVALID_STRING,
            SERIALNUMBER_INVALID: YAPI_INVALID_STRING,
            PRODUCTID_INVALID: YAPI_INVALID_UINT,
            PRODUCTRELEASE_INVALID: YAPI_INVALID_UINT,
            FIRMWARERELEASE_INVALID: YAPI_INVALID_STRING,
            PERSISTENTSETTINGS_LOADED: 0,
            PERSISTENTSETTINGS_SAVED: 1,
            PERSISTENTSETTINGS_MODIFIED: 2,
            PERSISTENTSETTINGS_INVALID: -1,
            LUMINOSITY_INVALID: YAPI_INVALID_UINT,
            BEACON_OFF: 0,
            BEACON_ON: 1,
            BEACON_INVALID: -1,
            UPTIME_INVALID: YAPI_INVALID_LONG,
            USBCURRENT_INVALID: YAPI_INVALID_UINT,
            REBOOTCOUNTDOWN_INVALID: YAPI_INVALID_INT,
            USERVAR_INVALID: YAPI_INVALID_INT
        });
        //--- (end of generated code: YModule constructor)

        // automatically fill in hardware properties if they can be resolved
        // without any network access (getDevice does not cause network access)
        let devid = this._func;
        let dotidx = devid.indexOf('.');
        if (dotidx > 0) devid = devid.substr(0, dotidx);
        let dev = this._yapi.imm_getDevice(devid);
        if (dev) {
            this._serial = dev.imm_getSerialNumber();
            this._funId = 'module';
            this._hwId = this._serial + '.module';
        }
    }

    _throw(int_errType, str_errMsg, obj_retVal) {
        this._lastErrorType = int_errType;
        this._lastErrorMsg = str_errMsg;
        this._yapi._throw(int_errType, str_errMsg, obj_retVal);
    }

    /** Return the internal device object hosting the function
     *
     * @return {YDevice}
     *
     * Raise an error if not found
     */
    imm_getDev() {
        /** @type {string} **/
        let devid = this._func;
        /** @type {number} **/
        let dotidx = devid.indexOf('.');
        if (dotidx > 0) devid = devid.substr(0, dotidx);
        /** @type {YDevice} **/
        let dev = this._yapi.imm_getDevice(devid);
        if (!dev) {
            this._throw(YAPI_DEVICE_NOT_FOUND, 'Device [' + devid + '] is not online', null);
        }
        return dev;
    }

    /**
     * Returns the number of functions (beside the "module" interface) available on the module.
     *
     * @return {number} the number of functions on the module
     *
     * On failure, throws an exception or returns a negative error code.
     */
    functionCount() {
        var _this34 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this34.imm_getDev();
            if (!dev) return YAPI_DEVICE_NOT_FOUND;
            return dev.imm_functionCount();
        })();
    }

    /**
     * Retrieves the hardware identifier of the <i>n</i>th function on the module.
     *
     * @param functionIndex {number} : the index of the function for which the information is desired,
     * starting at 0 for the first function.
     *
     * @return {string} a string corresponding to the unambiguous hardware identifier of the requested module function
     *
     * On failure, throws an exception or returns an empty string.
     */
    functionId(functionIndex) {
        var _this35 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this35.imm_getDev();
            if (!dev) return '';
            return dev.imm_functionId(functionIndex);
        })();
    }

    /**
     * Retrieves the type of the <i>n</i>th function on the module.
     *
     * @param functionIndex {number} : the index of the function for which the information is desired,
     * starting at 0 for the first function.
     *
     * @return {string} a the type of the function
     *
     * On failure, throws an exception or returns an empty string.
     */
    functionType(functionIndex) {
        var _this36 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this36.imm_getDev();
            if (!dev) return '';
            return dev.imm_functionType(functionIndex);
        })();
    }

    /**
     * Retrieves the base type of the <i>n</i>th function on the module.
     *
     * @param functionIndex {number} : the index of the function for which the information is desired, starting at
     * 0 for the first function.
     *
     * @return {string} a the base type of the function
     *
     * On failure, throws an exception or returns an empty string.
     */
    functionBaseType(functionIndex) {
        var _this37 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this37.imm_getDev();
            if (!dev) return '';
            return dev.imm_functionBaseType(functionIndex);
        })();
    }

    /**
     * Retrieves the logical name of the <i>n</i>th function on the module.
     *
     * @param functionIndex {number} : the index of the function for which the information is desired,
     * starting at 0 for the first function.
     *
     * @return {string} a string corresponding to the logical name of the requested module function
     *
     * On failure, throws an exception or returns an empty string.
     */
    functionName(functionIndex) {
        var _this38 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this38.imm_getDev();
            if (!dev) return '';
            return dev.imm_functionName(functionIndex);
        })();
    }

    /**
     * Retrieves the advertised value of the <i>n</i>th function on the module.
     *
     * @param functionIndex {number} : the index of the function for which the information is desired,
     * starting at 0 for the first function.
     *
     * @return {string} a short string (up to 6 characters) corresponding to the advertised value of the
     * requested module function
     *
     * On failure, throws an exception or returns an empty string.
     */
    functionValue(functionIndex) {
        var _this39 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this39.imm_getDev();
            if (!dev) return '';
            return dev.imm_functionValue(functionIndex);
        })();
    }

    /** Download the specified URL from the device
     *
     * @param str_url {string}
     * @return {Uint8Array}
     */
    loadUrl(str_url) {
        var _this40 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev = _this40.imm_getDev();
            if (!dev) return null;
            /** @type {YHTTPRequest} **/
            let yreq = yield _this40._yapi.devRequest(dev.imm_getRootUrl(), 'GET ' + str_url);
            if (yreq.errorType != YAPI_SUCCESS) {
                return _this40._throw(yreq.errorType, yreq.errorMsg, null);
            }
            return yreq.bin_result;
        })();
    }

    /**
     * Returns the logical name of the module.
     *
     * @return {string} a string corresponding to the logical name of the module
     *
     * On failure, throws an exception or returns YModule.LOGICALNAME_INVALID.
     */
    get_logicalName() {
        var _this41 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            var dev = _this41.imm_getDev();
            if (dev != null && _this41._cache._expiration <= _this41._yapi.GetTickCount()) {
                return dev._logicalName;
            }
            /** @type {string} **/
            var json_val = yield _this41._getAttr('logicalName');
            return json_val == null ? Y_LOGICALNAME_INVALID : json_val;
        })();
    }

    imm_flattenJsonStruct(jsoncomplex) {
        var decoded = JSON.parse(jsoncomplex);
        var attrs = [];
        for (var function_name in decoded) {
            if (function_name == 'services') continue;
            var function_attrs = decoded[function_name];
            for (var attr_name in function_attrs) {
                let attr_value = function_attrs[attr_name];
                if (attr_value === null || (typeof attr_value === 'undefined' ? 'undefined' : _typeof(attr_value)) === 'object') {
                    continue;
                }
                var flat = function_name + '/' + attr_name + '=' + attr_value;
                attrs.push(flat);
            }
        }
        return JSON.stringify(attrs);
    }

    //--- (generated code: YModule implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'productName':
                this._productName = val;
                return 1;
            case 'serialNumber':
                this._serialNumber = val;
                return 1;
            case 'productId':
                this._productId = parseInt(val);
                return 1;
            case 'productRelease':
                this._productRelease = parseInt(val);
                return 1;
            case 'firmwareRelease':
                this._firmwareRelease = val;
                return 1;
            case 'persistentSettings':
                this._persistentSettings = parseInt(val);
                return 1;
            case 'luminosity':
                this._luminosity = parseInt(val);
                return 1;
            case 'beacon':
                this._beacon = parseInt(val);
                return 1;
            case 'upTime':
                this._upTime = parseInt(val);
                return 1;
            case 'usbCurrent':
                this._usbCurrent = parseInt(val);
                return 1;
            case 'rebootCountdown':
                this._rebootCountdown = parseInt(val);
                return 1;
            case 'userVar':
                this._userVar = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the commercial name of the module, as set by the factory.
     *
     * @return {string} a string corresponding to the commercial name of the module, as set by the factory
     *
     * On failure, throws an exception or returns YModule.PRODUCTNAME_INVALID.
     */
    get_productName() {
        var _this42 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev;
            if (_this42._cacheExpiration == 0) {
                dev = _this42.imm_getDev();
                if (!(dev == null)) {
                    return dev.imm_getProductName();
                }
                if ((yield _this42.load(_this42._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_PRODUCTNAME_INVALID;
                }
            }
            return _this42._productName;
        })();
    }

    /**
     * Returns the serial number of the module, as set by the factory.
     *
     * @return {string} a string corresponding to the serial number of the module, as set by the factory
     *
     * On failure, throws an exception or returns YModule.SERIALNUMBER_INVALID.
     */
    get_serialNumber() {
        var _this43 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev;
            if (_this43._cacheExpiration == 0) {
                dev = _this43.imm_getDev();
                if (!(dev == null)) {
                    return dev.imm_getSerialNumber();
                }
                if ((yield _this43.load(_this43._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_SERIALNUMBER_INVALID;
                }
            }
            return _this43._serialNumber;
        })();
    }

    /**
     * Returns the USB device identifier of the module.
     *
     * @return {number} an integer corresponding to the USB device identifier of the module
     *
     * On failure, throws an exception or returns YModule.PRODUCTID_INVALID.
     */
    get_productId() {
        var _this44 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev;
            if (_this44._cacheExpiration == 0) {
                dev = _this44.imm_getDev();
                if (!(dev == null)) {
                    return dev.imm_getProductId();
                }
                if ((yield _this44.load(_this44._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_PRODUCTID_INVALID;
                }
            }
            return _this44._productId;
        })();
    }

    /**
     * Returns the hardware release version of the module.
     *
     * @return {number} an integer corresponding to the hardware release version of the module
     *
     * On failure, throws an exception or returns YModule.PRODUCTRELEASE_INVALID.
     */
    get_productRelease() {
        var _this45 = this;

        return _asyncToGenerator(function* () {
            if (_this45._cacheExpiration == 0) {
                if ((yield _this45.load(_this45._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_PRODUCTRELEASE_INVALID;
                }
            }
            return _this45._productRelease;
        })();
    }

    /**
     * Returns the version of the firmware embedded in the module.
     *
     * @return {string} a string corresponding to the version of the firmware embedded in the module
     *
     * On failure, throws an exception or returns YModule.FIRMWARERELEASE_INVALID.
     */
    get_firmwareRelease() {
        var _this46 = this;

        return _asyncToGenerator(function* () {
            if (_this46._cacheExpiration <= _this46._yapi.GetTickCount()) {
                if ((yield _this46.load(_this46._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_FIRMWARERELEASE_INVALID;
                }
            }
            return _this46._firmwareRelease;
        })();
    }

    /**
     * Returns the current state of persistent module settings.
     *
     * @return {number} a value among YModule.PERSISTENTSETTINGS_LOADED, YModule.PERSISTENTSETTINGS_SAVED
     * and YModule.PERSISTENTSETTINGS_MODIFIED corresponding to the current state of persistent module settings
     *
     * On failure, throws an exception or returns YModule.PERSISTENTSETTINGS_INVALID.
     */
    get_persistentSettings() {
        var _this47 = this;

        return _asyncToGenerator(function* () {
            if (_this47._cacheExpiration <= _this47._yapi.GetTickCount()) {
                if ((yield _this47.load(_this47._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_PERSISTENTSETTINGS_INVALID;
                }
            }
            return _this47._persistentSettings;
        })();
    }

    set_persistentSettings(newval) {
        var _this48 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this48._setAttr('persistentSettings', rest_val);
        })();
    }

    /**
     * Returns the luminosity of the  module informative leds (from 0 to 100).
     *
     * @return {number} an integer corresponding to the luminosity of the  module informative leds (from 0 to 100)
     *
     * On failure, throws an exception or returns YModule.LUMINOSITY_INVALID.
     */
    get_luminosity() {
        var _this49 = this;

        return _asyncToGenerator(function* () {
            if (_this49._cacheExpiration <= _this49._yapi.GetTickCount()) {
                if ((yield _this49.load(_this49._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_LUMINOSITY_INVALID;
                }
            }
            return _this49._luminosity;
        })();
    }

    /**
     * Changes the luminosity of the module informative leds. The parameter is a
     * value between 0 and 100.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : an integer corresponding to the luminosity of the module informative leds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_luminosity(newval) {
        var _this50 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this50._setAttr('luminosity', rest_val);
        })();
    }

    /**
     * Returns the state of the localization beacon.
     *
     * @return {number} either YModule.BEACON_OFF or YModule.BEACON_ON, according to the state of the
     * localization beacon
     *
     * On failure, throws an exception or returns YModule.BEACON_INVALID.
     */
    get_beacon() {
        var _this51 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDevice} **/
            let dev;
            if (_this51._cacheExpiration <= _this51._yapi.GetTickCount()) {
                dev = _this51.imm_getDev();
                if (!(dev == null)) {
                    return dev.imm_getBeacon();
                }
                if ((yield _this51.load(_this51._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_BEACON_INVALID;
                }
            }
            return _this51._beacon;
        })();
    }

    /**
     * Turns on or off the module localization beacon.
     *
     * @param newval {number} : either YModule.BEACON_OFF or YModule.BEACON_ON
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_beacon(newval) {
        var _this52 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this52._setAttr('beacon', rest_val);
        })();
    }

    /**
     * Returns the number of milliseconds spent since the module was powered on.
     *
     * @return {number} an integer corresponding to the number of milliseconds spent since the module was powered on
     *
     * On failure, throws an exception or returns YModule.UPTIME_INVALID.
     */
    get_upTime() {
        var _this53 = this;

        return _asyncToGenerator(function* () {
            if (_this53._cacheExpiration <= _this53._yapi.GetTickCount()) {
                if ((yield _this53.load(_this53._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_UPTIME_INVALID;
                }
            }
            return _this53._upTime;
        })();
    }

    /**
     * Returns the current consumed by the module on the USB bus, in milli-amps.
     *
     * @return {number} an integer corresponding to the current consumed by the module on the USB bus, in milli-amps
     *
     * On failure, throws an exception or returns YModule.USBCURRENT_INVALID.
     */
    get_usbCurrent() {
        var _this54 = this;

        return _asyncToGenerator(function* () {
            if (_this54._cacheExpiration <= _this54._yapi.GetTickCount()) {
                if ((yield _this54.load(_this54._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_USBCURRENT_INVALID;
                }
            }
            return _this54._usbCurrent;
        })();
    }

    /**
     * Returns the remaining number of seconds before the module restarts, or zero when no
     * reboot has been scheduled.
     *
     * @return {number} an integer corresponding to the remaining number of seconds before the module
     * restarts, or zero when no
     *         reboot has been scheduled
     *
     * On failure, throws an exception or returns YModule.REBOOTCOUNTDOWN_INVALID.
     */
    get_rebootCountdown() {
        var _this55 = this;

        return _asyncToGenerator(function* () {
            if (_this55._cacheExpiration <= _this55._yapi.GetTickCount()) {
                if ((yield _this55.load(_this55._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_REBOOTCOUNTDOWN_INVALID;
                }
            }
            return _this55._rebootCountdown;
        })();
    }

    set_rebootCountdown(newval) {
        var _this56 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this56._setAttr('rebootCountdown', rest_val);
        })();
    }

    /**
     * Returns the value previously stored in this attribute.
     * On startup and after a device reboot, the value is always reset to zero.
     *
     * @return {number} an integer corresponding to the value previously stored in this attribute
     *
     * On failure, throws an exception or returns YModule.USERVAR_INVALID.
     */
    get_userVar() {
        var _this57 = this;

        return _asyncToGenerator(function* () {
            if (_this57._cacheExpiration <= _this57._yapi.GetTickCount()) {
                if ((yield _this57.load(_this57._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_USERVAR_INVALID;
                }
            }
            return _this57._userVar;
        })();
    }

    /**
     * Returns the value previously stored in this attribute.
     * On startup and after a device reboot, the value is always reset to zero.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_userVar(newval) {
        var _this58 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this58._setAttr('userVar', rest_val);
        })();
    }

    /**
     * Allows you to find a module from its serial number or from its logical name.
     *
     * This function does not require that the module is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YModule.isOnline() to test if the module is
     * indeed online at a given time. In case of ambiguity when looking for
     * a module by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string containing either the serial number or
     *         the logical name of the desired module
     *
     * @return {YModule} a YModule object allowing you to drive the module
     *         or get additional information on the module.
     */
    static FindModule(func) {
        /** @type {YModule} **/
        let obj;
        //noinspection JSValidateTypes
        obj = YFunction._FindFromCache('Module', func);
        if (obj == null) {
            obj = new YModule(YAPI, func);
            YFunction._AddToCache('Module', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a module for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the module is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YModule.isOnline() to test if the module is
     * indeed online at a given time. In case of ambiguity when looking for
     * a module by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the module
     *
     * @return {YModule} a YModule object allowing you to drive the module.
     */
    static FindModuleInContext(yctx, func) {
        /** @type {YModule} **/
        let obj;
        //noinspection JSValidateTypes
        obj = YFunction._FindFromCacheInContext(yctx, 'Module', func);
        if (obj == null) {
            obj = new YModule(yctx, func);
            YFunction._AddToCache('Module', func, obj);
        }
        return obj;
    }

    /**
     * Saves current settings in the nonvolatile memory of the module.
     * Warning: the number of allowed save operations during a module life is
     * limited (about 100000 cycles). Do not call this function within a loop.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    saveToFlash() {
        var _this59 = this;

        return _asyncToGenerator(function* () {
            return yield _this59.set_persistentSettings(Y_PERSISTENTSETTINGS_SAVED);
        })();
    }

    /**
     * Reloads the settings stored in the nonvolatile memory, as
     * when the module is powered on.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    revertFromFlash() {
        var _this60 = this;

        return _asyncToGenerator(function* () {
            return yield _this60.set_persistentSettings(Y_PERSISTENTSETTINGS_LOADED);
        })();
    }

    /**
     * Schedules a simple module reboot after the given number of seconds.
     *
     * @param secBeforeReboot {number} : number of seconds before rebooting
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    reboot(secBeforeReboot) {
        var _this61 = this;

        return _asyncToGenerator(function* () {
            return yield _this61.set_rebootCountdown(secBeforeReboot);
        })();
    }

    /**
     * Schedules a module reboot into special firmware update mode.
     *
     * @param secBeforeReboot {number} : number of seconds before rebooting
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    triggerFirmwareUpdate(secBeforeReboot) {
        var _this62 = this;

        return _asyncToGenerator(function* () {
            return yield _this62.set_rebootCountdown(-secBeforeReboot);
        })();
    }

    /**
     * Tests whether the byn file is valid for this module. This method is useful to test if the module
     * needs to be updated.
     * It is possible to pass a directory as argument instead of a file. In this case, this method returns
     * the path of the most recent
     * appropriate byn file. If the parameter onlynew is true, the function discards firmware that are
     * older or equal to
     * the installed firmware.
     *
     * @param path {string} : the path of a byn file or a directory that contains byn files
     * @param onlynew {boolean} : returns only files that are strictly newer
     *
     * @return {string} : the path of the byn file to use or a empty string if no byn files matches the requirement
     *
     * On failure, throws an exception or returns a string that start with "error:".
     */
    checkFirmware(path, onlynew) {
        var _this63 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let serial;
            /** @type {number} **/
            let release;
            /** @type {string} **/
            let tmp_res;
            if (onlynew) {
                release = _this63._yapi.imm_atoi((yield _this63.get_firmwareRelease()));
            } else {
                release = 0;
            }
            //may throw an exception
            serial = yield _this63.get_serialNumber();
            tmp_res = yield YFirmwareUpdate.CheckFirmware(serial, path, release);
            if (tmp_res.indexOf('error:') == 0) {
                _this63._throw(YAPI_INVALID_ARGUMENT, tmp_res);
            }
            return tmp_res;
        })();
    }

    /**
     * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
     * handles the firmware update process.
     *
     * @param path {string} : the path of the byn file to use.
     *
     * @return {YFirmwareUpdate} : A YFirmwareUpdate object or NULL on error.
     */
    updateFirmware(path) {
        var _this64 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let serial;
            /** @type {Uint8Array} **/
            let settings;
            // may throw an exception
            serial = yield _this64.get_serialNumber();
            settings = yield _this64.get_allSettings();
            if (settings.length == 0) {
                _this64._throw(YAPI_IO_ERROR, 'Unable to get device settings');
                settings = _this64._yapi.imm_str2bin('error:Unable to get device settings');
            }
            return new YFirmwareUpdate(serial, path, settings);
        })();
    }

    /**
     * Returns all the settings and uploaded files of the module. Useful to backup all the logical names,
     * calibrations parameters,
     * and uploaded files of a connected module.
     *
     * @return {Uint8Array} a binary buffer with all the settings.
     *
     * On failure, throws an exception or returns an binary object of size 0.
     */
    get_allSettings() {
        var _this65 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let settings;
            /** @type {Uint8Array} **/
            let json;
            /** @type {Uint8Array} **/
            let res;
            /** @type {string} **/
            let sep;
            /** @type {string} **/
            let name;
            /** @type {string} **/
            let item;
            /** @type {string} **/
            let t_type;
            /** @type {string} **/
            let id;
            /** @type {string} **/
            let url;
            /** @type {string} **/
            let file_data;
            /** @type {Uint8Array} **/
            let file_data_bin;
            /** @type {Uint8Array} **/
            let temp_data_bin;
            /** @type {string} **/
            let ext_settings;
            /** @type {string[]} **/
            let filelist = [];
            /** @type {string[]} **/
            let templist = [];
            // may throw an exception
            settings = yield _this65._download('api.json');
            if (settings.length == 0) {
                return settings;
            }
            ext_settings = ', "extras":[';
            templist = yield _this65.get_functionIds('Temperature');
            sep = '';
            for (let ii in templist) {
                if (_this65._yapi.imm_atoi((yield _this65.get_firmwareRelease())) > 9000) {
                    url = 'api/' + templist[ii] + '/sensorType';
                    t_type = _this65._yapi.imm_bin2str((yield _this65._download(url)));
                    if (t_type == 'RES_NTC') {
                        id = templist[ii].substr(11, templist[ii].length - 11);
                        temp_data_bin = yield _this65._download('extra.json?page=' + id);
                        if (temp_data_bin.length == 0) {
                            return temp_data_bin;
                        }
                        item = sep + '{"fid":"' + templist[ii] + '", "json":' + _this65._yapi.imm_bin2str(temp_data_bin) + '}\n';
                        ext_settings = ext_settings + item;
                        sep = ',';
                    }
                }
            }
            ext_settings = ext_settings + '],\n"files":[';
            if (yield _this65.hasFunction('files')) {
                json = yield _this65._download('files.json?a=dir&f=');
                if (json.length == 0) {
                    return json;
                }
                filelist = _this65.imm_json_get_array(json);
                sep = '';
                for (let ii in filelist) {
                    name = _this65.imm_json_get_key(_this65._yapi.imm_str2bin(filelist[ii]), 'name');
                    if (name.length == 0) {
                        return _this65._yapi.imm_str2bin(name);
                    }
                    file_data_bin = yield _this65._download(_this65.imm_escapeAttr(name));
                    file_data = _this65._yapi.imm_bin2hexstr(file_data_bin);
                    item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
                    ext_settings = ext_settings + item;
                    sep = ',';;
                }
            }
            ext_settings = ext_settings + ']}';
            res = _this65._yapi.imm_str2bin('{ "api":') + settings + _this65._yapi.imm_str2bin(ext_settings);
            return res;
        })();
    }

    loadThermistorExtra(funcId, jsonExtra) {
        var _this66 = this;

        return _asyncToGenerator(function* () {
            /** @type {string[]} **/
            let values = [];
            /** @type {string} **/
            let url;
            /** @type {string} **/
            let curr;
            /** @type {string} **/
            let currTemp;
            /** @type {number} **/
            let ofs;
            /** @type {number} **/
            let size;
            url = 'api/' + funcId + '.json?command=Z';
            // may throw an exception
            yield _this66._download(url);
            // add records in growing resistance value
            values = _this66.imm_json_get_array(_this66._yapi.imm_str2bin(jsonExtra));
            ofs = 0;
            size = values.length;
            while (ofs + 1 < size) {
                curr = values[ofs];
                currTemp = values[ofs + 1];
                url = 'api/' + funcId + '/.json?command=m' + curr + ':' + currTemp;
                yield _this66._download(url);
                ofs = ofs + 2;
            }
            return YAPI_SUCCESS;
        })();
    }

    set_extraSettings(jsonExtra) {
        var _this67 = this;

        return _asyncToGenerator(function* () {
            /** @type {string[]} **/
            let extras = [];
            /** @type {string} **/
            let functionId;
            /** @type {string} **/
            let data;
            extras = _this67.imm_json_get_array(_this67._yapi.imm_str2bin(jsonExtra));
            for (let ii in extras) {
                functionId = _this67.imm_get_json_path(extras[ii], 'fid');
                functionId = _this67.imm_decode_json_string(functionId);
                data = _this67.imm_get_json_path(extras[ii], 'json');
                if (yield _this67.hasFunction(functionId)) {
                    yield _this67.loadThermistorExtra(functionId, data);
                }
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Restores all the settings and uploaded files of the module. Useful to restore all the logical names
     * and calibrations parameters, uploaded
     * files etc.. of a module from a backup.Remember to call the saveToFlash() method of the module if the
     * modifications must be kept.
     *
     * @param settings {Uint8Array} : a binary buffer with all the settings.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_allSettingsAndFiles(settings) {
        var _this68 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let down;
            /** @type {string} **/
            let json;
            /** @type {string} **/
            let json_api;
            /** @type {string} **/
            let json_files;
            /** @type {string} **/
            let json_extra;
            json = _this68._yapi.imm_bin2str(settings);
            json_api = _this68.imm_get_json_path(json, 'api');
            if (json_api == '') {
                return yield _this68.set_allSettings(settings);
            }
            json_extra = _this68.imm_get_json_path(json, 'extras');
            if (!(json_extra == '')) {
                yield _this68.set_extraSettings(json_extra);
            }
            yield _this68.set_allSettings(_this68._yapi.imm_str2bin(json_api));
            if (yield _this68.hasFunction('files')) {
                /** @type {string[]} **/
                let files = [];
                /** @type {string} **/
                let res;
                /** @type {string} **/
                let name;
                /** @type {string} **/
                let data;
                down = yield _this68._download('files.json?a=format');
                res = _this68.imm_get_json_path(_this68._yapi.imm_bin2str(down), 'res');
                res = _this68.imm_decode_json_string(res);
                if (!(res == 'ok')) {
                    return _this68._throw(YAPI_IO_ERROR, 'format failed', YAPI_IO_ERROR);
                }
                json_files = _this68.imm_get_json_path(json, 'files');
                files = _this68.imm_json_get_array(_this68._yapi.imm_str2bin(json_files));
                for (let ii in files) {
                    name = _this68.imm_get_json_path(files[ii], 'name');
                    name = _this68.imm_decode_json_string(name);
                    data = _this68.imm_get_json_path(files[ii], 'data');
                    data = _this68.imm_decode_json_string(data);
                    yield _this68._upload(name, _this68._yapi.imm_hexstr2bin(data));;
                }
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Test if the device has a specific function. This method took an function identifier
     * and return a boolean.
     *
     * @param funcId {string} : the requested function identifier
     *
     * @return {boolean} : true if the device has the function identifier
     */
    hasFunction(funcId) {
        var _this69 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let count;
            /** @type {number} **/
            let i;
            /** @type {string} **/
            let fid;
            // may throw an exception
            count = yield _this69.functionCount();
            i = 0;
            while (i < count) {
                fid = yield _this69.functionId(i);
                if (fid == funcId) {
                    return true;
                }
                i = i + 1;
            }
            return false;
        })();
    }

    /**
     * Retrieve all hardware identifier that match the type passed in argument.
     *
     * @param funType {string} : The type of function (Relay, LightSensor, Voltage,...)
     *
     * @return {string[]} : A array of string.
     */
    get_functionIds(funType) {
        var _this70 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let count;
            /** @type {number} **/
            let i;
            /** @type {string} **/
            let ftype;
            /** @type {string[]} **/
            let res = [];
            // may throw an exception
            count = yield _this70.functionCount();
            i = 0;
            while (i < count) {
                ftype = yield _this70.functionType(i);
                if (ftype == funType) {
                    res.push((yield _this70.functionId(i)));
                } else {
                    ftype = yield _this70.functionBaseType(i);
                    if (ftype == funType) {
                        res.push((yield _this70.functionId(i)));
                    }
                }
                i = i + 1;
            }
            return res;
        })();
    }

    // cannot be generated for JS:
    // /* */ imm_flattenJsonStruct(jsoncomplex)

    calibVersion(cparams) {
        return _asyncToGenerator(function* () {
            if (cparams == '0,') {
                return 3;
            }
            if (cparams.indexOf(',') >= 0) {
                if (cparams.indexOf(' ') > 0) {
                    return 3;
                } else {
                    return 1;
                }
            }
            if (cparams == '' || cparams == '0') {
                return 1;
            }
            if (cparams.length < 2 || cparams.indexOf('.') >= 0) {
                return 0;
            } else {
                return 2;
            }
        })();
    }

    calibScale(unit_name, sensorType) {
        var _this71 = this;

        return _asyncToGenerator(function* () {
            if (unit_name == 'g' || unit_name == 'gauss' || unit_name == 'W') {
                return 1000;
            }
            if (unit_name == 'C') {
                if (sensorType == '') {
                    return 16;
                }
                if (_this71._yapi.imm_atoi(sensorType) < 8) {
                    return 16;
                } else {
                    return 100;
                }
            }
            if (unit_name == 'm' || unit_name == 'deg') {
                return 10;
            }
            return 1;
        })();
    }

    calibOffset(unit_name) {
        return _asyncToGenerator(function* () {
            if (unit_name == '% RH' || unit_name == 'mbar' || unit_name == 'lx') {
                return 0;
            }
            return 32767;
        })();
    }

    calibConvert(param, currentFuncValue, unit_name, sensorType) {
        var _this72 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let paramVer;
            /** @type {number} **/
            let funVer;
            /** @type {number} **/
            let funScale;
            /** @type {number} **/
            let funOffset;
            /** @type {number} **/
            let paramScale;
            /** @type {number} **/
            let paramOffset;
            /** @type {number[]} **/
            let words = [];
            /** @type {string[]} **/
            let words_str = [];
            /** @type {number[]} **/
            let calibData = [];
            /** @type {number[]} **/
            let iCalib = [];
            /** @type {number} **/
            let calibType;
            /** @type {number} **/
            let i;
            /** @type {number} **/
            let maxSize;
            /** @type {number} **/
            let ratio;
            /** @type {number} **/
            let nPoints;
            /** @type {number} **/
            let wordVal;
            // Initial guess for parameter encoding
            paramVer = yield _this72.calibVersion(param);
            funVer = yield _this72.calibVersion(currentFuncValue);
            funScale = yield _this72.calibScale(unit_name, sensorType);
            funOffset = yield _this72.calibOffset(unit_name);
            paramScale = funScale;
            paramOffset = funOffset;
            if (funVer < 3) {
                if (funVer == 2) {
                    words = _this72._yapi.imm_decodeWords(currentFuncValue);
                    if (words[0] == 1366 && words[1] == 12500) {
                        funScale = 1;
                        funOffset = 0;
                    } else {
                        funScale = words[1];
                        funOffset = words[0];
                    }
                } else {
                    if (funVer == 1) {
                        if (currentFuncValue == '' || _this72._yapi.imm_atoi(currentFuncValue) > 10) {
                            funScale = 0;
                        }
                    }
                }
            }
            calibData.length = 0;
            calibType = 0;
            if (paramVer < 3) {
                if (paramVer == 2) {
                    words = _this72._yapi.imm_decodeWords(param);
                    if (words[0] == 1366 && words[1] == 12500) {
                        paramScale = 1;
                        paramOffset = 0;
                    } else {
                        paramScale = words[1];
                        paramOffset = words[0];
                    }
                    if (words.length >= 3 && words[2] > 0) {
                        maxSize = 3 + 2 * (words[2] % 10);
                        if (maxSize > words.length) {
                            maxSize = words.length;
                        }
                        i = 3;
                        while (i < maxSize) {
                            calibData.push(words[i]);
                            i = i + 1;
                        }
                    }
                } else {
                    if (paramVer == 1) {
                        words_str = param.split(',');
                        for (let ii in words_str) {
                            words.push(_this72._yapi.imm_atoi(words_str[ii]));
                        }
                        if (param == '' || words[0] > 10) {
                            paramScale = 0;
                        }
                        if (words.length > 0 && words[0] > 0) {
                            maxSize = 1 + 2 * (words[0] % 10);
                            if (maxSize > words.length) {
                                maxSize = words.length;
                            }
                            i = 1;
                            while (i < maxSize) {
                                calibData.push(words[i]);
                                i = i + 1;
                            }
                        }
                    } else {
                        if (paramVer == 0) {
                            ratio = parseFloat(param);
                            if (ratio > 0) {
                                calibData.push(0.0);
                                calibData.push(0.0);
                                calibData.push(Math.round(65535 / ratio));
                                calibData.push(65535.0);
                            }
                        }
                    }
                }
                i = 0;
                while (i < calibData.length) {
                    if (paramScale > 0) {
                        calibData[i] = (calibData[i] - paramOffset) / paramScale;
                    } else {
                        calibData[i] = _this72._yapi.imm_decimalToDouble(Math.round(calibData[i]));
                    }
                    i = i + 1;
                }
            } else {
                iCalib = _this72._yapi.imm_decodeFloats(param);
                calibType = Math.round(iCalib[0] / 1000.0);
                if (calibType >= 30) {
                    calibType = calibType - 30;
                }
                i = 1;
                while (i < iCalib.length) {
                    calibData.push(iCalib[i] / 1000.0);
                    i = i + 1;
                }
            }
            if (funVer >= 3) {
                if (calibData.length == 0) {
                    param = '0,';
                } else {
                    param = 30 + calibType;
                    i = 0;
                    while (i < calibData.length) {
                        if ((i & 1) > 0) {
                            param = param + ':';
                        } else {
                            param = param + ' ';
                        }
                        param = param + Math.round(calibData[i] * 1000.0 / 1000.0);
                        i = i + 1;
                    }
                    param = param + ',';
                }
            } else {
                if (funVer >= 1) {
                    nPoints = parseInt(calibData.length / 2, 10);
                    param = nPoints;
                    i = 0;
                    while (i < 2 * nPoints) {
                        if (funScale == 0) {
                            wordVal = _this72._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
                        } else {
                            wordVal = calibData[i] * funScale + funOffset;
                        }
                        param = param + ',' + Math.round(wordVal);
                        i = i + 1;
                    }
                } else {
                    if (calibData.length == 4) {
                        param = Math.round(1000 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]);
                    }
                }
            }
            return param;
        })();
    }

    /**
     * Restores all the settings of the module. Useful to restore all the logical names and calibrations parameters
     * of a module from a backup.Remember to call the saveToFlash() method of the module if the
     * modifications must be kept.
     *
     * @param settings {Uint8Array} : a binary buffer with all the settings.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_allSettings(settings) {
        var _this73 = this;

        return _asyncToGenerator(function* () {
            /** @type {string[]} **/
            let restoreLast = [];
            /** @type {Uint8Array} **/
            let old_json_flat;
            /** @type {string[]} **/
            let old_dslist = [];
            /** @type {string[]} **/
            let old_jpath = [];
            /** @type {number[]} **/
            let old_jpath_len = [];
            /** @type {string[]} **/
            let old_val_arr = [];
            /** @type {Uint8Array} **/
            let actualSettings;
            /** @type {string[]} **/
            let new_dslist = [];
            /** @type {string[]} **/
            let new_jpath = [];
            /** @type {number[]} **/
            let new_jpath_len = [];
            /** @type {string[]} **/
            let new_val_arr = [];
            /** @type {number} **/
            let cpos;
            /** @type {number} **/
            let eqpos;
            /** @type {number} **/
            let leng;
            /** @type {number} **/
            let i;
            /** @type {number} **/
            let j;
            /** @type {string} **/
            let njpath;
            /** @type {string} **/
            let jpath;
            /** @type {string} **/
            let fun;
            /** @type {string} **/
            let attr;
            /** @type {string} **/
            let value;
            /** @type {string} **/
            let url;
            /** @type {string} **/
            let tmp;
            /** @type {string} **/
            let new_calib;
            /** @type {string} **/
            let sensorType;
            /** @type {string} **/
            let unit_name;
            /** @type {string} **/
            let newval;
            /** @type {string} **/
            let oldval;
            /** @type {string} **/
            let old_calib;
            /** @type {string} **/
            let each_str;
            /** @type {boolean} **/
            let do_update;
            /** @type {boolean} **/
            let found;
            tmp = _this73._yapi.imm_bin2str(settings);
            tmp = _this73.imm_get_json_path(tmp, 'api');
            if (!(tmp == '')) {
                settings = _this73._yapi.imm_str2bin(tmp);
            }
            oldval = '';
            newval = '';
            old_json_flat = _this73.imm_flattenJsonStruct(settings);
            old_dslist = _this73.imm_json_get_array(old_json_flat);
            for (let ii in old_dslist) {
                each_str = _this73.imm_json_get_string(_this73._yapi.imm_str2bin(old_dslist[ii]));
                leng = each_str.length;
                eqpos = each_str.indexOf('=');
                if (eqpos < 0 || leng == 0) {
                    _this73._throw(YAPI_INVALID_ARGUMENT, 'Invalid settings');
                    return YAPI_INVALID_ARGUMENT;
                }
                jpath = each_str.substr(0, eqpos);
                eqpos = eqpos + 1;
                value = each_str.substr(eqpos, leng - eqpos);
                old_jpath.push(jpath);
                old_jpath_len.push(jpath.length);
                old_val_arr.push(value);;
            }
            // may throw an exception
            actualSettings = yield _this73._download('api.json');
            actualSettings = _this73.imm_flattenJsonStruct(actualSettings);
            new_dslist = _this73.imm_json_get_array(actualSettings);
            for (let ii in new_dslist) {
                each_str = _this73.imm_json_get_string(_this73._yapi.imm_str2bin(new_dslist[ii]));
                leng = each_str.length;
                eqpos = each_str.indexOf('=');
                if (eqpos < 0 || leng == 0) {
                    _this73._throw(YAPI_INVALID_ARGUMENT, 'Invalid settings');
                    return YAPI_INVALID_ARGUMENT;
                }
                jpath = each_str.substr(0, eqpos);
                eqpos = eqpos + 1;
                value = each_str.substr(eqpos, leng - eqpos);
                new_jpath.push(jpath);
                new_jpath_len.push(jpath.length);
                new_val_arr.push(value);;
            }
            i = 0;
            while (i < new_jpath.length) {
                njpath = new_jpath[i];
                leng = njpath.length;
                cpos = njpath.indexOf('/');
                if (cpos < 0 || leng == 0) {
                    continue;
                }
                fun = njpath.substr(0, cpos);
                cpos = cpos + 1;
                attr = njpath.substr(cpos, leng - cpos);
                do_update = true;
                if (fun == 'services') {
                    do_update = false;
                }
                if (do_update && attr == 'firmwareRelease') {
                    do_update = false;
                }
                if (do_update && attr == 'usbCurrent') {
                    do_update = false;
                }
                if (do_update && attr == 'upTime') {
                    do_update = false;
                }
                if (do_update && attr == 'persistentSettings') {
                    do_update = false;
                }
                if (do_update && attr == 'adminPassword') {
                    do_update = false;
                }
                if (do_update && attr == 'userPassword') {
                    do_update = false;
                }
                if (do_update && attr == 'rebootCountdown') {
                    do_update = false;
                }
                if (do_update && attr == 'advertisedValue') {
                    do_update = false;
                }
                if (do_update && attr == 'poeCurrent') {
                    do_update = false;
                }
                if (do_update && attr == 'readiness') {
                    do_update = false;
                }
                if (do_update && attr == 'ipAddress') {
                    do_update = false;
                }
                if (do_update && attr == 'subnetMask') {
                    do_update = false;
                }
                if (do_update && attr == 'router') {
                    do_update = false;
                }
                if (do_update && attr == 'linkQuality') {
                    do_update = false;
                }
                if (do_update && attr == 'ssid') {
                    do_update = false;
                }
                if (do_update && attr == 'channel') {
                    do_update = false;
                }
                if (do_update && attr == 'security') {
                    do_update = false;
                }
                if (do_update && attr == 'message') {
                    do_update = false;
                }
                if (do_update && attr == 'currentValue') {
                    do_update = false;
                }
                if (do_update && attr == 'currentRawValue') {
                    do_update = false;
                }
                if (do_update && attr == 'currentRunIndex') {
                    do_update = false;
                }
                if (do_update && attr == 'pulseTimer') {
                    do_update = false;
                }
                if (do_update && attr == 'lastTimePressed') {
                    do_update = false;
                }
                if (do_update && attr == 'lastTimeReleased') {
                    do_update = false;
                }
                if (do_update && attr == 'filesCount') {
                    do_update = false;
                }
                if (do_update && attr == 'freeSpace') {
                    do_update = false;
                }
                if (do_update && attr == 'timeUTC') {
                    do_update = false;
                }
                if (do_update && attr == 'rtcTime') {
                    do_update = false;
                }
                if (do_update && attr == 'unixTime') {
                    do_update = false;
                }
                if (do_update && attr == 'dateTime') {
                    do_update = false;
                }
                if (do_update && attr == 'rawValue') {
                    do_update = false;
                }
                if (do_update && attr == 'lastMsg') {
                    do_update = false;
                }
                if (do_update && attr == 'delayedPulseTimer') {
                    do_update = false;
                }
                if (do_update && attr == 'rxCount') {
                    do_update = false;
                }
                if (do_update && attr == 'txCount') {
                    do_update = false;
                }
                if (do_update && attr == 'msgCount') {
                    do_update = false;
                }
                if (do_update) {
                    do_update = false;
                    newval = new_val_arr[i];
                    j = 0;
                    found = false;
                    while (j < old_jpath.length && !found) {
                        if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
                            found = true;
                            oldval = old_val_arr[j];
                            if (!(newval == oldval)) {
                                do_update = true;
                            }
                        }
                        j = j + 1;
                    }
                }
                if (do_update) {
                    if (attr == 'calibrationParam') {
                        old_calib = '';
                        unit_name = '';
                        sensorType = '';
                        new_calib = newval;
                        j = 0;
                        found = false;
                        while (j < old_jpath.length && !found) {
                            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
                                found = true;
                                old_calib = old_val_arr[j];
                            }
                            j = j + 1;
                        }
                        tmp = fun + '/unit';
                        j = 0;
                        found = false;
                        while (j < new_jpath.length && !found) {
                            if (tmp == new_jpath[j]) {
                                found = true;
                                unit_name = new_val_arr[j];
                            }
                            j = j + 1;
                        }
                        tmp = fun + '/sensorType';
                        j = 0;
                        found = false;
                        while (j < new_jpath.length && !found) {
                            if (tmp == new_jpath[j]) {
                                found = true;
                                sensorType = new_val_arr[j];
                            }
                            j = j + 1;
                        }
                        newval = yield _this73.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
                        url = 'api/' + fun + '.json?' + attr + '=' + _this73.imm_escapeAttr(newval);
                        yield _this73._download(url);
                    } else {
                        url = 'api/' + fun + '.json?' + attr + '=' + _this73.imm_escapeAttr(oldval);
                        if (attr == 'resolution') {
                            restoreLast.push(url);
                        } else {
                            yield _this73._download(url);
                        }
                    }
                }
                i = i + 1;
            }
            for (let ii in restoreLast) {
                yield _this73._download(restoreLast[ii]);;
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Downloads the specified built-in file and returns a binary buffer with its content.
     *
     * @param pathname {string} : name of the new file to load
     *
     * @return {Uint8Array} a binary buffer with the file content
     *
     * On failure, throws an exception or returns  YAPI.INVALID_STRING.
     */
    download(pathname) {
        var _this74 = this;

        return _asyncToGenerator(function* () {
            return yield _this74._download(pathname);
        })();
    }

    /**
     * Returns the icon of the module. The icon is a PNG image and does not
     * exceeds 1536 bytes.
     *
     * @return {Uint8Array} a binary buffer with module icon, in png format.
     *         On failure, throws an exception or returns  YAPI.INVALID_STRING.
     */
    get_icon2d() {
        var _this75 = this;

        return _asyncToGenerator(function* () {
            return yield _this75._download('icon2d.png');
        })();
    }

    /**
     * Returns a string with last logs of the module. This method return only
     * logs that are still in the module.
     *
     * @return {string} a string with last logs of the module.
     *         On failure, throws an exception or returns  YAPI.INVALID_STRING.
     */
    get_lastLogs() {
        var _this76 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let content;
            // may throw an exception
            content = yield _this76._download('logs.txt');
            return _this76._yapi.imm_bin2str(content);
        })();
    }

    // cannot be generated for JS:
    // async get_subDevices()

    /**
     * Continues the module enumeration started using yFirstModule().
     *
     * @return {YModule} a pointer to a YModule object, corresponding to
     *         the next module found, or a null pointer
     *         if there are no more modules to enumerate.
     */
    /* */nextModule() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YModule.FindModuleInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of modules currently accessible.
     * Use the method YModule.nextModule() to iterate on the
     * next modules.
     *
     * @return {YModule} a pointer to a YModule object, corresponding to
     *         the first module currently online, or a null pointer
     *         if there are none.
     */
    static FirstModule() {
        /** @type {string|null} **/
        let next_hwid = YAPI.imm_getFirstHardwareId('Module');
        if (next_hwid == null) return null;
        return YModule.FindModule(next_hwid);
    }

    /**
     * Starts the enumeration of modules currently accessible.
     * Use the method YModule.nextModule() to iterate on the
     * next modules.
     *
     * @return {YModule} a pointer to a YModule object, corresponding to
     *         the first module currently online, or a null pointer
     *         if there are none.
     */
    static FirstModuleInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Module');
        if (next_hwid == null) return null;
        return YModule.FindModuleInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YModule implementation)
}

exports.YModule = YModule; //--- (generated code: Module functions)

/**
 * comment from .yc definition
 */

function yFindModule(func) {
    return YModule.FindModule(func);
}

/**
 * comment from .yc definition
 */
function yFirstModule() {
    return YModule.FirstModule();
}

//--- (end of generated code: Module functions)

//--- (generated code: YSensor class start)
/**
 * YSensor Class: Sensor function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of generated code: YSensor class start)
/** @extends {YFunction} **/
class YSensor extends YFunction {
    constructor(obj_yapi, str_func) {
        //--- (generated code: YSensor constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Sensor';
        /** @member {string} **/
        this._unit = Y_UNIT_INVALID;
        /** @member {number} **/
        this._currentValue = Y_CURRENTVALUE_INVALID;
        /** @member {number} **/
        this._lowestValue = Y_LOWESTVALUE_INVALID;
        /** @member {number} **/
        this._highestValue = Y_HIGHESTVALUE_INVALID;
        /** @member {number} **/
        this._currentRawValue = Y_CURRENTRAWVALUE_INVALID;
        /** @member {string} **/
        this._logFrequency = Y_LOGFREQUENCY_INVALID;
        /** @member {string} **/
        this._reportFrequency = Y_REPORTFREQUENCY_INVALID;
        /** @member {string} **/
        this._calibrationParam = Y_CALIBRATIONPARAM_INVALID;
        /** @member {number} **/
        this._resolution = Y_RESOLUTION_INVALID;
        /** @member {number} **/
        this._sensorState = Y_SENSORSTATE_INVALID;
        /** @member {function} **/
        this._timedReportCallbackSensor = null;
        /** @member {number} **/
        this._prevTimedReport = 0;
        /** @member {number} **/
        this._iresol = 0;
        /** @member {number} **/
        this._offset = 0;
        /** @member {number} **/
        this._scale = 0;
        /** @member {number} **/
        this._decexp = 0;
        /** @member {boolean} **/
        this._isScal = 0;
        /** @member {boolean} **/
        this._isScal32 = 0;
        /** @member {number} **/
        this._caltyp = 0;
        /** @member {number[]} **/
        this._calpar = [];
        /** @member {number[]} **/
        this._calraw = [];
        /** @member {number[]} **/
        this._calref = [];
        /** @member {function} **/
        this._calhdl = null;
        this.imm_setConst({
            UNIT_INVALID: YAPI_INVALID_STRING,
            CURRENTVALUE_INVALID: YAPI_INVALID_DOUBLE,
            LOWESTVALUE_INVALID: YAPI_INVALID_DOUBLE,
            HIGHESTVALUE_INVALID: YAPI_INVALID_DOUBLE,
            CURRENTRAWVALUE_INVALID: YAPI_INVALID_DOUBLE,
            LOGFREQUENCY_INVALID: YAPI_INVALID_STRING,
            REPORTFREQUENCY_INVALID: YAPI_INVALID_STRING,
            CALIBRATIONPARAM_INVALID: YAPI_INVALID_STRING,
            RESOLUTION_INVALID: YAPI_INVALID_DOUBLE,
            SENSORSTATE_INVALID: YAPI_INVALID_INT
        });
        //--- (end of generated code: YSensor constructor)
    }

    //--- (generated code: YSensor implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'unit':
                this._unit = val;
                return 1;
            case 'currentValue':
                this._currentValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'lowestValue':
                this._lowestValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'highestValue':
                this._highestValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'currentRawValue':
                this._currentRawValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'logFrequency':
                this._logFrequency = val;
                return 1;
            case 'reportFrequency':
                this._reportFrequency = val;
                return 1;
            case 'calibrationParam':
                this._calibrationParam = val;
                return 1;
            case 'resolution':
                this._resolution = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'sensorState':
                this._sensorState = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the measuring unit for the measure.
     *
     * @return {string} a string corresponding to the measuring unit for the measure
     *
     * On failure, throws an exception or returns YSensor.UNIT_INVALID.
     */
    get_unit() {
        var _this77 = this;

        return _asyncToGenerator(function* () {
            if (_this77._cacheExpiration <= _this77._yapi.GetTickCount()) {
                if ((yield _this77.load(_this77._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_UNIT_INVALID;
                }
            }
            return _this77._unit;
        })();
    }

    /**
     * Returns the current value of the measure, in the specified unit, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the current value of the measure, in the
     * specified unit, as a floating point number
     *
     * On failure, throws an exception or returns YSensor.CURRENTVALUE_INVALID.
     */
    get_currentValue() {
        var _this78 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let res;
            if (_this78._cacheExpiration <= _this78._yapi.GetTickCount()) {
                if ((yield _this78.load(_this78._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_CURRENTVALUE_INVALID;
                }
            }
            res = yield _this78._applyCalibration(_this78._currentRawValue);
            if (res == Y_CURRENTVALUE_INVALID) {
                res = _this78._currentValue;
            }
            res = res * _this78._iresol;
            return Math.round(res) / _this78._iresol;
        })();
    }

    /**
     * Changes the recorded minimal value observed.
     *
     * @param newval {number} : a floating point number corresponding to the recorded minimal value observed
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_lowestValue(newval) {
        var _this79 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this79._setAttr('lowestValue', rest_val);
        })();
    }

    /**
     * Returns the minimal value observed for the measure since the device was started.
     *
     * @return {number} a floating point number corresponding to the minimal value observed for the
     * measure since the device was started
     *
     * On failure, throws an exception or returns YSensor.LOWESTVALUE_INVALID.
     */
    get_lowestValue() {
        var _this80 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let res;
            if (_this80._cacheExpiration <= _this80._yapi.GetTickCount()) {
                if ((yield _this80.load(_this80._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_LOWESTVALUE_INVALID;
                }
            }
            res = _this80._lowestValue * _this80._iresol;
            return Math.round(res) / _this80._iresol;
        })();
    }

    /**
     * Changes the recorded maximal value observed.
     *
     * @param newval {number} : a floating point number corresponding to the recorded maximal value observed
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_highestValue(newval) {
        var _this81 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this81._setAttr('highestValue', rest_val);
        })();
    }

    /**
     * Returns the maximal value observed for the measure since the device was started.
     *
     * @return {number} a floating point number corresponding to the maximal value observed for the
     * measure since the device was started
     *
     * On failure, throws an exception or returns YSensor.HIGHESTVALUE_INVALID.
     */
    get_highestValue() {
        var _this82 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let res;
            if (_this82._cacheExpiration <= _this82._yapi.GetTickCount()) {
                if ((yield _this82.load(_this82._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_HIGHESTVALUE_INVALID;
                }
            }
            res = _this82._highestValue * _this82._iresol;
            return Math.round(res) / _this82._iresol;
        })();
    }

    /**
     * Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a
     * floating point number.
     *
     * @return {number} a floating point number corresponding to the uncalibrated, unrounded raw value
     * returned by the sensor, in the specified unit, as a floating point number
     *
     * On failure, throws an exception or returns YSensor.CURRENTRAWVALUE_INVALID.
     */
    get_currentRawValue() {
        var _this83 = this;

        return _asyncToGenerator(function* () {
            if (_this83._cacheExpiration <= _this83._yapi.GetTickCount()) {
                if ((yield _this83.load(_this83._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_CURRENTRAWVALUE_INVALID;
                }
            }
            return _this83._currentRawValue;
        })();
    }

    /**
     * Returns the datalogger recording frequency for this function, or "OFF"
     * when measures are not stored in the data logger flash memory.
     *
     * @return {string} a string corresponding to the datalogger recording frequency for this function, or "OFF"
     *         when measures are not stored in the data logger flash memory
     *
     * On failure, throws an exception or returns YSensor.LOGFREQUENCY_INVALID.
     */
    get_logFrequency() {
        var _this84 = this;

        return _asyncToGenerator(function* () {
            if (_this84._cacheExpiration <= _this84._yapi.GetTickCount()) {
                if ((yield _this84.load(_this84._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_LOGFREQUENCY_INVALID;
                }
            }
            return _this84._logFrequency;
        })();
    }

    /**
     * Changes the datalogger recording frequency for this function.
     * The frequency can be specified as samples per second,
     * as sample per minute (for instance "15/m") or in samples per
     * hour (eg. "4/h"). To disable recording for this function, use
     * the value "OFF".
     *
     * @param newval {string} : a string corresponding to the datalogger recording frequency for this function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_logFrequency(newval) {
        var _this85 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this85._setAttr('logFrequency', rest_val);
        })();
    }

    /**
     * Returns the timed value notification frequency, or "OFF" if timed
     * value notifications are disabled for this function.
     *
     * @return {string} a string corresponding to the timed value notification frequency, or "OFF" if timed
     *         value notifications are disabled for this function
     *
     * On failure, throws an exception or returns YSensor.REPORTFREQUENCY_INVALID.
     */
    get_reportFrequency() {
        var _this86 = this;

        return _asyncToGenerator(function* () {
            if (_this86._cacheExpiration <= _this86._yapi.GetTickCount()) {
                if ((yield _this86.load(_this86._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_REPORTFREQUENCY_INVALID;
                }
            }
            return _this86._reportFrequency;
        })();
    }

    /**
     * Changes the timed value notification frequency for this function.
     * The frequency can be specified as samples per second,
     * as sample per minute (for instance "15/m") or in samples per
     * hour (eg. "4/h"). To disable timed value notifications for this
     * function, use the value "OFF".
     *
     * @param newval {string} : a string corresponding to the timed value notification frequency for this function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_reportFrequency(newval) {
        var _this87 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this87._setAttr('reportFrequency', rest_val);
        })();
    }

    get_calibrationParam() {
        var _this88 = this;

        return _asyncToGenerator(function* () {
            if (_this88._cacheExpiration <= _this88._yapi.GetTickCount()) {
                if ((yield _this88.load(_this88._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_CALIBRATIONPARAM_INVALID;
                }
            }
            return _this88._calibrationParam;
        })();
    }

    set_calibrationParam(newval) {
        var _this89 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this89._setAttr('calibrationParam', rest_val);
        })();
    }

    /**
     * Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision
     * when displaying value. It does not change the precision of the measure itself.
     *
     * @param newval {number} : a floating point number corresponding to the resolution of the measured physical values
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_resolution(newval) {
        var _this90 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this90._setAttr('resolution', rest_val);
        })();
    }

    /**
     * Returns the resolution of the measured values. The resolution corresponds to the numerical precision
     * of the measures, which is not always the same as the actual precision of the sensor.
     *
     * @return {number} a floating point number corresponding to the resolution of the measured values
     *
     * On failure, throws an exception or returns YSensor.RESOLUTION_INVALID.
     */
    get_resolution() {
        var _this91 = this;

        return _asyncToGenerator(function* () {
            if (_this91._cacheExpiration <= _this91._yapi.GetTickCount()) {
                if ((yield _this91.load(_this91._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_RESOLUTION_INVALID;
                }
            }
            return _this91._resolution;
        })();
    }

    /**
     * Returns the sensor health state code, which is zero when there is an up-to-date measure
     * available or a positive code if the sensor is not able to provide a measure right now.
     *
     * @return {number} an integer corresponding to the sensor health state code, which is zero when there
     * is an up-to-date measure
     *         available or a positive code if the sensor is not able to provide a measure right now
     *
     * On failure, throws an exception or returns YSensor.SENSORSTATE_INVALID.
     */
    get_sensorState() {
        var _this92 = this;

        return _asyncToGenerator(function* () {
            if (_this92._cacheExpiration <= _this92._yapi.GetTickCount()) {
                if ((yield _this92.load(_this92._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return Y_SENSORSTATE_INVALID;
                }
            }
            return _this92._sensorState;
        })();
    }

    /**
     * Retrieves a sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSensor.isOnline() to test if the sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the sensor
     *
     * @return {YSensor} a YSensor object allowing you to drive the sensor.
     */
    static FindSensor(func) {
        /** @type {YSensor} **/
        let obj;
        //noinspection JSValidateTypes
        obj = YFunction._FindFromCache('Sensor', func);
        if (obj == null) {
            obj = new YSensor(YAPI, func);
            YFunction._AddToCache('Sensor', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSensor.isOnline() to test if the sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the sensor
     *
     * @return {YSensor} a YSensor object allowing you to drive the sensor.
     */
    static FindSensorInContext(yctx, func) {
        /** @type {YSensor} **/
        let obj;
        //noinspection JSValidateTypes
        obj = YFunction._FindFromCacheInContext(yctx, 'Sensor', func);
        if (obj == null) {
            obj = new YSensor(yctx, func);
            YFunction._AddToCache('Sensor', func, obj);
        }
        return obj;
    }

    _parserHelper() {
        var _this93 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let position;
            /** @type {number} **/
            let maxpos;
            /** @type {number[]} **/
            let iCalib = [];
            /** @type {number} **/
            let iRaw;
            /** @type {number} **/
            let iRef;
            /** @type {number} **/
            let fRaw;
            /** @type {number} **/
            let fRef;
            _this93._caltyp = -1;
            _this93._scale = -1;
            _this93._isScal32 = false;
            _this93._calpar.length = 0;
            _this93._calraw.length = 0;
            _this93._calref.length = 0;
            // Store inverted resolution, to provide better rounding
            if (_this93._resolution > 0) {
                _this93._iresol = Math.round(1.0 / _this93._resolution);
            } else {
                _this93._iresol = 10000;
                _this93._resolution = 0.0001;
            }
            // Old format: supported when there is no calibration
            if (_this93._calibrationParam == '' || _this93._calibrationParam == '0') {
                _this93._caltyp = 0;
                return 0;
            }
            if (_this93._calibrationParam.indexOf(',') >= 0) {
                iCalib = _this93._yapi.imm_decodeFloats(_this93._calibrationParam);
                _this93._caltyp = parseInt(iCalib[0] / 1000, 10);
                if (_this93._caltyp > 0) {
                    if (_this93._caltyp < YOCTO_CALIB_TYPE_OFS) {
                        _this93._caltyp = -1;
                        return 0;
                    }
                    _this93.imm_calhdl = _this93._yapi.imm_getCalibrationHandler(_this93._caltyp);
                    if (!(_this93.imm_calhdl != null)) {
                        _this93._caltyp = -1;
                        return 0;
                    }
                }
                _this93._isScal = true;
                _this93._isScal32 = true;
                _this93._offset = 0;
                _this93._scale = 1000;
                maxpos = iCalib.length;
                _this93._calpar.length = 0;
                position = 1;
                while (position < maxpos) {
                    _this93._calpar.push(iCalib[position]);
                    position = position + 1;
                }
                _this93._calraw.length = 0;
                _this93._calref.length = 0;
                position = 1;
                while (position + 1 < maxpos) {
                    fRaw = iCalib[position];
                    fRaw = fRaw / 1000.0;
                    fRef = iCalib[position + 1];
                    fRef = fRef / 1000.0;
                    _this93._calraw.push(fRaw);
                    _this93._calref.push(fRef);
                    position = position + 2;
                }
            } else {
                iCalib = _this93._yapi.imm_decodeWords(_this93._calibrationParam);
                if (iCalib.length < 2) {
                    _this93._caltyp = -1;
                    return 0;
                }
                _this93._isScal = iCalib[1] > 0;
                if (_this93._isScal) {
                    _this93._offset = iCalib[0];
                    if (_this93._offset > 32767) {
                        _this93._offset = _this93._offset - 65536;
                    }
                    _this93._scale = iCalib[1];
                    _this93._decexp = 0;
                } else {
                    _this93._offset = 0;
                    _this93._scale = 1;
                    _this93._decexp = 1.0;
                    position = iCalib[0];
                    while (position > 0) {
                        _this93._decexp = _this93._decexp * 10;
                        position = position - 1;
                    }
                }
                if (iCalib.length == 2) {
                    _this93._caltyp = 0;
                    return 0;
                }
                _this93._caltyp = iCalib[2];
                _this93.imm_calhdl = _this93._yapi.imm_getCalibrationHandler(_this93._caltyp);
                if (_this93._caltyp <= 10) {
                    maxpos = _this93._caltyp;
                } else {
                    if (_this93._caltyp <= 20) {
                        maxpos = _this93._caltyp - 10;
                    } else {
                        maxpos = 5;
                    }
                }
                maxpos = 3 + 2 * maxpos;
                if (maxpos > iCalib.length) {
                    maxpos = iCalib.length;
                }
                _this93._calpar.length = 0;
                _this93._calraw.length = 0;
                _this93._calref.length = 0;
                position = 3;
                while (position + 1 < maxpos) {
                    iRaw = iCalib[position];
                    iRef = iCalib[position + 1];
                    _this93._calpar.push(iRaw);
                    _this93._calpar.push(iRef);
                    if (_this93._isScal) {
                        fRaw = iRaw;
                        fRaw = (fRaw - _this93._offset) / _this93._scale;
                        fRef = iRef;
                        fRef = (fRef - _this93._offset) / _this93._scale;
                        _this93._calraw.push(fRaw);
                        _this93._calref.push(fRef);
                    } else {
                        _this93._calraw.push(_this93._yapi.imm_decimalToDouble(iRaw));
                        _this93._calref.push(_this93._yapi.imm_decimalToDouble(iRef));
                    }
                    position = position + 2;
                }
            }
            return 0;
        })();
    }

    /**
     * Checks if the sensor is currently able to provide an up-to-date measure.
     * Returns false if the device is unreachable, or if the sensor does not have
     * a current measure to transmit. No exception is raised if there is an error
     * while trying to contact the device hosting $THEFUNCTION$.
     *
     * @return {boolean} true if the sensor can provide an up-to-date measure, and false otherwise
     */
    isSensorReady() {
        var _this94 = this;

        return _asyncToGenerator(function* () {
            if (!(yield _this94.isOnline())) {
                return false;
            }
            if (!(_this94._sensorState == 0)) {
                return false;
            }
            return true;
        })();
    }

    /**
     * Starts the data logger on the device. Note that the data logger
     * will only save the measures on this sensor if the logFrequency
     * is not set to "OFF".
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     */
    startDataLogger() {
        var _this95 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let res;
            // may throw an exception
            res = yield _this95._download('api/dataLogger/recording?recording=1');
            if (!(res.length > 0)) {
                return _this95._throw(YAPI_IO_ERROR, 'unable to start datalogger', YAPI_IO_ERROR);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Stops the datalogger on the device.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     */
    stopDataLogger() {
        var _this96 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let res;
            // may throw an exception
            res = yield _this96._download('api/dataLogger/recording?recording=0');
            if (!(res.length > 0)) {
                return _this96._throw(YAPI_IO_ERROR, 'unable to stop datalogger', YAPI_IO_ERROR);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Retrieves a DataSet object holding historical data for this
     * sensor, for a specified time interval. The measures will be
     * retrieved from the data logger, which must have been turned
     * on at the desired time. See the documentation of the DataSet
     * class for information on how to get an overview of the
     * recorded data, and how to load progressively a large set
     * of measures from the data logger.
     *
     * This function only works if the device uses a recent firmware,
     * as DataSet objects are not supported by firmwares older than
     * version 13000.
     *
     * @param startTime {number} : the start of the desired measure time interval,
     *         as a Unix timestamp, i.e. the number of seconds since
     *         January 1, 1970 UTC. The special value 0 can be used
     *         to include any meaasure, without initial limit.
     * @param endTime {number} : the end of the desired measure time interval,
     *         as a Unix timestamp, i.e. the number of seconds since
     *         January 1, 1970 UTC. The special value 0 can be used
     *         to include any meaasure, without ending limit.
     *
     * @return {YDataSet} an instance of YDataSet, providing access to historical
     *         data. Past measures can be loaded progressively
     *         using methods from the YDataSet object.
     */
    get_recordedData(startTime, endTime) {
        var _this97 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let funcid;
            /** @type {string} **/
            let funit;
            // may throw an exception
            funcid = yield _this97.get_functionId();
            funit = yield _this97.get_unit();
            return new YDataSet(_this97, funcid, funit, startTime, endTime);
        })();
    }

    /**
     * Registers the callback function that is invoked on every periodic timed notification.
     * The callback is invoked only during the execution of ySleep or yHandleEvents.
     * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
     * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
     *
     * @param callback {function} : the callback function to call, or a null pointer. The callback
     * function should take two
     *         arguments: the function object of which the value has changed, and an YMeasure object describing
     *         the new advertised value.
     * @noreturn
     */
    registerTimedReportCallback(callback) {
        var _this98 = this;

        return _asyncToGenerator(function* () {
            if (callback != null) {
                yield YFunction._UpdateTimedReportCallbackList(_this98, true);
            } else {
                yield YFunction._UpdateTimedReportCallbackList(_this98, false);
            }
            _this98._timedReportCallbackSensor = callback;
            return 0;
        })();
    }

    _invokeTimedReportCallback(value) {
        var _this99 = this;

        return _asyncToGenerator(function* () {
            if (_this99._timedReportCallbackSensor != null) {
                yield _this99._timedReportCallbackSensor(_this99, value);
            } else {}
            return 0;
        })();
    }

    /**
     * Configures error correction data points, in particular to compensate for
     * a possible perturbation of the measure caused by an enclosure. It is possible
     * to configure up to five correction points. Correction points must be provided
     * in ascending order, and be in the range of the sensor. The device will automatically
     * perform a linear interpolation of the error correction between specified
     * points. Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * For more information on advanced capabilities to refine the calibration of
     * sensors, please contact support@yoctopuce.com.
     *
     * @param rawValues {number[]} : array of floating point numbers, corresponding to the raw
     *         values returned by the sensor for the correction points.
     * @param refValues {number[]} : array of floating point numbers, corresponding to the corrected
     *         values for the correction points.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    calibrateFromPoints(rawValues, refValues) {
        var _this100 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            // may throw an exception
            rest_val = yield _this100._encodeCalibrationPoints(rawValues, refValues);
            return yield _this100._setAttr('calibrationParam', rest_val);
        })();
    }

    /**
     * Retrieves error correction data points previously entered using the method
     * calibrateFromPoints.
     *
     * @param rawValues {number[]} : array of floating point numbers, that will be filled by the
     *         function with the raw sensor values for the correction points.
     * @param refValues {number[]} : array of floating point numbers, that will be filled by the
     *         function with the desired values for the correction points.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    loadCalibrationPoints(rawValues, refValues) {
        var _this101 = this;

        return _asyncToGenerator(function* () {
            rawValues.length = 0;
            refValues.length = 0;
            // Load function parameters if not yet loaded
            if (_this101._scale == 0) {
                if ((yield _this101.load(_this101._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
            }
            if (_this101._caltyp < 0) {
                _this101._throw(YAPI_NOT_SUPPORTED, 'Calibration parameters format mismatch. Please upgrade your library or firmware.');
                return YAPI_NOT_SUPPORTED;
            }
            rawValues.length = 0;
            refValues.length = 0;
            for (let ii in _this101._calraw) {
                rawValues.push(_this101._calraw[ii]);
            }
            for (let ii in _this101._calref) {
                refValues.push(_this101._calref[ii]);
            }
            return YAPI_SUCCESS;
        })();
    }

    _encodeCalibrationPoints(rawValues, refValues) {
        var _this102 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let res;
            /** @type {number} **/
            let npt;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let iRaw;
            /** @type {number} **/
            let iRef;
            npt = rawValues.length;
            if (npt != refValues.length) {
                _this102._throw(YAPI_INVALID_ARGUMENT, 'Invalid calibration parameters (size mismatch)');
                return YAPI_INVALID_STRING;
            }
            // Shortcut when building empty calibration parameters
            if (npt == 0) {
                return '0';
            }
            // Load function parameters if not yet loaded
            if (_this102._scale == 0) {
                if ((yield _this102.load(_this102._yapi.defaultCacheValidity)) != YAPI_SUCCESS) {
                    return YAPI_INVALID_STRING;
                }
            }
            // Detect old firmware
            if (_this102._caltyp < 0 || _this102._scale < 0) {
                _this102._throw(YAPI_NOT_SUPPORTED, 'Calibration parameters format mismatch. Please upgrade your library or firmware.');
                return '0';
            }
            if (_this102._isScal32) {
                res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
                idx = 0;
                while (idx < npt) {
                    res = res + ',' + String(Math.round(rawValues[idx] * 1000) / 1000) + ',' + String(Math.round(refValues[idx] * 1000) / 1000);
                    idx = idx + 1;
                }
            } else {
                if (_this102._isScal) {
                    res = String(Math.round(npt));
                    idx = 0;
                    while (idx < npt) {
                        iRaw = Math.round(rawValues[idx] * _this102._scale + _this102._offset);
                        iRef = Math.round(refValues[idx] * _this102._scale + _this102._offset);
                        res = res + ',' + String(Math.round(iRaw)) + ',' + String(Math.round(iRef));
                        idx = idx + 1;
                    }
                } else {
                    res = String(Math.round(10 + npt));
                    idx = 0;
                    while (idx < npt) {
                        iRaw = _this102._yapi.imm_doubleToDecimal(rawValues[idx]);
                        iRef = _this102._yapi.imm_doubleToDecimal(refValues[idx]);
                        res = res + ',' + String(Math.round(iRaw)) + ',' + String(Math.round(iRef));
                        idx = idx + 1;
                    }
                }
            }
            return res;
        })();
    }

    _applyCalibration(rawValue) {
        var _this103 = this;

        return _asyncToGenerator(function* () {
            if (rawValue == Y_CURRENTVALUE_INVALID) {
                return Y_CURRENTVALUE_INVALID;
            }
            if (_this103._caltyp == 0) {
                return rawValue;
            }
            if (_this103._caltyp < 0) {
                return Y_CURRENTVALUE_INVALID;
            }
            if (!(_this103.imm_calhdl != null)) {
                return Y_CURRENTVALUE_INVALID;
            }
            return _this103.imm_calhdl(rawValue, _this103._caltyp, _this103._calpar, _this103._calraw, _this103._calref);
        })();
    }

    _decodeTimedReport(timestamp, report) {
        var _this104 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let i;
            /** @type {number} **/
            let byteVal;
            /** @type {number} **/
            let poww;
            /** @type {number} **/
            let minRaw;
            /** @type {number} **/
            let avgRaw;
            /** @type {number} **/
            let maxRaw;
            /** @type {number} **/
            let sublen;
            /** @type {number} **/
            let difRaw;
            /** @type {number} **/
            let startTime;
            /** @type {number} **/
            let endTime;
            /** @type {number} **/
            let minVal;
            /** @type {number} **/
            let avgVal;
            /** @type {number} **/
            let maxVal;
            startTime = _this104._prevTimedReport;
            endTime = timestamp;
            _this104._prevTimedReport = endTime;
            if (startTime == 0) {
                startTime = endTime;
            }
            if (report[0] == 2) {
                if (report.length <= 5) {
                    poww = 1;
                    avgRaw = 0;
                    byteVal = 0;
                    i = 1;
                    while (i < report.length) {
                        byteVal = report[i];
                        avgRaw = avgRaw + poww * byteVal;
                        poww = poww * 0x100;
                        i = i + 1;
                    }
                    if ((byteVal & 0x80) != 0) {
                        avgRaw = avgRaw - poww;
                    }
                    avgVal = avgRaw / 1000.0;
                    if (_this104._caltyp != 0) {
                        if (_this104.imm_calhdl != null) {
                            avgVal = _this104.imm_calhdl(avgVal, _this104._caltyp, _this104._calpar, _this104._calraw, _this104._calref);
                        }
                    }
                    minVal = avgVal;
                    maxVal = avgVal;
                } else {
                    sublen = 1 + (report[1] & 3);
                    poww = 1;
                    avgRaw = 0;
                    byteVal = 0;
                    i = 2;
                    while (sublen > 0 && i < report.length) {
                        byteVal = report[i];
                        avgRaw = avgRaw + poww * byteVal;
                        poww = poww * 0x100;
                        i = i + 1;
                        sublen = sublen - 1;
                    }
                    if ((byteVal & 0x80) != 0) {
                        avgRaw = avgRaw - poww;
                    }
                    sublen = 1 + (report[1] >> 2 & 3);
                    poww = 1;
                    difRaw = 0;
                    while (sublen > 0 && i < report.length) {
                        byteVal = report[i];
                        difRaw = difRaw + poww * byteVal;
                        poww = poww * 0x100;
                        i = i + 1;
                        sublen = sublen - 1;
                    }
                    minRaw = avgRaw - difRaw;
                    sublen = 1 + (report[1] >> 4 & 3);
                    poww = 1;
                    difRaw = 0;
                    while (sublen > 0 && i < report.length) {
                        byteVal = report[i];
                        difRaw = difRaw + poww * byteVal;
                        poww = poww * 0x100;
                        i = i + 1;
                        sublen = sublen - 1;
                    }
                    maxRaw = avgRaw + difRaw;
                    avgVal = avgRaw / 1000.0;
                    minVal = minRaw / 1000.0;
                    maxVal = maxRaw / 1000.0;
                    if (_this104._caltyp != 0) {
                        if (_this104.imm_calhdl != null) {
                            avgVal = _this104.imm_calhdl(avgVal, _this104._caltyp, _this104._calpar, _this104._calraw, _this104._calref);
                            minVal = _this104.imm_calhdl(minVal, _this104._caltyp, _this104._calpar, _this104._calraw, _this104._calref);
                            maxVal = _this104.imm_calhdl(maxVal, _this104._caltyp, _this104._calpar, _this104._calraw, _this104._calref);
                        }
                    }
                }
            } else {
                if (report[0] == 0) {
                    poww = 1;
                    avgRaw = 0;
                    byteVal = 0;
                    i = 1;
                    while (i < report.length) {
                        byteVal = report[i];
                        avgRaw = avgRaw + poww * byteVal;
                        poww = poww * 0x100;
                        i = i + 1;
                    }
                    if (_this104._isScal) {
                        avgVal = _this104.imm_decodeVal(avgRaw);
                    } else {
                        if ((byteVal & 0x80) != 0) {
                            avgRaw = avgRaw - poww;
                        }
                        avgVal = _this104.imm_decodeAvg(avgRaw);
                    }
                    minVal = avgVal;
                    maxVal = avgVal;
                } else {
                    minRaw = report[1] + 0x100 * report[2];
                    maxRaw = report[3] + 0x100 * report[4];
                    avgRaw = report[5] + 0x100 * report[6] + 0x10000 * report[7];
                    byteVal = report[8];
                    if ((byteVal & 0x80) == 0) {
                        avgRaw = avgRaw + 0x1000000 * byteVal;
                    } else {
                        avgRaw = avgRaw - 0x1000000 * (0x100 - byteVal);
                    }
                    minVal = _this104.imm_decodeVal(minRaw);
                    avgVal = _this104.imm_decodeAvg(avgRaw);
                    maxVal = _this104.imm_decodeVal(maxRaw);
                }
            }
            return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
        })();
    }

    /* */imm_decodeVal(w) {
        /** @type {number} **/
        let val;
        val = w;
        if (this._isScal) {
            val = (val - this._offset) / this._scale;
        } else {
            val = this._yapi.imm_decimalToDouble(w);
        }
        if (this._caltyp != 0) {
            if (this.imm_calhdl != null) {
                val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
            }
        }
        return val;
    }

    /* */imm_decodeAvg(dw) {
        /** @type {number} **/
        let val;
        val = dw;
        if (this._isScal) {
            val = (val / 100 - this._offset) / this._scale;
        } else {
            val = val / this._decexp;
        }
        if (this._caltyp != 0) {
            if (this.imm_calhdl != null) {
                val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
            }
        }
        return val;
    }

    /**
     * Continues the enumeration of sensors started using yFirstSensor().
     *
     * @return {YSensor} a pointer to a YSensor object, corresponding to
     *         a sensor currently online, or a null pointer
     *         if there are no more sensors to enumerate.
     */
    /* */nextSensor() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YSensor.FindSensorInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of sensors currently accessible.
     * Use the method YSensor.nextSensor() to iterate on
     * next sensors.
     *
     * @return {YSensor} a pointer to a YSensor object, corresponding to
     *         the first sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstSensor() {
        /** @type {string|null} **/
        let next_hwid = YAPI.imm_getFirstHardwareId('Sensor');
        if (next_hwid == null) return null;
        return YSensor.FindSensor(next_hwid);
    }

    /**
     * Starts the enumeration of sensors currently accessible.
     * Use the method YSensor.nextSensor() to iterate on
     * next sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YSensor} a pointer to a YSensor object, corresponding to
     *         the first sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstSensorInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Sensor');
        if (next_hwid == null) return null;
        return YSensor.FindSensorInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YSensor implementation)
}

//--- (generated code: Sensor functions)

/**
 * comment from .yc definition
 */
function yFindSensor(func) {
    return YSensor.FindSensor(func);
}

/**
 * comment from .yc definition
 */
function yFirstSensor() {
    return YSensor.FirstSensor();
}

//--- (end of generated code: Sensor functions)

//--- (generated code: YMeasure definitions)
//--- (end of generated code: YMeasure definitions)

//--- (generated code: YMeasure class start)
/**
 * YMeasure Class: Measured value
 *
 * YMeasure objects are used within the API to represent
 * a value measured at a specified time. These objects are
 * used in particular in conjunction with the YDataSet class.
 */
//--- (end of generated code: YMeasure class start)
class YMeasure {
    constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
        //--- (generated code: YMeasure constructor)
        /** @member {number} **/
        this._start = 0;
        /** @member {number} **/
        this._end = 0;
        /** @member {number} **/
        this._minVal = 0;
        /** @member {number} **/
        this._avgVal = 0;
        /** @member {number} **/
        this._maxVal = 0;
        //--- (end of generated code: YMeasure constructor)
        this._start = float_start;
        this._end = float_end;
        this._minVal = float_minVal;
        this._avgVal = float_avgVal;
        this._maxVal = float_maxVal;
    }
    //--- (generated code: YMeasure implementation)

    /**
     * Returns the start time of the measure, relative to the Jan 1, 1970 UTC
     * (Unix timestamp). When the recording rate is higher then 1 sample
     * per second, the timestamp may have a fractional part.
     *
     * @return {number} an floating point number corresponding to the number of seconds
     *         between the Jan 1, 1970 UTC and the beginning of this measure.
     */
    /* */get_startTimeUTC() {
        return this._start;
    }

    /**
     * Returns the end time of the measure, relative to the Jan 1, 1970 UTC
     * (Unix timestamp). When the recording rate is higher than 1 sample
     * per second, the timestamp may have a fractional part.
     *
     * @return {number} an floating point number corresponding to the number of seconds
     *         between the Jan 1, 1970 UTC and the end of this measure.
     */
    /* */get_endTimeUTC() {
        return this._end;
    }

    /**
     * Returns the smallest value observed during the time interval
     * covered by this measure.
     *
     * @return {number} a floating-point number corresponding to the smallest value observed.
     */
    /* */get_minValue() {
        return this._minVal;
    }

    /**
     * Returns the average value observed during the time interval
     * covered by this measure.
     *
     * @return {number} a floating-point number corresponding to the average value observed.
     */
    /* */get_averageValue() {
        return this._avgVal;
    }

    /**
     * Returns the largest value observed during the time interval
     * covered by this measure.
     *
     * @return {number} a floating-point number corresponding to the largest value observed.
     */
    /* */get_maxValue() {
        return this._maxVal;
    }

    //--- (end of generated code: YMeasure implementation)

    /**
     * Returns the start date of the measure.
     *
     * @return {Date} a Date object corresponding to the beginning of this measure
     */
    get_startTimeUTC_asDate() {
        return new Date(Math.round(this._start * 1000));
    }

    /**
     * Returns the start date of the measure.
     *
     * @return {Date} a Date object corresponding to the end of this measure
     */
    get_endTimeUTC_asDate() {
        return new Date(Math.round(this._end * 1000));
    }
}

//--- (generated code: YDataStream definitions)
//--- (end of generated code: YDataStream definitions)

//--- (generated code: YDataStream class start)
/**
 * YDataStream Class: Unformatted data sequence
 *
 * YDataStream objects represent bare recorded measure sequences,
 * exactly as found within the data logger present on Yoctopuce
 * sensors.
 *
 * In most cases, it is not necessary to use YDataStream objects
 * directly, as the YDataSet objects (returned by the
 * get_recordedData() method from sensors and the
 * get_dataSets() method from the data logger) provide
 * a more convenient interface.
 */
//--- (end of generated code: YDataStream class start)
class YDataStream {
    constructor(obj_parent, obj_dataset, encoded) {
        //--- (generated code: YDataStream constructor)
        /** @member {YFunction} **/
        this._parent = null;
        /** @member {number} **/
        this._runNo = 0;
        /** @member {number} **/
        this._utcStamp = 0;
        /** @member {number} **/
        this._nCols = 0;
        /** @member {number} **/
        this._nRows = 0;
        /** @member {number} **/
        this._duration = 0;
        /** @member {string[]} **/
        this._columnNames = [];
        /** @member {string} **/
        this._functionId = '';
        /** @member {boolean} **/
        this._isClosed = 0;
        /** @member {boolean} **/
        this._isAvg = 0;
        /** @member {boolean} **/
        this._isScal = 0;
        /** @member {boolean} **/
        this._isScal32 = 0;
        /** @member {number} **/
        this._decimals = 0;
        /** @member {number} **/
        this._offset = 0;
        /** @member {number} **/
        this._scale = 0;
        /** @member {number} **/
        this._samplesPerHour = 0;
        /** @member {number} **/
        this._minVal = 0;
        /** @member {number} **/
        this._avgVal = 0;
        /** @member {number} **/
        this._maxVal = 0;
        /** @member {number} **/
        this._decexp = 0;
        /** @member {number} **/
        this._caltyp = 0;
        /** @member {number[]} **/
        this._calpar = [];
        /** @member {number[]} **/
        this._calraw = [];
        /** @member {number[]} **/
        this._calref = [];
        /** @member {number[][]} **/
        this._values = [];
        //--- (end of generated code: YDataStream constructor)

        this._parent = obj_parent;
        this._calhdl = null;
        if (typeof obj_dataset != 'undefined') {
            this.imm_initFromDataSet(obj_dataset, encoded);
        }
    }

    //--- (generated code: YDataStream implementation)

    /* */imm_initFromDataSet(dataset, encoded) {
        /** @type {number} **/
        let val;
        /** @type {number} **/
        let i;
        /** @type {number} **/
        let maxpos;
        /** @type {number} **/
        let iRaw;
        /** @type {number} **/
        let iRef;
        /** @type {number} **/
        let fRaw;
        /** @type {number} **/
        let fRef;
        /** @type {number} **/
        let duration_float;
        /** @type {number[]} **/
        let iCalib = [];
        // decode sequence header to extract data
        this._runNo = encoded[0] + (encoded[1] << 16);
        this._utcStamp = encoded[2] + (encoded[3] << 16);
        val = encoded[4];
        this._isAvg = (val & 0x100) == 0;
        this._samplesPerHour = val & 0xff;
        if ((val & 0x100) != 0) {
            this._samplesPerHour = this._samplesPerHour * 3600;
        } else {
            if ((val & 0x200) != 0) {
                this._samplesPerHour = this._samplesPerHour * 60;
            }
        }
        val = encoded[5];
        if (val > 32767) {
            val = val - 65536;
        }
        this._decimals = val;
        this._offset = val;
        this._scale = encoded[6];
        this._isScal = this._scale != 0;
        this._isScal32 = encoded.length >= 14;
        val = encoded[7];
        this._isClosed = val != 0xffff;
        if (val == 0xffff) {
            val = 0;
        }
        this._nRows = val;
        duration_float = this._nRows * 3600 / this._samplesPerHour;
        this._duration = Math.round(duration_float);
        // precompute decoding parameters
        this._decexp = 1.0;
        if (this._scale == 0) {
            i = 0;
            while (i < this._decimals) {
                this._decexp = this._decexp * 10.0;
                i = i + 1;
            }
        }
        iCalib = dataset.imm_get_calibration();
        this._caltyp = iCalib[0];
        if (this._caltyp != 0) {
            this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
            maxpos = iCalib.length;
            this._calpar.length = 0;
            this._calraw.length = 0;
            this._calref.length = 0;
            if (this._isScal32) {
                i = 1;
                while (i < maxpos) {
                    this._calpar.push(iCalib[i]);
                    i = i + 1;
                }
                i = 1;
                while (i + 1 < maxpos) {
                    fRaw = iCalib[i];
                    fRaw = fRaw / 1000.0;
                    fRef = iCalib[i + 1];
                    fRef = fRef / 1000.0;
                    this._calraw.push(fRaw);
                    this._calref.push(fRef);
                    i = i + 2;
                }
            } else {
                i = 1;
                while (i + 1 < maxpos) {
                    iRaw = iCalib[i];
                    iRef = iCalib[i + 1];
                    this._calpar.push(iRaw);
                    this._calpar.push(iRef);
                    if (this._isScal) {
                        fRaw = iRaw;
                        fRaw = (fRaw - this._offset) / this._scale;
                        fRef = iRef;
                        fRef = (fRef - this._offset) / this._scale;
                        this._calraw.push(fRaw);
                        this._calref.push(fRef);
                    } else {
                        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
                        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
                    }
                    i = i + 2;
                }
            }
        }
        // preload column names for backward-compatibility
        this._functionId = dataset.imm_get_functionId();
        if (this._isAvg) {
            this._columnNames.length = 0;
            this._columnNames.push(this._functionId + '_min');
            this._columnNames.push(this._functionId + '_avg');
            this._columnNames.push(this._functionId + '_max');
            this._nCols = 3;
        } else {
            this._columnNames.length = 0;
            this._columnNames.push(this._functionId);
            this._nCols = 1;
        }
        // decode min/avg/max values for the sequence
        if (this._nRows > 0) {
            if (this._isScal32) {
                this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 0x8000) << 16), 1);
                this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
                this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
            } else {
                this._minVal = this.imm_decodeVal(encoded[8]);
                this._maxVal = this.imm_decodeVal(encoded[9]);
                this._avgVal = this.imm_decodeAvg(encoded[10] + (encoded[11] << 16), this._nRows);
            }
        }
        return 0;
    }

    /* */imm_parseStream(sdata) {
        /** @type {number} **/
        let idx;
        /** @type {number[]} **/
        let udat = [];
        /** @type {number[]} **/
        let dat = [];
        if (sdata.length == 0) {
            this._nRows = 0;
            return YAPI_SUCCESS;
        }
        // may throw an exception
        udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
        this._values.length = 0;
        idx = 0;
        if (this._isAvg) {
            while (idx + 3 < udat.length) {
                dat.length = 0;
                if (this._isScal32) {
                    dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
                    dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 0x8000) << 16), 1));
                    dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
                    idx = idx + 6;
                } else {
                    dat.push(this.imm_decodeVal(udat[idx]));
                    dat.push(this.imm_decodeAvg(udat[idx + 2] + (udat[idx + 3] << 16), 1));
                    dat.push(this.imm_decodeVal(udat[idx + 1]));
                    idx = idx + 4;
                }
                this._values.push(dat.slice());
            }
        } else {
            if (this._isScal && !this._isScal32) {
                while (idx < udat.length) {
                    dat.length = 0;
                    dat.push(this.imm_decodeVal(udat[idx]));
                    this._values.push(dat.slice());
                    idx = idx + 1;
                }
            } else {
                while (idx + 1 < udat.length) {
                    dat.length = 0;
                    dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 0x8000) << 16), 1));
                    this._values.push(dat.slice());
                    idx = idx + 2;
                }
            }
        }

        this._nRows = this._values.length;
        return YAPI_SUCCESS;
    }

    /* */imm_get_url() {
        /** @type {string} **/
        let url;
        url = 'logger.json?id=' + this._functionId + '&run=' + String(Math.round(this._runNo)) + '&utc=' + String(Math.round(this._utcStamp));
        return url;
    }

    loadStream() {
        var _this105 = this;

        return _asyncToGenerator(function* () {
            return _this105.imm_parseStream((yield _this105._parent._download(_this105.imm_get_url())));
        })();
    }

    /* */imm_decodeVal(w) {
        /** @type {number} **/
        let val;
        val = w;
        if (this._isScal32) {
            val = val / 1000.0;
        } else {
            if (this._isScal) {
                val = (val - this._offset) / this._scale;
            } else {
                val = this._yapi.imm_decimalToDouble(w);
            }
        }
        if (this._caltyp != 0) {
            val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
        }
        return val;
    }

    /* */imm_decodeAvg(dw, count) {
        /** @type {number} **/
        let val;
        val = dw;
        if (this._isScal32) {
            val = val / 1000.0;
        } else {
            if (this._isScal) {
                val = (val / (100 * count) - this._offset) / this._scale;
            } else {
                val = val / (count * this._decexp);
            }
        }
        if (this._caltyp != 0) {
            val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
        }
        return val;
    }

    isClosed() {
        var _this106 = this;

        return _asyncToGenerator(function* () {
            return _this106._isClosed;
        })();
    }

    /**
     * Returns the run index of the data stream. A run can be made of
     * multiple datastreams, for different time intervals.
     *
     * @return {number} an unsigned number corresponding to the run index.
     */
    get_runIndex() {
        var _this107 = this;

        return _asyncToGenerator(function* () {
            return _this107._runNo;
        })();
    }

    /**
     * Returns the relative start time of the data stream, measured in seconds.
     * For recent firmwares, the value is relative to the present time,
     * which means the value is always negative.
     * If the device uses a firmware older than version 13000, value is
     * relative to the start of the time the device was powered on, and
     * is always positive.
     * If you need an absolute UTC timestamp, use get_startTimeUTC().
     *
     * @return {number} an unsigned number corresponding to the number of seconds
     *         between the start of the run and the beginning of this data
     *         stream.
     */
    get_startTime() {
        var _this108 = this;

        return _asyncToGenerator(function* () {
            return _this108._utcStamp - parseInt(+new Date() / 1000, 10);
        })();
    }

    /**
     * Returns the start time of the data stream, relative to the Jan 1, 1970.
     * If the UTC time was not set in the datalogger at the time of the recording
     * of this data stream, this method returns 0.
     *
     * @return {number} an unsigned number corresponding to the number of seconds
     *         between the Jan 1, 1970 and the beginning of this data
     *         stream (i.e. Unix time representation of the absolute time).
     */
    get_startTimeUTC() {
        var _this109 = this;

        return _asyncToGenerator(function* () {
            return _this109._utcStamp;
        })();
    }

    /**
     * Returns the number of milliseconds between two consecutive
     * rows of this data stream. By default, the data logger records one row
     * per second, but the recording frequency can be changed for
     * each device function
     *
     * @return {number} an unsigned number corresponding to a number of milliseconds.
     */
    get_dataSamplesIntervalMs() {
        var _this110 = this;

        return _asyncToGenerator(function* () {
            return parseInt(3600000 / _this110._samplesPerHour, 10);
        })();
    }

    get_dataSamplesInterval() {
        var _this111 = this;

        return _asyncToGenerator(function* () {
            return 3600.0 / _this111._samplesPerHour;
        })();
    }

    /**
     * Returns the number of data rows present in this stream.
     *
     * If the device uses a firmware older than version 13000,
     * this method fetches the whole data stream from the device
     * if not yet done, which can cause a little delay.
     *
     * @return {number} an unsigned number corresponding to the number of rows.
     *
     * On failure, throws an exception or returns zero.
     */
    get_rowCount() {
        var _this112 = this;

        return _asyncToGenerator(function* () {
            if (_this112._nRows != 0 && _this112._isClosed) {
                return _this112._nRows;
            }
            yield _this112.loadStream();
            return _this112._nRows;
        })();
    }

    /**
     * Returns the number of data columns present in this stream.
     * The meaning of the values present in each column can be obtained
     * using the method get_columnNames().
     *
     * If the device uses a firmware older than version 13000,
     * this method fetches the whole data stream from the device
     * if not yet done, which can cause a little delay.
     *
     * @return {number} an unsigned number corresponding to the number of columns.
     *
     * On failure, throws an exception or returns zero.
     */
    get_columnCount() {
        var _this113 = this;

        return _asyncToGenerator(function* () {
            if (_this113._nCols != 0) {
                return _this113._nCols;
            }
            yield _this113.loadStream();
            return _this113._nCols;
        })();
    }

    /**
     * Returns the title (or meaning) of each data column present in this stream.
     * In most case, the title of the data column is the hardware identifier
     * of the sensor that produced the data. For streams recorded at a lower
     * recording rate, the dataLogger stores the min, average and max value
     * during each measure interval into three columns with suffixes _min,
     * _avg and _max respectively.
     *
     * If the device uses a firmware older than version 13000,
     * this method fetches the whole data stream from the device
     * if not yet done, which can cause a little delay.
     *
     * @return {string[]} a list containing as many strings as there are columns in the
     *         data stream.
     *
     * On failure, throws an exception or returns an empty array.
     */
    get_columnNames() {
        var _this114 = this;

        return _asyncToGenerator(function* () {
            if (_this114._columnNames.length != 0) {
                return _this114._columnNames;
            }
            yield _this114.loadStream();
            return _this114._columnNames;
        })();
    }

    /**
     * Returns the smallest measure observed within this stream.
     * If the device uses a firmware older than version 13000,
     * this method will always return YDataStream.DATA_INVALID.
     *
     * @return {number} a floating-point number corresponding to the smallest value,
     *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
     *
     * On failure, throws an exception or returns YDataStream.DATA_INVALID.
     */
    get_minValue() {
        var _this115 = this;

        return _asyncToGenerator(function* () {
            return _this115._minVal;
        })();
    }

    /**
     * Returns the average of all measures observed within this stream.
     * If the device uses a firmware older than version 13000,
     * this method will always return YDataStream.DATA_INVALID.
     *
     * @return {number} a floating-point number corresponding to the average value,
     *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
     *
     * On failure, throws an exception or returns YDataStream.DATA_INVALID.
     */
    get_averageValue() {
        var _this116 = this;

        return _asyncToGenerator(function* () {
            return _this116._avgVal;
        })();
    }

    /**
     * Returns the largest measure observed within this stream.
     * If the device uses a firmware older than version 13000,
     * this method will always return YDataStream.DATA_INVALID.
     *
     * @return {number} a floating-point number corresponding to the largest value,
     *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
     *
     * On failure, throws an exception or returns YDataStream.DATA_INVALID.
     */
    get_maxValue() {
        var _this117 = this;

        return _asyncToGenerator(function* () {
            return _this117._maxVal;
        })();
    }

    /**
     * Returns the approximate duration of this stream, in seconds.
     *
     * @return {number} the number of seconds covered by this stream.
     *
     * On failure, throws an exception or returns YDataStream.DURATION_INVALID.
     */
    get_duration() {
        var _this118 = this;

        return _asyncToGenerator(function* () {
            if (_this118._isClosed) {
                return _this118._duration;
            }
            return parseInt(+new Date() / 1000, 10) - _this118._utcStamp;
        })();
    }

    /**
     * Returns the whole data set contained in the stream, as a bidimensional
     * table of numbers.
     * The meaning of the values present in each column can be obtained
     * using the method get_columnNames().
     *
     * This method fetches the whole data stream from the device,
     * if not yet done.
     *
     * @return {number[][]} a list containing as many elements as there are rows in the
     *         data stream. Each row itself is a list of floating-point
     *         numbers.
     *
     * On failure, throws an exception or returns an empty array.
     */
    get_dataRows() {
        var _this119 = this;

        return _asyncToGenerator(function* () {
            if (_this119._values.length == 0 || !_this119._isClosed) {
                yield _this119.loadStream();
            }
            return _this119._values;
        })();
    }

    /**
     * Returns a single measure from the data stream, specified by its
     * row and column index.
     * The meaning of the values present in each column can be obtained
     * using the method get_columnNames().
     *
     * This method fetches the whole data stream from the device,
     * if not yet done.
     *
     * @param row {number} : row index
     * @param col {number} : column index
     *
     * @return {number} a floating-point number
     *
     * On failure, throws an exception or returns YDataStream.DATA_INVALID.
     */
    get_data(row, col) {
        var _this120 = this;

        return _asyncToGenerator(function* () {
            if (_this120._values.length == 0 || !_this120._isClosed) {
                yield _this120.loadStream();
            }
            if (row >= _this120._values.length) {
                return Y_DATA_INVALID;
            }
            if (col >= _this120._values[row].length) {
                return Y_DATA_INVALID;
            }
            return _this120._values[row][col];
        })();
    }

    //--- (end of generated code: YDataStream implementation)
}

//--- (generated code: YDataSet definitions)
//--- (end of generated code: YDataSet definitions)

//--- (generated code: YDataSet class start)
/**
 * YDataSet Class: Recorded data sequence
 *
 * YDataSet objects make it possible to retrieve a set of recorded measures
 * for a given sensor and a specified time interval. They can be used
 * to load data points with a progress report. When the YDataSet object is
 * instantiated by the get_recordedData()  function, no data is
 * yet loaded from the module. It is only when the loadMore()
 * method is called over and over than data will be effectively loaded
 * from the dataLogger.
 *
 * A preview of available measures is available using the function
 * get_preview() as soon as loadMore() has been called
 * once. Measures themselves are available using function get_measures()
 * when loaded by subsequent calls to loadMore().
 *
 * This class can only be used on devices that use a recent firmware,
 * as YDataSet objects are not supported by firmwares older than version 13000.
 */
//--- (end of generated code: YDataSet class start)
class YDataSet {
    constructor(obj_parent, str_functionId, str_unit, u32_startTime, u32_endTime) {
        //--- (generated code: YDataSet constructor)
        /** @member {YFunction} **/
        this._parent = null;
        /** @member {string} **/
        this._hardwareId = '';
        /** @member {string} **/
        this._functionId = '';
        /** @member {string} **/
        this._unit = '';
        /** @member {number} **/
        this._startTime = 0;
        /** @member {number} **/
        this._endTime = 0;
        /** @member {number} **/
        this._progress = 0;
        /** @member {number[]} **/
        this._calib = [];
        /** @member {YDataStream[]} **/
        this._streams = [];
        /** @member {YMeasure} **/
        this._summary = null;
        /** @member {YMeasure[]} **/
        this._preview = [];
        /** @member {YMeasure[]} **/
        this._measures = [];
        //--- (end of generated code: YDataSet constructor)
        // init _summary with dummy value
        this._summary = new YMeasure(0, 0, 0, 0, 0);
        if (typeof str_unit === 'undefined') {
            // 1st version of constructor, called from YDataLogger
            /** @member {YFunction} **/
            this._parent = obj_parent;
            /** @member {YAPIContext} **/
            this._yapi = obj_parent._yapi;
            this._startTime = 0;
            this._endTime = 0;
            // caller must call method async parse() just afterwards
        } else {
                // 2nd version of constructor, called from YFunction
                /** @member {YFunction} **/
                this._parent = obj_parent;
                /** @member {YAPIContext} **/
                this._yapi = obj_parent._yapi;
                this._functionId = str_functionId;
                this._unit = str_unit;
                this._startTime = u32_startTime;
                this._endTime = u32_endTime;
                this._progress = -1;
            }
    }

    imm_get_functionId() {
        return this._functionId;
    }

    //--- (generated code: YDataSet implementation)

    /* */imm_get_calibration() {
        return this._calib;
    }

    processMore(progress, data) {
        var _this121 = this;

        return _asyncToGenerator(function* () {
            /** @type {YDataStream} **/
            let stream;
            /** @type {number[][]} **/
            let dataRows = [];
            /** @type {string} **/
            let strdata;
            /** @type {number} **/
            let tim;
            /** @type {number} **/
            let itv;
            /** @type {number} **/
            let nCols;
            /** @type {number} **/
            let minCol;
            /** @type {number} **/
            let avgCol;
            /** @type {number} **/
            let maxCol;
            // may throw an exception
            if (progress != _this121._progress) {
                return _this121._progress;
            }
            if (_this121._progress < 0) {
                strdata = _this121._yapi.imm_bin2str(data);
                if (strdata == '{}') {
                    _this121._parent._throw(YAPI_VERSION_MISMATCH, 'device firmware is too old');
                    return YAPI_VERSION_MISMATCH;
                }
                return yield _this121._parse(strdata);
            }
            stream = _this121._streams[_this121._progress];
            stream.imm_parseStream(data);
            dataRows = yield stream.get_dataRows();
            _this121._progress = _this121._progress + 1;
            if (dataRows.length == 0) {
                return yield _this121.get_progress();
            }
            tim = yield stream.get_startTimeUTC();
            itv = yield stream.get_dataSamplesInterval();
            if (tim < itv) {
                tim = itv;
            }
            nCols = dataRows[0].length;
            minCol = 0;
            if (nCols > 2) {
                avgCol = 1;
            } else {
                avgCol = 0;
            }
            if (nCols > 2) {
                maxCol = 2;
            } else {
                maxCol = 0;
            }

            for (let ii in dataRows) {
                if (tim >= _this121._startTime && (_this121._endTime == 0 || tim <= _this121._endTime)) {
                    _this121._measures.push(new YMeasure(tim - itv, tim, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
                }
                tim = tim + itv;
            }

            return yield _this121.get_progress();
        })();
    }

    get_privateDataStreams() {
        var _this122 = this;

        return _asyncToGenerator(function* () {
            return _this122._streams;
        })();
    }

    /**
     * Returns the unique hardware identifier of the function who performed the measures,
     * in the form SERIAL.FUNCTIONID. The unique hardware identifier is composed of the
     * device serial number and of the hardware identifier of the function
     * (for example THRMCPL1-123456.temperature1)
     *
     * @return {string} a string that uniquely identifies the function (ex: THRMCPL1-123456.temperature1)
     *
     * On failure, throws an exception or returns  YDataSet.HARDWAREID_INVALID.
     */
    get_hardwareId() {
        var _this123 = this;

        return _asyncToGenerator(function* () {
            /** @type {YModule} **/
            let mo;
            if (!(_this123._hardwareId == '')) {
                return _this123._hardwareId;
            }
            mo = yield _this123._parent.get_module();
            _this123._hardwareId = (yield mo.get_serialNumber()) + '.' + (yield _this123.get_functionId());
            return _this123._hardwareId;
        })();
    }

    /**
     * Returns the hardware identifier of the function that performed the measure,
     * without reference to the module. For example temperature1.
     *
     * @return {string} a string that identifies the function (ex: temperature1)
     */
    get_functionId() {
        var _this124 = this;

        return _asyncToGenerator(function* () {
            return _this124._functionId;
        })();
    }

    /**
     * Returns the measuring unit for the measured value.
     *
     * @return {string} a string that represents a physical unit.
     *
     * On failure, throws an exception or returns  YDataSet.UNIT_INVALID.
     */
    get_unit() {
        var _this125 = this;

        return _asyncToGenerator(function* () {
            return _this125._unit;
        })();
    }

    /**
     * Returns the start time of the dataset, relative to the Jan 1, 1970.
     * When the YDataSet is created, the start time is the value passed
     * in parameter to the get_dataSet() function. After the
     * very first call to loadMore(), the start time is updated
     * to reflect the timestamp of the first measure actually found in the
     * dataLogger within the specified range.
     *
     * @return {number} an unsigned number corresponding to the number of seconds
     *         between the Jan 1, 1970 and the beginning of this data
     *         set (i.e. Unix time representation of the absolute time).
     */
    get_startTimeUTC() {
        var _this126 = this;

        return _asyncToGenerator(function* () {
            return _this126._startTime;
        })();
    }

    /**
     * Returns the end time of the dataset, relative to the Jan 1, 1970.
     * When the YDataSet is created, the end time is the value passed
     * in parameter to the get_dataSet() function. After the
     * very first call to loadMore(), the end time is updated
     * to reflect the timestamp of the last measure actually found in the
     * dataLogger within the specified range.
     *
     * @return {number} an unsigned number corresponding to the number of seconds
     *         between the Jan 1, 1970 and the end of this data
     *         set (i.e. Unix time representation of the absolute time).
     */
    get_endTimeUTC() {
        var _this127 = this;

        return _asyncToGenerator(function* () {
            return _this127._endTime;
        })();
    }

    /**
     * Returns the progress of the downloads of the measures from the data logger,
     * on a scale from 0 to 100. When the object is instantiated by get_dataSet,
     * the progress is zero. Each time loadMore() is invoked, the progress
     * is updated, to reach the value 100 only once all measures have been loaded.
     *
     * @return {number} an integer in the range 0 to 100 (percentage of completion).
     */
    get_progress() {
        var _this128 = this;

        return _asyncToGenerator(function* () {
            if (_this128._progress < 0) {
                return 0;
            }
            // index not yet loaded
            if (_this128._progress >= _this128._streams.length) {
                return 100;
            }
            return parseInt((1 + (1 + _this128._progress) * 98) / (1 + _this128._streams.length), 10);
        })();
    }

    /**
     * Loads the the next block of measures from the dataLogger, and updates
     * the progress indicator.
     *
     * @return {number} an integer in the range 0 to 100 (percentage of completion),
     *         or a negative error code in case of failure.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    loadMore() {
        var _this129 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let url;
            /** @type {YDataStream} **/
            let stream;
            if (_this129._progress < 0) {
                url = 'logger.json?id=' + _this129._functionId;
            } else {
                if (_this129._progress >= _this129._streams.length) {
                    return 100;
                } else {
                    stream = _this129._streams[_this129._progress];
                    url = stream.imm_get_url();
                }
            }
            return yield _this129.processMore(_this129._progress, (yield _this129._parent._download(url)));
        })();
    }

    /**
     * Returns an YMeasure object which summarizes the whole
     * DataSet. In includes the following information:
     * - the start of a time interval
     * - the end of a time interval
     * - the minimal value observed during the time interval
     * - the average value observed during the time interval
     * - the maximal value observed during the time interval
     *
     * This summary is available as soon as loadMore() has
     * been called for the first time.
     *
     * @return {YMeasure} an YMeasure object
     */
    get_summary() {
        var _this130 = this;

        return _asyncToGenerator(function* () {
            return _this130._summary;
        })();
    }

    /**
     * Returns a condensed version of the measures that can
     * retrieved in this YDataSet, as a list of YMeasure
     * objects. Each item includes:
     * - the start of a time interval
     * - the end of a time interval
     * - the minimal value observed during the time interval
     * - the average value observed during the time interval
     * - the maximal value observed during the time interval
     *
     * This preview is available as soon as loadMore() has
     * been called for the first time.
     *
     * @return {YMeasure[]} a table of records, where each record depicts the
     *         measured values during a time interval
     *
     * On failure, throws an exception or returns an empty array.
     */
    get_preview() {
        var _this131 = this;

        return _asyncToGenerator(function* () {
            return _this131._preview;
        })();
    }

    /**
     * Returns the detailed set of measures for the time interval corresponding
     * to a given condensed measures previously returned by get_preview().
     * The result is provided as a list of YMeasure objects.
     *
     * @param measure {YMeasure} : condensed measure from the list previously returned by
     *         get_preview().
     *
     * @return {YMeasure[]} a table of records, where each record depicts the
     *         measured values during a time interval
     *
     * On failure, throws an exception or returns an empty array.
     */
    get_measuresAt(measure) {
        var _this132 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let startUtc;
            /** @type {YDataStream} **/
            let stream;
            /** @type {number[][]} **/
            let dataRows = [];
            /** @type {YMeasure[]} **/
            let measures = [];
            /** @type {number} **/
            let tim;
            /** @type {number} **/
            let itv;
            /** @type {number} **/
            let nCols;
            /** @type {number} **/
            let minCol;
            /** @type {number} **/
            let avgCol;
            /** @type {number} **/
            let maxCol;
            // may throw an exception
            startUtc = Math.round(measure.get_startTimeUTC());
            stream = null;
            for (let ii in _this132._streams) {
                if ((yield _this132._streams[ii].get_startTimeUTC()) == startUtc) {
                    stream = _this132._streams[ii];
                }
                ;;
            }
            if (stream == null) {
                return measures;
            }
            dataRows = yield stream.get_dataRows();
            if (dataRows.length == 0) {
                return measures;
            }
            tim = yield stream.get_startTimeUTC();
            itv = yield stream.get_dataSamplesInterval();
            if (tim < itv) {
                tim = itv;
            }
            nCols = dataRows[0].length;
            minCol = 0;
            if (nCols > 2) {
                avgCol = 1;
            } else {
                avgCol = 0;
            }
            if (nCols > 2) {
                maxCol = 2;
            } else {
                maxCol = 0;
            }

            for (let ii in dataRows) {
                if (tim >= _this132._startTime && (_this132._endTime == 0 || tim <= _this132._endTime)) {
                    measures.push(new YMeasure(tim - itv, tim, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
                }
                tim = tim + itv;;
            }
            return measures;
        })();
    }

    /**
     * Returns all measured values currently available for this DataSet,
     * as a list of YMeasure objects. Each item includes:
     * - the start of the measure time interval
     * - the end of the measure time interval
     * - the minimal value observed during the time interval
     * - the average value observed during the time interval
     * - the maximal value observed during the time interval
     *
     * Before calling this method, you should call loadMore()
     * to load data from the device. You may have to call loadMore()
     * several time until all rows are loaded, but you can start
     * looking at available data rows before the load is complete.
     *
     * The oldest measures are always loaded first, and the most
     * recent measures will be loaded last. As a result, timestamps
     * are normally sorted in ascending order within the measure table,
     * unless there was an unexpected adjustment of the datalogger UTC
     * clock.
     *
     * @return {YMeasure[]} a table of records, where each record depicts the
     *         measured value for a given time interval
     *
     * On failure, throws an exception or returns an empty array.
     */
    get_measures() {
        var _this133 = this;

        return _asyncToGenerator(function* () {
            return _this133._measures;
        })();
    }

    //--- (end of generated code: YDataSet implementation)

    // YDataSet parser for stream list
    _parse(str_json) {
        var _this134 = this;

        return _asyncToGenerator(function* () {
            var summaryMinVal = Number.MAX_VALUE;
            var summaryMaxVal = -Number.MAX_VALUE;
            var summaryTotalTime = 0;
            var summaryTotalAvg = 0;
            var startTime = 0x7fffffff;
            var endTime = 0;
            var loadval;

            try {
                loadval = JSON.parse(str_json);
            } catch (err) {}
            if (!loadval) {
                // no data available
                _this134._progress = 0;
                return _this134;
            }

            _this134._functionId = loadval.id;
            _this134._unit = loadval.unit;
            if (loadval.calib) {
                _this134._calib = _this134._yapi.imm_decodeFloats(loadval.calib);
                _this134._calib[0] = parseInt(_this134._calib[0] / 1000);
            } else {
                _this134._calib = _this134._yapi.imm_decodeWords(loadval.cal);
            }
            _this134._summary = new YMeasure(0, 0, 0, 0, 0);
            _this134._streams = [];
            _this134._preview = [];
            _this134._measures = [];
            for (var i = 0; i < loadval.streams.length; i++) {
                var stream = _this134._parent.imm_findDataStream(_this134, loadval.streams[i]);
                var streamEndTime = (yield stream.get_startTimeUTC()) + (yield stream.get_duration());
                var streamStartTime = (yield stream.get_startTimeUTC()) - parseInt((yield stream.get_dataSamplesIntervalMs()) / 1000);
                if (_this134._startTime > 0 && streamEndTime <= _this134._startTime) {
                    // this stream is too early, drop it
                } else if (_this134._endTime > 0 && (yield stream.get_startTimeUTC()) > _this134._endTime) {
                        // this stream is too late, drop it
                    } else {
                            _this134._streams.push(stream);
                            if (startTime > streamStartTime) {
                                startTime = streamStartTime;
                            }
                            if (endTime < streamEndTime) {
                                endTime = streamEndTime;
                            }
                            if (stream.isClosed() && (yield stream.get_startTimeUTC()) >= _this134._startTime && (_this134._endTime == 0 || streamEndTime <= _this134._endTime)) {
                                if (summaryMinVal > (yield stream.get_minValue())) summaryMinVal = yield stream.get_minValue();
                                if (summaryMaxVal < (yield stream.get_maxValue())) summaryMaxVal = yield stream.get_maxValue();
                                summaryTotalAvg += (yield stream.get_averageValue()) * (yield stream.get_duration());
                                summaryTotalTime += yield stream.get_duration();

                                var rec = new YMeasure((yield stream.get_startTimeUTC()), streamEndTime, (yield stream.get_minValue()), (yield stream.get_averageValue()), (yield stream.get_maxValue()));
                                _this134._preview.push(rec);
                            }
                        }
            }
            if (_this134._streams.length > 0 && summaryTotalTime > 0) {
                // update time boundaries with actual data
                if (_this134._startTime < startTime) {
                    _this134._startTime = startTime;
                }
                if (_this134._endTime == 0 || _this134._endTime > endTime) {
                    _this134._endTime = endTime;
                }
                _this134._summary = new YMeasure(_this134._startTime, _this134._endTime, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
            }
            _this134._progress = 0;
            return _this134;
        })();
    }

}

//
// YAPI Context
//
// This class provides the high-level entry points to access Functions, stores
// an indexes instances of the Device object and of FunctionType collections.
//
class YGenericHub {
    constructor(obj_yapi, var_urlInfo) {
        /** @member {YAPIContext} **/
        this._yapi = obj_yapi;
        /** @member {number} **/
        this._lastErrorType = YAPI_SUCCESS;
        /** @member {string} **/
        this._lastErrorMsg = 'no error';
        /** @member {Object} **/
        this.urlInfo = var_urlInfo; // structure that describe the root URL of the hub
        /** @member {number} **/
        this.notiflen = 32000; // notification message length before forced disconnection
        /** @member {number} **/
        this.devListValidity = 500; // default validity of updateDeviceList
        /** @member {number} **/
        this.devListExpires = 0; // timestamp of next useful updateDeviceList
        this.serialByYdx = []; // serials by hub-specific devYdx
        /** @member {number} **/
        this.retryDelay = 15; // delay before reconnecting in case of error: initially 15ms
        /** @member {number} **/
        this.notifPos = -1; // current absolute position in hub notification stream
        /** @member {number} **/
        this.currPos = 0; // current position in data stream
        /** @member {Object} **/
        this.missing = {}; // used during UpdateDeviceList
        /** @member {boolean} **/
        this.disconnecting = false; // set to true when requested to disconnect
    }

    _throw(int_errType, str_errMsg, obj_retVal) {
        this._lastErrorType = int_errType;
        this._lastErrorMsg = str_errMsg;
        this._yapi._throw(int_errType, str_errMsg, obj_retVal);
    }

    imm_forceUpdate() {
        this.devListExpires = this._yapi.GetTickCount();
    }

    /** Make sure the hub can work properly
     *
     * @param errmsg {YErrorMsg}
     * @returns {number}
     */
    testHub(errmsg) {
        var _this135 = this;

        return _asyncToGenerator(function* () {
            // default test method is to issue a small request
            /** @type {YHTTPRequest} **/
            let yreq = yield _this135.request('GET', _this135.urlInfo.url, '/api/module.json', null);
            if (yreq.errorType != YAPI_SUCCESS) {
                errmsg.msg = yreq.errorMsg;
                return yreq.errorType;
            }

            return YAPI_SUCCESS;
        })();
    }

    hubUpdateDeviceList() {
        var _this136 = this;

        return _asyncToGenerator(function* () {
            // load hub API, process white pages and yellow pages
            /** @type {YDevice} **/
            let hubDev = _this136._yapi.imm_getDevice(_this136.urlInfo.url);
            /** @type {number} **/
            let retcode = yield hubDev.refresh();
            if (retcode != YAPI_SUCCESS) {
                return _this136._throw(retcode, hubDev._lastErrorMsg, retcode);
            }
            /** @type {YHTTPRequest} **/
            let yreq = yield hubDev.requestAPI(_this136._yapi.defaultCacheValidity);
            if (yreq.errorType != YAPI_SUCCESS) {
                return yreq;
            }
            let loadval = null;
            try {
                loadval = JSON.parse(_this136._yapi.imm_bin2str(yreq.bin_result));
            } catch (err) {}
            if (!loadval) {
                return _this136._throw(YAPI_IO_ERROR, 'Request failed, could not parse API result for ' + hubDev.imm_describe(), YAPI_IO_ERROR);
            }
            let whitePages = loadval['services']['whitePages'];
            let yellowPages = loadval['services']['yellowPages'];
            if (whitePages == undefined) {
                return _this136._throw(YAPI_INVALID_ARGUMENT, 'Device ' + hubDev.imm_describe() + ' is not a hub', YAPI_INVALID_ARGUMENT);
            }
            retcode = yield _this136._yapi.updateDeviceList_process(_this136, hubDev, whitePages, yellowPages);
            if (retcode != YAPI_SUCCESS) {
                return _this136._throw(_this136._yapi._lastErrorType, _this136._yapi._lastErrorMsg, _this136._yapi._lastErrorType);
            }

            // reset device list cache timeout for this hub
            _this136.devListExpires = _this136._yapi.GetTickCount() + _this136.devListValidity;
            return YAPI_SUCCESS;
        })();
    }

    /** Perform an HTTP query on the hub
     *
     * @param method {string}
     * @param baseUrl {string}
     * @param devUrl {string}
     * @param obj_body {Uint8Array}
     * @returns {YHTTPRequest}
     */
    request(method, baseUrl, devUrl, obj_body) {
        return _asyncToGenerator(function* () {
            // must be overriden by subclasses
            var res = new YHTTPRequest(null);
            res.errorType = YAPI_NOT_SUPPORTED;
            res.errorMsg = 'GenericHub subclass expected';
            return res;
        })();
    }

    disconnect() {
        var _this137 = this;

        return _asyncToGenerator(function* () {
            _this137.disconnecting = true;
        })();
    }
}

exports.YGenericHub = YGenericHub;
class YHttpHub extends YGenericHub {
    constructor(obj_yapi, var_urlInfo) {
        super(obj_yapi, var_urlInfo);
        /** @member {XMLHttpRequest} **/
        this.notbynRequest = null;
        /** @member {Promise} **/
        this.notbynOpenPromise = null;
    }

    /** Handle HTTP-based event-monitoring work on a registered hub
     *
     * @param errmsg {YErrorMsg}
     * @returns {number}
     */
    testHub(errmsg) {
        var _this138 = this;

        return _asyncToGenerator(function* () {
            if (_this138.disconnecting) {
                return YAPI_IO_ERROR;
            }
            let args = '?len=' + _this138.notiflen.toString();
            if (_this138.notifPos > 0) {
                args += '&abs=' + _this138.notifPos.toString();
            }
            _this138.notbynOpenPromise = new Promise((resolve, reject) => {
                this.notbynRequest = new XMLHttpRequest();
                this.notbynRequest.open('GET', this.urlInfo.url + 'not.byn' + args, true, '', '');
                this.notbynRequest.overrideMimeType('text/plain; charset=x-user-defined');
                this.notbynRequest.onreadystatechange = () => {
                    if (this.disconnecting) {
                        return;
                    }
                    if (this.notbynRequest.readyState >= 3) {
                        resolve(YAPI_SUCCESS);
                        if (this.notbynRequest.readyState == 4 && parseInt(this.notbynRequest.status) != 200 && parseInt(this.notbynRequest.status) != 304) {
                            // connection error
                            if (this.retryDelay < 15000) this.retryDelay *= 2;
                            this.devListValidity = 500;
                            this.devListExpires = 0;
                            setTimeout(() => {
                                this.testHub(new YErrorMsg());
                            }, this.retryDelay);
                        } else {
                            // receiving data properly
                            if (this.notbynRequest.readyState == 3) {
                                // when using reconnection mode, ignore state 3
                                if (this.notiflen == 1) return;
                            }
                            let newlen = this.notbynRequest.responseText.length;
                            if (newlen > this.currPos) {
                                this._yapi.parseEvents(this, this.notbynRequest.responseText.substr(this.currPos, newlen - this.currPos));
                            }
                            // trigger immediately a new connection if closed in success
                            if (this.notbynRequest.readyState == 4 && parseInt(this.notbynRequest.status) != 0) {
                                this.currPos = 0;
                                this.testHub(new YErrorMsg());
                            }
                        }
                    }
                };
                this.notbynRequest.send('');
            });
            return yield _this138.notbynOpenPromise;
        })();
    }

    /** Perform an HTTP query on the hub
     *
     * @param method {string}
     * @param baseUrl {string}
     * @param devUrl {string}
     * @param obj_body {Uint8Array}
     * @returns {YHTTPRequest}
     */
    request(method, baseUrl, devUrl, obj_body) {
        return _asyncToGenerator(function* () {
            let httpPromise = new Promise((resolve, reject) => {
                let httpRequest = new XMLHttpRequest();
                httpRequest.open(method, baseUrl + devUrl, true, '', '');
                httpRequest.onreadystatechange = () => {
                    if (httpRequest.readyState == 4) {
                        let yreq = new YHTTPRequest(null);
                        if (httpRequest.status != 200 && httpRequest.status != 304) {
                            yreq.errorType = YAPI_NOT_SUPPORTED;
                            yreq.errorMsg = 'HTTP Error ' + httpRequest.status;
                        } else {
                            yreq.bin_result = this._yapi.imm_str2bin(httpRequest.responseText);
                        }
                        resolve(yreq);
                    }
                };
                // FIXME: convert body to FormData if needed
                httpRequest.send(obj_body || '');
            });
            return httpPromise;
        })();
    }

    disconnect() {
        var _this139 = this;

        return _asyncToGenerator(function* () {
            yield super.disconnect();
            _this139.notbynRequest.abort();
        })();
    }
}

exports.YHttpHub = YHttpHub;
class YHttpNodeHub extends YGenericHub {
    constructor(obj_yapi, var_urlInfo) {
        super(obj_yapi, var_urlInfo);
        this.http = this._yapi._nodeRequire('http');
        /** @member {ClientRequest} **/
        this.notbynRequest = null;
        /** @member {Promise} **/
        this.notbynOpenPromise = null;
    }

    /** Handle HTTP-based event-monitoring work on a registered hub
     *
     * @param errmsg {YErrorMsg}
     * @returns {number}
     */
    testHub(errmsg) {
        var _this140 = this;

        return _asyncToGenerator(function* () {
            if (_this140.disconnecting) {
                return YAPI_IO_ERROR;
            }
            let args = '';
            if (_this140.notifPos > 0) {
                args = '?abs=' + _this140.notifPos.toString();
            }
            let options = {
                method: 'GET',
                hostname: _this140.urlInfo.host,
                port: _this140.urlInfo.port,
                path: '/not.byn' + args
            };
            _this140.notbynOpenPromise = new Promise((resolve, reject) => {
                this.notbynRequest = this.http.request(options, res => {
                    if (this.disconnecting) {
                        return;
                    }
                    if (res.statusCode != 200 && res.statusCode != 304) {
                        // connection error
                        if (this.retryDelay < 15000) this.retryDelay *= 2;
                        this.devListValidity = 500;
                        this.devListExpires = 0;
                        setTimeout(() => {
                            this.testHub(new YErrorMsg());
                        }, this.retryDelay);
                    } else {
                        resolve(YAPI_SUCCESS);
                        res.on('data', chunk => {
                            // receiving data properly
                            this._yapi.parseEvents(this, this._yapi.imm_bin2str(chunk));
                        });
                        res.on('end', () => {
                            // trigger immediately a new connection if closed in success
                            this.currPos = 0;
                            this.testHub(new YErrorMsg());
                        });
                    }
                });
                this.notbynRequest.on('error', () => {
                    // connection aborted, need to reconnect
                    this.devListValidity = 500;
                    this.devListExpires = 0;
                    setTimeout(() => {
                        this.testHub(new YErrorMsg());
                    }, 50);
                });
                this.notbynRequest.end();
            });
            return yield _this140.notbynOpenPromise;
        })();
    }

    /** Perform an HTTP query on the hub
     *
     * @param str_method {string}
     * @param baseUrl {string}
     * @param devUrl {string}
     * @param obj_body {Uint8Array}
     * @returns {YHTTPRequest}
     */
    request(str_method, baseUrl, devUrl, obj_body) {
        var _this141 = this;

        return _asyncToGenerator(function* () {
            let options = {
                method: str_method,
                hostname: _this141.urlInfo.host,
                port: _this141.urlInfo.port,
                path: devUrl
            };
            let httpPromise = new Promise((resolve, reject) => {
                let response = new Buffer(0);
                let httpRequest = this.http.request(options, res => {
                    if (res.statusCode != 200 && res.statusCode != 304) {
                        // connection error
                        let yreq = new YHTTPRequest(null);
                        yreq.errorType = YAPI_NOT_SUPPORTED;
                        yreq.errorMsg = 'HTTP Error ' + res.statusCode.toString();
                        resolve(yreq);
                    } else {
                        res.on('data', chunk => {
                            // receiving data properly
                            response = Buffer.concat([response, chunk]);
                        });
                        res.on('end', () => {
                            resolve(new YHTTPRequest(new Uint8Array(response)));
                        });
                    }
                });
                httpRequest.on('error', err => {
                    let yreq = new YHTTPRequest(null);
                    yreq.errorType = YAPI_IO_ERROR;
                    yreq.errorMsg = err.errorMsg;
                    resolve(yreq);
                });
                httpRequest.end();
            });
            return httpPromise;
        })();
    }

    disconnect() {
        var _this142 = this;

        return _asyncToGenerator(function* () {
            yield super.disconnect();
            _this142.notbynRequest.abort();
        })();
    }
}

exports.YHttpNodeHub = YHttpNodeHub;
class YHttpCallbackHub extends YGenericHub {
    constructor(obj_yapi, var_urlInfo, incomingMessage, serverResponse) {
        super(obj_yapi, var_urlInfo);
        this.crypto = this._yapi._nodeRequire('crypto');
        /** @member {IncomingMessage} **/
        this._incomingMessage = incomingMessage;
        /** @member {ServerResponse} **/
        this._serverResponse = serverResponse;
        /** @member {Buffer} **/
        this._callbackData = new Buffer(0);
        /** @member {Object} **/
        this._callbackCache = null;
        /** @member {Promise} **/
        this.httpCallbackPromise = new Promise((resolve, reject) => {
            this._incomingMessage.on('data', chunk => {
                this._callbackData = Buffer.concat([this._callbackData, chunk]);
            });
            this._incomingMessage.on('end', () => {
                this._callbackData = new Uint8Array(this._callbackData);
                this._callbackCache = JSON.parse(this._yapi.imm_bin2str(this._callbackData));
                resolve(true);
            });
        });
    }

    /** Test input data for a HTTP callback hub
     *
     * @param errmsg {YErrorMsg}
     * @returns {number}
     */
    testHub(errmsg) {
        var _this143 = this;

        return _asyncToGenerator(function* () {
            yield _this143.httpCallbackPromise;
            if (_this143._incomingMessage.method != 'POST') {
                errmsg.msg = 'HTTP POST expected';
                return YAPI_INVALID_ARGUMENT;
            }
            if (_this143._callbackData.length == 0) {
                errmsg.msg = 'Empty POST body';
                return YAPI_NO_MORE_DATA;
            }
            if (_this143.urlInfo.pass != '') {
                // callback data signed, verify signature
                if (!_this143._callbackCache.sign) {
                    errmsg.msg = 'missing signature from incoming YoctoHub (callback password required)';
                    _this143._callbackCache = [];
                    return YAPI_NO_MORE_DATA;
                }
                let sign = _this143._callbackCache['sign'];
                let pass = _this143.urlInfo.pass;
                let salt;
                if (pass.length == 32) {
                    salt = _this143._yapi.imm_str2bin(pass.toLowerCase());
                } else {
                    salt = _this143._yapi.imm_str2bin(_this143.crypto.createHash('md5').update(pass).digest('hex'));
                }
                let patched = _this143._yapi.imm_bin2str(_this143._callbackData).replace(sign, salt);
                let check = _this143.crypto.createHash('md5').update(patched).digest('hex');
                if (check.toLowerCase() != sign.toLowerCase()) {
                    //console.log('Computed signature: '+ check);
                    //console.log('Received signature: '+ sign);
                    errmsg.msg = 'invalid signature from incoming YoctoHub (invalid callback password)';
                    _this143._callbackCache = [];
                    return YAPI_UNAUTHORIZED;
                }
            }
            return YAPI_SUCCESS;
        })();
    }

    /** Perform an HTTP query on the hub
     *
     * @param str_method {string}
     * @param baseUrl {string}
     * @param devUrl {string}
     * @param obj_body {Uint8Array}
     * @returns {YHTTPRequest}
     */
    request(str_method, baseUrl, devUrl, obj_body) {
        var _this144 = this;

        return _asyncToGenerator(function* () {
            let yreq = new YHTTPRequest(null);
            if (str_method == 'POST' && obj_body.length > 2) {
                var boundary = '???';
                for (var endb = 0; endb < obj_body.length; endb++) {
                    if (obj_body[endb] == 13) break;
                }

                if (endb > 2 && endb < 20 && obj_body[0] == 45 && obj_body[1] == 45) {
                    boundary = _this144._yapi.imm_bin2str(obj_body.subarray(2, endb));
                }
                _this144._serverResponse.write('\n@YoctoAPI:' + str_method + ' ' + devUrl + ' ' + obj_body.length + ':' + boundary + '\n');
                _this144._serverResponse.write(obj_body);
            } else if (str_method == 'GET') {
                var jzon = devUrl.indexOf('?fw=');
                if (jzon != -1 && devUrl.indexOf('&', jzon) == -1) {
                    devUrl = devUrl.slice(0, jzon);
                }
                if (devUrl.indexOf('?') == -1 || devUrl.indexOf('/logs.txt') != -1 || devUrl.indexOf('/logger.json') != -1 || devUrl.indexOf('/ping.txt') != -1 || devUrl.indexOf('/files.json?a=dir') != -1) {
                    // read request, load from cache
                    var subfun = /\/api\/([a-z][A-Za-z0-9]*)[.]json$/.exec(devUrl);
                    if (subfun) {
                        devUrl = devUrl.slice(0, subfun.index) + '/api.json';
                    }
                    if (!_this144._callbackCache[devUrl]) {
                        _this144._serverResponse.write('\n!YoctoAPI:' + devUrl + ' is not preloaded, adding to list');
                        _this144._serverResponse.write('\n@YoctoAPI:+' + devUrl + '\n');
                        yreq.errorType = YAPI_NO_MORE_DATA;
                        yreq.errorMsg = 'URL ' + devUrl + ' not preloaded, adding to list';
                    } else {
                        var jsonres = _this144._callbackCache[devUrl];
                        if (subfun) {
                            jsonres = jsonres[subfun[1]];
                        }
                        yreq.bin_result = _this144._yapi.imm_str2bin(JSON.stringify(jsonres));
                    }
                } else {
                    // change request, print to output stream
                    _this144._serverResponse.write('\n@YoctoAPI:' + str_method + ' ' + devUrl + '\n');
                    yreq.bin_result = new Uint8Array(0);
                }
            } else {
                yreq.errorType = YAPI_NOT_SUPPORTED;
                yreq.errorMsg = 'Unsupported HTTP method';
            }
            return yreq;
        })();
    }
}

exports.YHttpCallbackHub = YHttpCallbackHub;
class YWebSocketHub extends YGenericHub {
    constructor(obj_yapi, var_urlInfo) {
        super(obj_yapi, var_urlInfo);
        /** @member {WebSocket} **/
        this.websocket = null;
        /** @member {Promise} **/
        this.websocketOpenPromise = null;
        /** @member {YHTTPRequest[]} **/
        this.tcpChan = [];
    }

    /** Open an outgoing websocket
     *
     * @param str_url {string}
     **/
    imm_webSocketOpen(str_url) {
        this.websocket = new WebSocket(str_url);
        this.websocket.binaryType = 'arraybuffer';
    }

    /** Handle websocket-based event-monitoring work on a registered hub
     *
     * @param errmsg {YErrorMsg}
     * @returns {number}
     */
    testHub(errmsg) {
        var _this145 = this;

        return _asyncToGenerator(function* () {
            if (_this145.disconnecting) {
                return YAPI_IO_ERROR;
            }
            // Open WebSocket connection
            _this145.imm_webSocketOpen(_this145.urlInfo.url + 'not.byn');
            _this145.websocketOpenPromise = new Promise((resolve, reject) => {
                this.websocket.onmessage = evt => {
                    resolve(YAPI_SUCCESS);
                    this._webSocketMsg(new Uint8Array(evt.data));
                };
            });
            _this145.websocket.onclose = evt => {
                this.websocket = null;
                if (this.disconnecting) {
                    return;
                }
                // connection error
                if (this.retryDelay < 15000) this.retryDelay *= 2;
                this.devListValidity = 500;
                this.devListExpires = 0;
                setTimeout(() => {
                    this.testHub(new YErrorMsg());
                }, this.retryDelay);
            };
            _this145.websocket.onerror = evt => {
                console.log('WebSocket error: ', evt);
                this.websocket = null;
                if (this.disconnecting) {
                    return;
                }
                // connection error
                if (this.retryDelay < 15000) this.retryDelay *= 2;
                this.devListValidity = 500;
                this.devListExpires = 0;
                setTimeout(() => {
                    this.testHub(new YErrorMsg());
                }, this.retryDelay);
            };
            return yield _this145.websocketOpenPromise;
        })();
    }

    /** Handle an incoming packet
     *
     * @param arr_bytes {Uint8Array}
     **/
    _webSocketMsg(arr_bytes) {
        var _this146 = this;

        return _asyncToGenerator(function* () {
            var text = '';
            if (arr_bytes[0] == 8 * 8) {
                // YSTREAM_TCP_NOTIF
                for (let i = 1; i < arr_bytes.length; i++) {
                    text += String.fromCharCode(arr_bytes[i]);
                }
                yield _this146._yapi.parseEvents(_this146, text);
                return;
            }
            // Other types of messages
            var ws = _this146.websocket;
            var ystream = arr_bytes[0] >> 3;
            var tcpchan = arr_bytes[0] & 7;
            if (ystream == 1 || ystream == 2) {
                // YSTREAM_TCP or YSTREAM_TCP_CLOSE
                if (!_this146.tcpChan[tcpchan]) {
                    console.log('WS: Drop frame for closed tcpChan ' + tcpchan);
                    return;
                }
                let oldArr = _this146.tcpChan[tcpchan].bin_result;
                let newArr = new Uint8Array(oldArr.length + arr_bytes.length - 1);
                newArr.set(oldArr, 0);
                newArr.set(arr_bytes.subarray(1), oldArr.length);
                _this146.tcpChan[tcpchan].bin_result = newArr;
                if (ystream == 2) {
                    // YSTREAM_TCP_CLOSE
                    // send YSTREAM_TCP_CLOSE
                    let frame = new Uint8Array(1);
                    frame[0] = 8 * 2 + tcpchan;
                    _this146.websocket.send(frame);
                    // free tcp channel
                    let yreq = _this146.tcpChan[tcpchan];
                    _this146.tcpChan[tcpchan] = null;
                    // process incoming reply
                    let pos = yreq.bin_result.indexOf(13);
                    if (pos < 0) {
                        yreq.errorType = YAPI_IO_ERROR;
                        yreq.errorMsg = 'Bad response header';
                    } else {
                        let header = _this146._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
                        let words = header.split(' ');
                        if (words[0] == 'OK') {
                            yreq.errorType = YAPI_SUCCESS;
                            yreq.bin_result = yreq.bin_result.subarray(4);
                        } else if (words[0] == '0K') {
                            yreq.errorType = YAPI_IO_ERROR;
                            yreq.errorMsg = 'Unexpected persistent connection';
                        } else {
                            yreq.errorType = YAPI_IO_ERROR;
                            yreq.errorMsg = 'HTTP error ' + header.slice(words[0].length + 1);
                        }
                    }
                    yreq.acceptor(yreq);
                }
                return;
            }
            console.log('WS: Unsupported message', arr_bytes);
        })();
    }

    /** Send an outgoing packet
     *
     * @param arr_bytes {Uint8Array}
     **/
    imm_webSocketSend(arr_bytes) {
        this.websocket.send(arr_bytes);
    }

    /** Perform an HTTP query on the hub
     *
     * @param method {string}
     * @param baseUrl {string}
     * @param devUrl {string}
     * @param obj_body {Uint8Array}
     * @returns {YHTTPRequest}
     */
    request(method, baseUrl, devUrl, obj_body) {
        return _asyncToGenerator(function* () {
            let httpPromise = new Promise((resolve, reject) => {
                var subReq = method + ' ' + devUrl + ' \r\n\r\n';
                var ws = this.websocket;
                var tcpchan = 0;

                while (this.tcpChan[tcpchan]) {
                    tcpchan++;
                }
                if (tcpchan > 2) {
                    // For now, limit to 2 channels (up to 8 could be possible)
                    console.log('WebSocket: TOO MANY CONCURRENT TCP CHANNELS');
                    return;
                }
                this.tcpChan[tcpchan] = new YHTTPRequest(new Uint8Array(0));
                this.tcpChan[tcpchan].acceptor = resolve;

                var pos = 0;
                while (pos < subReq.length) {
                    var framelen = 1 + subReq.length - pos;
                    if (framelen > 125) framelen = 125;
                    var datalen = framelen - 1;
                    var i,
                        frame = new Uint8Array(framelen);

                    // use YSTREAM_TCP
                    frame[0] = 8 + tcpchan;
                    for (i = 0; i < datalen; i++) {
                        frame[1 + i] = subReq.charCodeAt(pos + i);
                    }
                    pos += framelen - 1;
                    this.imm_webSocketSend(frame);
                    // FIXME: send body as well !
                }
            });
            //noinspection JSValidateTypes
            return httpPromise;
        })();
    }

    disconnect() {
        var _this147 = this;

        return _asyncToGenerator(function* () {
            yield super.disconnect();
            _this147.websocket.close();
        })();
    }
}

exports.YWebSocketHub = YWebSocketHub;
class YWebSocketNodeHub extends YWebSocketHub {
    constructor(obj_yapi, var_urlInfo) {
        super(obj_yapi, var_urlInfo);
        this.wsWebSocket = this._yapi._nodeRequire('ws');
    }

    /** Open an outgoing websocket
     *
     * @param str_url {string}
     **/
    imm_webSocketOpen(str_url) {
        this.websocket = new this.wsWebSocket(this.urlInfo.url + 'not.byn');
    }

    /** Send an outgoing packet
     *
     * @param arr_bytes {Uint8Array}
     **/
    imm_webSocketSend(arr_bytes) {
        this.websocket.send(arr_bytes, { binary: true, mask: false });
    }
}

exports.YWebSocketNodeHub = YWebSocketNodeHub;
class YWebSocketCallbackHub extends YWebSocketNodeHub {
    constructor(obj_yapi, var_urlInfo, ws) {
        super(obj_yapi, var_urlInfo);
        this.websocket = ws;
    }

    /** Open an outgoing websocket
     *
     * @param str_url {string}
     **/
    imm_webSocketOpen(str_url) {
        // nothing to do, the ws is already open !
    }
}

exports.YWebSocketCallbackHub = YWebSocketCallbackHub; //
// YAPI Context
//
// This class provides the high-level entry points to access Functions, stores
// an indexes instances of the Device object and of FunctionType collections.
//

class YAPIContext {
    constructor() {
        //--- (generated code: YFunction return codes)
        this.SUCCESS = 0; // everything worked all right
        this.NOT_INITIALIZED = -1; // call yInitAPI() first !
        this.INVALID_ARGUMENT = -2; // one of the arguments passed to the function is invalid
        this.NOT_SUPPORTED = -3; // the operation attempted is (currently) not supported
        this.DEVICE_NOT_FOUND = -4; // the requested device is not reachable
        this.VERSION_MISMATCH = -5; // the device firmware is incompatible with this API version
        this.DEVICE_BUSY = -6; // the device is busy with another task and cannot answer
        this.TIMEOUT = -7; // the device took too long to provide an answer
        this.IO_ERROR = -8; // there was an I/O problem while talking to the device
        this.NO_MORE_DATA = -9; // there is no more data to read from
        this.EXHAUSTED = -10; // you have run out of a limited resource, check the documentation
        this.DOUBLE_ACCES = -11; // you have two process that try to access to the same device
        this.UNAUTHORIZED = -12; // unauthorized access to password-protected device
        this.RTC_NOT_READY = -13; // real-time clock has not been initialized (or time was lost)
        this.FILE_NOT_FOUND = -14; // the file is not found
        //--- (end of generated code: YFunction return codes)
        this.INVALID_INT = YAPI_INVALID_INT;
        this.INVALID_UINT = YAPI_INVALID_UINT;
        this.INVALID_LONG = YAPI_INVALID_LONG;
        this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
        this.INVALID_STRING = YAPI_INVALID_STRING;

        // yInitAPI constants (not really useful in JavaScript)
        this.DETECT_NONE = 0;
        this.DETECT_USB = 1;
        this.DETECT_NET = 2;
        this.DETECT_ALL = this.DETECT_USB | this.DETECT_NET;

        // Default string encoding used in the library
        this.defaultEncoding = 'binary';

        // Default cache validity (in [ms]) before reloading data from device. This saves a lots of trafic.
        // Note that a value under 2 ms makes little sense since a USB bus itself has a 2ms roundtrip period
        /** @member {number} **/
        this.defaultCacheValidity = 5;
        // Switch to turn off exceptions and use return codes instead, for source-code compatibility
        // with languages without exception support like C
        /** @member {boolean} **/
        this.exceptionsDisabled = false;

        this.imm_init();

        for (var i = 1; i <= 20; i++) {
            this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
        }
        this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    }

    imm_init() {
        /** @member {YGenericHub[]} **/
        this._hubs = []; // array of root urls
        /** @member {Object} **/
        this._devs = {}; // hash table of known devices, by serial number
        /** @member {Object} **/
        this._snByUrl = {}; // serial number for each known device, by URL
        /** @member {Object} **/
        this._snByName = {}; // serial number for each known device, by name
        /** @member {Object} **/
        this._fnByType = {}; // functions by type
        this._fnByType.Module = new YFunctionType(this, 'Module');
        /** @member {number} **/
        this._lastErrorType = YAPI_SUCCESS;
        /** @member {string} **/
        this._lastErrorMsg = 'no error';
        /** @member {boolean} **/
        this._firstArrival = true;
        /** @member {boolean} **/
        this._updateDevListStarted = false;
        /** @member {Object[]} **/
        this._pendingCallbacks = [];
        /** @member {Function} **/
        this._arrivalCallback = null;
        /** @member {Function} **/
        this._namechgCallback = null;
        /** @member {Function} **/
        this._removalCallback = null;
        /** @member {Object[]} **/
        this._data_events = [];
        /** @member {number} **/
        this._forwardValues = 0;
        /** @member {Object} **/
        this._calibHandlers = {};
        /** @member {Object[]} **/
        this._ValueCallbackList = [];
        /** @member {Object[]} **/
        this._TimedReportCallbackList = [];
        /** @member {boolean} **/
        this._isNodeJS = false;
        /** @member {function} **/
        this._nodeRequire = null;
        if (typeof System != 'undefined') {
            // SystemJS detected
            if (System._nodeRequire) {
                this._isNodeJS = true;
                this._nodeRequire = System._nodeRequire;
            }
        } else {
            // Node.js without SystemJS, or running in browserify SFX bundle
            if (typeof require != 'undefined') {
                this._isNodeJS = true;
                this._nodeRequire = require;
            }
        }
    }

    _throw(int_errType, str_errMsg, obj_retVal) {
        this._lastErrorType = int_errType;
        this._lastErrorMsg = str_errMsg;

        if (!this.exceptionsDisabled) {
            // create a well-formed exception object including stack
            try {
                // note: The function Trigger_Yocto_Error below does intentionally not exist !
                //       Its only purpose is to create a valid exception stack frame and
                //       trigger the javascript debugger in the best possible way
                //noinspection JSUnresolvedFunction
                Trigger_Yocto_Error(int_errType, str_errMsg);
            } catch (e) {
                var key,
                    exc = new Error(str_errMsg);
                for (key in e) {
                    if (key != 'name' && key != 'number' && key != 'message') exc[key] = e[key];
                }
                exc['name'] = 'YoctoError';
                exc['message'] = str_errMsg;
                exc['description'] = str_errMsg;
                exc['number'] = int_errType;
                throw exc;
            }
        }
        return obj_retVal;
    }

    // Add a hub object to the list of known hub
    _addHub(newhub) {
        var _this148 = this;

        return _asyncToGenerator(function* () {
            // Add hub to known list
            _this148._hubs.push(newhub);

            // If hub is not yet known, create a device object (synchronous call)
            var serial = _this148._snByUrl[newhub.urlInfo.url];
            if (!serial) {
                let dev = new YDevice(_this148, newhub.urlInfo.url, null, null);
                yield dev.refresh();
            }
        })();
    }

    // Search for an existing a hub object for a given URL
    imm_getHub(str_rootUrl) {
        var i, hubUrl;

        for (i = 0; i < this._hubs.length; i++) {
            hubUrl = this._hubs[i].urlInfo.url;
            if (str_rootUrl.slice(0, hubUrl.length) == hubUrl) {
                return this._hubs[i];
            }
        }
        return null;
    }

    // Trigger an update of connected devices by querying all hubs
    _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
        var _this149 = this;

        return _asyncToGenerator(function* () {
            if (_this149._firstArrival && bool_invokecallbacks && _this149._arrivalCallback) {
                bool_forceupdate = true;
            }
            if (bool_forceupdate) {
                for (let i = 0; i < _this149._hubs.length; i++) {
                    _this149._hubs[i].imm_forceUpdate();
                }
            }
            if (_this149._updateDevListStarted && _this149.GetTickCount() - _this149._updateDevListStarted < 30 * 1000) {
                return {
                    errorType: YAPI_SUCCESS,
                    errorMsg: 'no error',
                    result: YAPI_SUCCESS
                };
            }

            try {
                // mark updateDeviceList in progress to avoid concurrent asynchronous runs
                _this149._updateDevListStarted = _this149.GetTickCount();

                // collect list of hubs which should be checked
                let hubs = [];
                for (let i = 0; i < _this149._hubs.length; i++) {
                    let hub = _this149._hubs[i];
                    let rootUrl = hub.urlInfo.url;
                    let hubDev = _this149.imm_getDevice(rootUrl);
                    if (!hubDev) continue;
                    if (hub.devListExpires <= _this149.GetTickCount()) {
                        hub.missing = [];
                        hubs.push(hub);
                    }
                }

                // assume all device are unplugged, unless proved wrong
                for (let serial in _this149._devs) {
                    let rooturl = _this149._devs[serial].imm_getRootUrl();
                    for (let i = 0; i < hubs.length; i++) {
                        let huburl = hubs[i].urlInfo.url;
                        if (rooturl.substr(0, huburl.length) == huburl) {
                            hubs[i].missing[serial] = true;
                        }
                    }
                }

                // Rescan all hubs and update list of online devices
                yield Promise.all(Array.from(hubs, hub => hub.hubUpdateDeviceList()));

                // after processing all hubs, invoke pending callbacks if required
                if (bool_invokecallbacks) {
                    let nbEvents = _this149._pendingCallbacks.length;
                    for (let i = 0; i < nbEvents; i++) {
                        let evt = _this149._pendingCallbacks[i];
                        let serial = evt.slice(1);
                        switch (evt.charAt(0)) {
                            case '+':
                                if (_this149._arrivalCallback != undefined) {
                                    yield _this149._arrivalCallback(yFindModule(serial + '.module'));
                                }
                                break;
                            case '/':
                                if (_this149._namechgCallback != undefined) {
                                    yield _this149._namechgCallback(yFindModule(serial + '.module'));
                                }
                                break;
                            case '-':
                                if (_this149._removalCallback != undefined) {
                                    yield _this149._removalCallback(yFindModule(serial + '.module'));
                                }
                                _this149.imm_forgetDevice(_this149._devs[serial]);
                                break;
                        }
                    }
                    _this149._pendingCallbacks = _this149._pendingCallbacks.slice(nbEvents);
                    if (_this149._arrivalCallback != undefined && _this149._firstArrival) {
                        _this149._firstArrival = false;
                    }
                }
            } finally {
                _this149._updateDevListStarted = false;
            }

            return {
                errorType: YAPI_SUCCESS,
                errorMsg: 'no error',
                result: YAPI_SUCCESS
            };
        })();
    }

    // process a hub white-pages/yellow-pages records to update the device data
    updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
        var _this150 = this;

        return _asyncToGenerator(function* () {
            // Reindex all functions from yellow pages
            let refresh = {};
            let serial = null;
            for (let classname in yellowPages) {
                let obj_yprecs = yellowPages[classname];
                let ftype = _this150._fnByType[classname];
                if (ftype == undefined) {
                    ftype = new YFunctionType(_this150, classname);
                    _this150._fnByType[classname] = ftype;
                }
                for (var key in obj_yprecs) {
                    var yprec = obj_yprecs[key];
                    var hwid = yprec['hardwareId'];
                    var basetype = yprec['baseType'];
                    if (ftype.imm_reindexFunction(hwid, yprec['logicalName'], yprec['advertisedValue'], basetype)) {
                        // logical name discrepency detected, force a refresh from device
                        serial = hwid.substr(0, hwid.indexOf('.'));
                        refresh[serial] = true;
                    }
                }
            }
            // Reindex all devices from white pages
            for (let devkey in whitePages) {
                var devinfo = whitePages[devkey];
                serial = devinfo['serialNumber'];
                var devydx = devinfo['index'];
                var rooturl = devinfo.networkUrl.slice(0, -3);
                if (rooturl.charAt(0) == '/') rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
                var currdev = _this150._devs[serial];
                if (currdev && _this150._arrivalCallback != undefined && _this150._firstArrival) {
                    _this150._pendingCallbacks.push('+' + serial);
                }
                hub.serialByYdx[devydx] = serial;
                if (!currdev) {
                    // Add new device
                    //noinspection ObjectAllocationIgnored
                    new YDevice(_this150, rooturl, devinfo, yellowPages);
                    if (_this150._arrivalCallback != undefined) {
                        _this150._pendingCallbacks.push('+' + serial);
                    }
                } else if (currdev.imm_getLogicalName() != devinfo['logicalName']) {
                    // Reindex device from its own data
                    yield currdev.refresh();
                    if (_this150._namechgCallback != undefined) {
                        _this150._pendingCallbacks.push('/' + serial);
                    }
                } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo['beacon']) {
                    // Reindex device from its own data in case of discrepency
                    yield currdev.refresh();
                }
                hub.missing[serial] = false;
            }

            // Keep track of all unplugged devices on this hub
            for (serial in hub.missing) {
                if (hub.missing[serial]) {
                    if (_this150._removalCallback != undefined) {
                        _this150._pendingCallbacks.push('-' + serial);
                    } else {
                        _this150.imm_forgetDevice(_this150._devs[serial]);
                    }
                }
            }

            return YAPI_SUCCESS;
        })();
    }

    /** process event data produced by a hub
     *
     * @param hub {Object}
     * @param str_lines {string}
     */
    parseEvents(hub, str_lines) {
        var _this151 = this;

        return _asyncToGenerator(function* () {
            hub.devListValidity = 10000; // 10s validity when notification are working properly

            var rows = str_lines.split('\n');
            var nrows = rows.length;
            var value;
            // in continuous mode, last line is either empty or a partial event
            nrows--;
            for (var idx = 0; idx < nrows; idx++) {
                var ev = rows[idx];
                if (ev.length == 0) continue;
                var firstCode = ev.charAt(0);
                if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_FLUSHV2YDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
                    hub.retryDelay = 15;
                    if (hub.notifPos >= 0) hub.notifPos += ev.length + 1;
                    var devydx = ev.charCodeAt(1) - 65; // from 'A'
                    var funydx = ev.charCodeAt(2) - 48; // from '0'
                    if (funydx >= 64) {
                        // high bit of devydx is on second character
                        funydx -= 64;
                        devydx += 128;
                    }
                    var serial = hub.serialByYdx[devydx];
                    if (serial && _this151._devs[serial]) {
                        var funcid = funydx == 0xf ? 'time' : _this151._devs[serial].imm_functionId(funydx);
                        if (funcid != '') {
                            value = ev.slice(3);
                            switch (firstCode) {
                                case NOTIFY_NETPKT_FUNCVALYDX:
                                    if (value != '') value = value.split('\0')[0];
                                    // function value ydx (tiny notification)
                                    _this151.imm_setFunctionValue(serial + '.' + funcid, value);
                                    break;
                                case NOTIFY_NETPKT_DEVLOGYDX:
                                    // log notification
                                    break;
                                case NOTIFY_NETPKT_TIMEVALYDX:
                                case NOTIFY_NETPKT_TIMEAVGYDX:
                                case NOTIFY_NETPKT_TIMEV2YDX:

                                    // timed value report
                                    var pos,
                                        arr = [firstCode == 'x' ? 0 : firstCode == 'z' ? 1 : 2];
                                    for (pos = 0; pos < value.length; pos += 2) {
                                        arr.push(parseInt(value.substr(pos, 2), 16));
                                    }
                                    var dev = _this151._devs[serial];
                                    if (funcid == 'time') {
                                        var time = arr[1] + 0x100 * arr[2] + 0x10000 * arr[3] + 0x1000000 * arr[4];
                                        dev.imm_setDeviceTime(time + arr[5] / 250.0);
                                    } else {
                                        _this151.imm_setTimedReport(serial + '.' + funcid, dev.imm_getDeviceTime(), arr);
                                    }
                                    break;
                                case NOTIFY_NETPKT_FUNCV2YDX:
                                    var rawval = _this151.imm_decodeNetFuncValV2(value);
                                    if (rawval != null) {
                                        var decodedval = _this151.imm_decodePubVal(rawval[0], rawval, 1, 6);
                                        _this151.imm_setFunctionValue(serial + '.' + funcid, decodedval);
                                    }
                                    break;
                                case NOTIFY_NETPKT_FLUSHV2YDX:
                                // To be implemented later
                                default:
                                    break;
                            }
                        }
                    }
                } else if (ev.length > 5 && ev.substr(0, 4) == 'YN01') {
                    hub.retryDelay = 15;
                    if (hub.notifPos >= 0) hub.notifPos += ev.length + 1;
                    var notype = ev.substr(4, 1);
                    if (notype == '@') {
                        hub.notifPos = parseInt(ev.slice(5));
                    } else switch (parseInt(notype)) {
                        case 0: // device name change, or arrival
                        case 2: // device plug/unplug
                        case 4: // function name change
                        case 8:
                            // function name change (ydx)
                            hub.devListExpires = 0;
                            break;
                        case 5:
                            // function value (long notification)
                            var parts = ev.slice(5).split(',');
                            if (parts.length > 2) {
                                value = parts[2].split('\0');
                                _this151.imm_setFunctionValue(parts[0] + '.' + parts[1], value[0]);
                            }
                            break;
                    }
                } else {
                    // oops, bad notification ? be safe until a good one comes
                    hub.devListValidity = 500;
                    hub.devListExpires = 0;
                    //alert('bad event on line '+idx+'/'+nrows+' : '+ev);
                    hub.notifPos = -1;
                }
                hub.currPos += ev.length + 1;
            }
            if (_this151._forwardValues > 0) {
                yield _this151.HandleEvents(new YErrorMsg());
            }
        })();
    }

    /** Network notification format: 7x7bit (mapped to 7 chars in range 32..159)
     *                               used to represent 1 flag (RAW6BYTES) + 6 bytes
     * INPUT:  [R765432][1076543][2107654][3210765][4321076][5432107][6543210]
     * OUTPUT: 7 bytes array (1 byte for the funcint_TypeV2 and 6 bytes of USB like data
     *                     funcTypeV2 + [R][-byte 0][-byte 1-][-byte 2-][-byte 3-][-byte 4-][-byte 5-]
     *
     * @return {number[]}
     */
    imm_decodeNetFuncValV2(p) {
        var p_ofs = 0;
        var ch = p.charCodeAt(p_ofs) & 0xff;
        var len = 0;
        var funcVal = [0, 0, 0, 0, 0, 0, 0];

        if (ch < 32 || ch > 32 + 127) {
            return null;
        }
        // get the 7 first bits
        ch -= 32;
        funcVal[0] = (ch & 0x40) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
        // clear flag
        ch &= 0x3f;
        while (len < YOCTO_PUBVAL_SIZE) {
            p_ofs++;
            if (p_ofs >= p.length) break;
            var newCh = p.charCodeAt(p_ofs) & 0xff;
            if (newCh == NOTIFY_NETPKT_STOP) {
                break;
            }
            if (newCh < 32 || newCh > 32 + 127) {
                return null;
            }
            newCh -= 32;
            ch = (ch << 7) + newCh;
            funcVal[len + 1] = ch >> 5 - len & 0xff;
            len++;
        }
        return funcVal;
    }

    /** Decode an enhanced notification (V2) buffer
     *
     * @param int_typeV2 {number}
     * @param arr_funcval {number[]}
     * @param int_ofs {number}
     * @param int_funcvalen {number}
     * @returns {string}
     */
    imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
        var buffer = '';
        var endp;
        if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
            var funcValType;
            if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
                funcValType = PUBVAL_6RAWBYTES;
            } else {
                funcValType = arr_funcval[int_ofs++];
            }
            switch (funcValType) {
                case PUBVAL_LEGACY:
                    // fallback to legacy handling, just in case
                    break;
                case PUBVAL_1RAWBYTE:
                case PUBVAL_2RAWBYTES:
                case PUBVAL_3RAWBYTES:
                case PUBVAL_4RAWBYTES:
                case PUBVAL_5RAWBYTES:
                case PUBVAL_6RAWBYTES:
                    // 1..5 hex bytes
                    for (var i = 0; i < funcValType; i++) {
                        var c = arr_funcval[int_ofs++];
                        var b = c >> 4;
                        buffer += b.toString(16);
                        b = c & 0xf;
                        buffer += b.toString(16);
                    }
                    return buffer;
                case PUBVAL_C_LONG:
                case PUBVAL_YOCTO_FLOAT_E3:
                    // 32bit integer in little endian format or Yoctopuce 10-3 format
                    var numVal = arr_funcval[int_ofs++];
                    numVal += arr_funcval[int_ofs++] << 8;
                    numVal += arr_funcval[int_ofs++] << 16;
                    numVal += arr_funcval[int_ofs++] << 24;
                    if (funcValType == PUBVAL_C_LONG) {
                        return String(Math.round(numVal));
                    } else {
                        buffer = String(Math.round(numVal * 1000) / 1000000.0);
                        endp = buffer.length;
                        while (endp > 0 && buffer[endp - 1] == '0') {
                            --endp;
                        }
                        if (endp > 0 && buffer[endp - 1] == '.') {
                            --endp;
                            buffer = buffer.substr(0, endp);
                        }
                        return buffer;
                    }
                case PUBVAL_C_FLOAT:
                    // 32bit (short) float
                    var v = arr_funcval[int_ofs++];
                    v += arr_funcval[int_ofs++] << 8;
                    v += arr_funcval[int_ofs++] << 16;
                    v += arr_funcval[int_ofs++] << 24;
                    var fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >> 31 | 1);
                    var exp = (v >> 23 & 0xFF) - 127;
                    var floatVal = fraction * Math.pow(2, exp - 23);
                    buffer = String(Math.round(floatVal * 1000000) / 1000000);
                    endp = buffer.length;
                    while (endp > 0 && buffer[endp - 1] == '0') {
                        --endp;
                    }
                    if (endp > 0 && buffer[endp - 1] == '.') {
                        --endp;
                        buffer = buffer.substr(0, endp);
                    }
                    return buffer;
                default:
                    return '?';
            }

            // Legacy handling: just pad with NUL up to 7 chars
            var len = 0;
            buffer = '';
            while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
                if (arr_funcval[len] == 0) break;
                buffer += String.fromCharCode(arr_funcval[len]);
                len++;
            }
        }
        return buffer;
    }

    imm_decExp(int_pow) {
        const arr = [1.0e-6, 1.0e-5, 1.0e-4, 1.0e-3, 1.0e-2, 1.0e-1, 1.0, 1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5, 1.0e6, 1.0e7, 1.0e8, 1.0e9];
        return arr[int_pow];
    }

    // Convert Yoctopuce 16-bit decimal floats to standard double-precision floats
    //
    imm_decimalToDouble(val) {
        var negate = false;
        var res;
        var mantis = val & 2047;
        if (mantis == 0) return 0.0;
        if (val > 32767) {
            negate = true;
            val = 65536 - val;
        } else if (val < 0) {
            negate = true;
            val = -val;
        }
        var decexp = this.imm_decExp(val >> 11);
        if (decexp >= 1.0) {
            res = mantis * decexp;
        } else {
            // fix rounding issue
            res = mantis / Math.round(1 / decexp);
        }

        return negate ? -res : res;
    }

    // Convert standard double-precision floats to Yoctopuce 16-bit decimal floats
    //
    imm_doubleToDecimal(val) {
        var negate = false;
        var comp, mant;
        var decpow;
        var res;

        if (val == 0.0) {
            return 0;
        }
        if (val < 0) {
            negate = true;
            val = -val;
        }
        comp = val / 1999.0;
        decpow = 0;
        while (comp > this.imm_decExp(decpow) && decpow < 15) {
            decpow++;
        }
        mant = val / this.imm_decExp(decpow);
        if (decpow == 15 && mant > 2047.0) {
            res = (15 << 11) + 2047; // overflow
        } else {
                res = (decpow << 11) + Math.round(mant);
            }
        return negate ? -res : res;
    }

    imm_getCalibrationHandler(calibType) {
        return this._calibHandlers[calibType];
    }

    // Parse an array of u16 encoded in a base64-like string with memory-based compression
    imm_decodeWords(data) {
        var udata = [];
        for (var i = 0; i < data.length;) {
            var c = data[i];
            if (c == '*') {
                val = 0;
                i++;
            } else if (c == 'X') {
                val = 0xffff;
                i++;
            } else if (c == 'Y') {
                val = 0x7fff;
                i++;
            } else if (c >= 'a') {
                var srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
                if (srcpos < 0) val = 0;else val = udata[srcpos];
            } else {
                if (i + 3 > data.length) return udata;
                var val = data.charCodeAt(i++) - 48;
                val += data.charCodeAt(i++) - 48 << 5;
                var lastcode = data.charCodeAt(i++);
                if (lastcode == 122) lastcode = 92;
                val += lastcode - 48 << 10;
            }
            udata.push(val);
        }
        return udata;
    }

    // Parse an array of u16 encoded in a base64-like string with memory-based compresssion
    imm_decodeFloats(data) {
        var idata = [];
        var p = 0;
        var datalen = data.length;
        while (p < datalen) {
            var val = 0;
            var sign = 1;
            var dec = 0;
            var decInc = 0;
            var c = data[p++];
            while (c != '-' && (c < '0' || c > '9')) {
                if (p >= datalen) {
                    return idata;
                }
                c = data[p++];
            }
            if (c == '-') {
                if (p >= datalen) {
                    return idata;
                }
                sign = -sign;
                c = data[p++];
            }
            while (c >= '0' && c <= '9' || c == '.') {
                if (c == '.') {
                    decInc = 1;
                } else if (dec < 3) {
                    val = val * 10 + (c.charCodeAt(0) - 48);
                    dec += decInc;
                }
                if (p < datalen) {
                    c = data[p++];
                } else {
                    c = '\0';
                }
            }
            if (dec < 3) {
                if (dec == 0) val *= 1000;else if (dec == 1) val *= 100;else val *= 10;
            }
            idata.push(sign * val);
        }
        return idata;
    }

    /** Convert a numeric string to an integer
     *
     * @param str_data {string}
     * @return {number}
     */
    imm_atoi(str_data) {
        var num = parseInt(str_data);
        if (isNaN(num)) {
            return 0;
        }
        return Math.floor(num);
    }

    /** Convert a binary object to string
     *
     * @param bin_data {Uint8Array|Buffer}
     * @return {string}
     */
    imm_bin2str(bin_data) {
        /** @type {number} **/
        let len = bin_data.length;
        /** @type {string} **/
        let res = '';
        for (let i = 0; i < len; i += 20) {
            let subdata = bin_data.subarray(i, Math.min(i + 20, len));
            res += String.fromCharCode.apply(null, subdata);
        }
        return res;
    }

    /** Convert a string to binary object
     *
     * @param str_data {string}
     * @return {Uint8Array}
     */
    imm_str2bin(str_data) {
        /** @type {number} **/
        let len = str_data.length;
        /** @type {Uint8Array} **/
        let res = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            res[i] = str_data.charCodeAt(i);
        }
        return res;
    }

    /** Convert a binary object to hex string
     *
     * @param bin_data {Uint8Array}
     * @return {string}
     */
    imm_bin2hexstr(bin_data) {
        /** @type {number} **/
        let len = bin_data.length;
        /** @type {string} **/
        let res = '';
        for (let i = 0; i < len; i++) {
            let n = bin_data[i].toString(16);
            res += n.length < 2 ? '0' + n : n;
        }
        return res.toUpperCase();
    }

    /** Convert a hex string to binary object
     *
     * @param str_data {string}
     * @return {Uint8Array}
     */
    imm_hexstr2bin(str_data) {
        /** @type {number} **/
        let len = str_data.length >> 1;
        /** @type {Uint8Array} **/
        let res = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            res[i] = parseInt(str_data.substr(2 * i, 2), 16);
        }
        return res;
    }

    /** Return a Device object for a specified URL, serial number or logical device name
     *
     * @param str_device {string}
     * @return {YDevice}
     *
     * This function will not cause any network access (not async !)
     */
    imm_getDevice(str_device) {
        var dev = null;
        var serial;

        if (str_device.substr(0, 7) == 'http://' || str_device.substr(0, 5) == 'ws://') {
            // lookup by url
            serial = this._snByUrl[str_device];
            if (serial != undefined) dev = this._devs[serial];
        } else {
            // lookup by serial
            if (this._devs[str_device]) {
                dev = this._devs[str_device];
            } else {
                // fallback to lookup by logical name
                serial = this._snByName[str_device];
                if (serial) {
                    dev = this._devs[serial];
                }
            }
        }
        return dev;
    }

    /** Add or remove a value change callback
     *
     * @param obj_func {YFunction}
     * @param bool_add {Boolean}
     */
    _UpdateValueCallbackList(obj_func, bool_add) {
        var _this152 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let index = _this152._ValueCallbackList.indexOf(obj_func);
            if (bool_add) {
                yield obj_func.isOnline();
                if (index < 0) {
                    _this152._ValueCallbackList.push(obj_func);
                }
            } else if (index >= 0) {
                _this152._ValueCallbackList.splice(index, 1);
            }
        })();
    }

    /** Add or remove a timed report callback
     *
     * @param obj_func {YFunction}
     * @param bool_add {Boolean}
     */
    _UpdateTimedReportCallbackList(obj_func, bool_add) {
        var _this153 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let index = _this153._TimedReportCallbackList.indexOf(obj_func);
            if (bool_add) {
                yield obj_func.isOnline();
                if (index < 0) {
                    _this153._TimedReportCallbackList.push(obj_func);
                }
            } else if (index >= 0) {
                _this153._TimedReportCallbackList.splice(index, 1);
            }
        })();
    }

    // Return the class name for a given function ID or full Hardware Id
    // Also make sure that the function type is registered in the API
    imm_functionClass(str_funcid) {
        var dotpos = str_funcid.indexOf('.');
        if (dotpos >= 0) str_funcid = str_funcid.substr(dotpos + 1);
        var classlen = str_funcid.length;
        while (str_funcid.substr(classlen - 1, 1) <= '9') classlen--;
        var classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
        if (this._fnByType[classname] == undefined) this._fnByType[classname] = new YFunctionType(this, classname);

        return classname;
    }

    // Reindex a device in YAPI after a name change detected by device refresh
    imm_reindexDevice(obj_dev) {
        var rootUrl = obj_dev.imm_getRootUrl();
        var serial = obj_dev.imm_getSerialNumber();
        var lname = obj_dev.imm_getLogicalName();
        this._devs[serial] = obj_dev;
        this._snByUrl[rootUrl] = serial;
        if (lname != '') this._snByName[lname] = serial;
        this._fnByType['Module'].imm_reindexFunction(serial + '.module', lname, null, null);
        var i,
            count = obj_dev.imm_functionCount();
        for (i = 0; i < count; i++) {
            var funcid = obj_dev.imm_functionId(i);
            var funcname = obj_dev.imm_functionName(i);
            var classname = this.imm_functionClass(funcid);
            this._fnByType[classname].imm_reindexFunction(serial + '.' + funcid, funcname, null, null);
        }
    }

    // Remove a device from YAPI after an unplug detected by device refresh
    imm_forgetDevice(obj_dev) {
        var rootUrl = obj_dev.imm_getRootUrl();
        var serial = obj_dev.imm_getSerialNumber();
        var lname = obj_dev.imm_getLogicalName();
        delete this._devs[serial];
        delete this._snByUrl[rootUrl];
        if (this._snByName[lname] == serial) {
            delete this._snByName[lname];
        }
        this._fnByType['Module'].imm_forgetFunction(serial + '.module');
        var i,
            count = obj_dev.imm_functionCount();
        for (i = 0; i < count; i++) {
            var funcid = obj_dev.imm_functionId(i);
            var classname = this.imm_functionClass(funcid);
            this._fnByType[classname].imm_forgetFunction(serial + '.' + funcid);
        }
    }

    // Find the best known identifier (hardware Id) for a given function
    imm_resolveFunction(str_className, str_func) {
        if (Y_BASETYPES[str_className] == undefined) {
            // using a regular function type
            if (this._fnByType[str_className] == undefined) this._fnByType[str_className] = new YFunctionType(this, str_className);
            return this._fnByType[str_className].imm_resolve(str_func);
        }
        // using an abstract baseType
        var baseType = Y_BASETYPES[str_className];
        var res;
        for (str_className in this._fnByType) {
            if (this._fnByType[str_className].imm_getBaseType() == baseType) {
                res = this._fnByType[str_className].imm_resolve(str_func);
                if (res.errorType == YAPI_SUCCESS) return res;
            }
        }
        return { errorType: YAPI_DEVICE_NOT_FOUND,
            errorMsg: 'No ' + str_className + ' [' + str_func + '] found (old firmware?)',
            result: null };
    }

    // Find the best known identifier (hardware Id) for a given function
    imm_getFriendlyNameFunction(str_className, str_func) {
        if (Y_BASETYPES[str_className] == undefined) {
            // using a regular function type
            if (this._fnByType[str_className] == undefined) this._fnByType[str_className] = new YFunctionType(this, str_className);
            return this._fnByType[str_className].imm_getFriendlyName(str_func);
        }
        // using an abstract baseType
        var baseType = Y_BASETYPES[str_className];
        var res;
        for (str_className in this._fnByType) {
            if (this._fnByType[str_className].imm_getBaseType() == baseType) {
                res = this._fnByType[str_className].imm_getFriendlyName(str_func);
                if (res.errorType == YAPI_SUCCESS) return res;
            }
        }
        return { errorType: YAPI_DEVICE_NOT_FOUND,
            errorMsg: 'No ' + str_className + ' [' + str_func + '] found (old firmware?)',
            result: null };
    }

    // Retrieve a function object by hardware id, updating the indexes on the fly if needed
    imm_setFunction(str_className, str_func, obj_func) {
        if (this._fnByType[str_className] == undefined) this._fnByType[str_className] = new YFunctionType(this, str_className);
        return this._fnByType[str_className].imm_setFunction(str_func, obj_func);
    }

    // Retrieve a function object by hardware id, updating the indexes on the fly if needed
    imm_getFunction(str_className, str_func) {
        if (this._fnByType[str_className] == undefined) this._fnByType[str_className] = new YFunctionType(this, str_className);
        return this._fnByType[str_className].imm_getFunction(str_func);
    }

    // Set a function advertised value by hardware id
    imm_setFunctionValue(str_hwid, str_pubval) {
        let classname = this.imm_functionClass(str_hwid);
        if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
            let receivers = this._ValueCallbackList;
            for (let i = 0; i < receivers.length; i++) {
                let fun = receivers[i];
                if (!fun._hwId) continue;
                if (fun._hwId == str_hwid) {
                    this._data_events.push([fun, str_pubval]);
                }
            }
        }
    }

    // Set add a timed value report for a function
    imm_setTimedReport(str_hwid, float_timestamp, arr_report) {
        let classname = this.imm_functionClass(str_hwid);
        let receivers = this._TimedReportCallbackList;
        for (let i = 0; i < receivers.length; i++) {
            let fun = receivers[i];
            if (!fun._hwId) continue;
            if (fun._hwId == str_hwid) {
                this._data_events.push([fun, float_timestamp, arr_report]);
            }
        }
    }

    // Retrieve a function advertised value by hardware id
    imm_getFunctionValue(str_hwid) {
        var classname = this.imm_functionClass(str_hwid);
        return this._fnByType[classname].imm_getFunctionValue(str_hwid);
    }

    // Retrieve a function advertised value by hardware id
    imm_getFunctionBaseType(str_hwid) {
        var classname = this.imm_functionClass(str_hwid);
        return this._fnByType[classname].imm_getBaseType();
    }

    // Find the hardwareId for the first instance of a given function class
    imm_getFirstHardwareId(str_className) {
        if (Y_BASETYPES[str_className] == undefined) {
            // enumeration of a regular function type
            if (this._fnByType[str_className] == undefined) this._fnByType[str_className] = new YFunctionType(this, str_className);
            return this._fnByType[str_className].imm_getFirstHardwareId();
        }
        // enumeration of an abstract class
        var baseType = Y_BASETYPES[str_className];
        var res;
        for (str_className in this._fnByType) {
            if (this._fnByType[str_className].imm_getBaseType() == baseType) {
                res = this._fnByType[str_className].imm_getFirstHardwareId();
                if (res != undefined) return res;
            }
        }
        return null;
    }

    // Find the hardwareId for the next instance of a given function class
    imm_getNextHardwareId(str_className, str_hwid) {
        if (Y_BASETYPES[str_className] == undefined) {
            // enumeration of a regular function type
            return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
        }
        // enumeration of an abstract class
        var baseType = Y_BASETYPES[str_className];
        var prevclass = this.imm_functionClass(str_hwid);
        var res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
        if (res != undefined) return res;
        for (str_className in this._fnByType) {
            if (prevclass != '') {
                if (str_className != prevclass) continue;
                prevclass = '';
                continue;
            }
            if (this._fnByType[str_className].imm_getBaseType() == baseType) {
                res = this._fnByType[str_className].imm_getFirstHardwareId();
                if (res != undefined) return res;
            }
        }
        return null;
    }

    /** Perform an HTTP request on a device, by URL or identifier.
     * When loading the REST API from a device by identifier, the device cache will be used.
     *
     * @param str_device {string}
     * @param str_request {string}
     * @param obj_body {Uint8Array|string}
     * @returns {YHTTPRequest}
     */
    devRequest(str_device, str_request) {
        var _arguments = arguments,
            _this154 = this;

        return _asyncToGenerator(function* () {
            let obj_body = _arguments.length <= 2 || _arguments[2] === undefined ? '' : _arguments[2];

            /** @type {string[]} **/
            let lines = str_request.split('\n');
            /** @type {YHTTPRequest} **/
            let res = new YHTTPRequest(null);
            /** @type {YDevice} **/
            let lockdev;
            /** @type {string} **/
            let baseUrl;
            if (str_device.substr(0, 7) == 'http://' || str_device.substr(0, 5) == 'ws://') {
                baseUrl = str_device;
                if (baseUrl.slice(-1) != '/') baseUrl = baseUrl + '/';
                if (lines[0].substr(0, 12) != 'GET /not.byn') {
                    /** @type {string} **/
                    let serial = _this154._snByUrl[baseUrl];
                    if (serial) {
                        lockdev = _this154._devs[serial];
                    }
                }
            } else {
                lockdev = _this154.imm_getDevice(str_device);
                if (!lockdev) {
                    res.errorType = YAPI_DEVICE_NOT_FOUND;
                    res.errorMsg = 'Device [' + str_device + '] not online';
                    return res;
                }
                // use the device cache when loading the whole API
                if (lines[0] == 'GET /api.json') {
                    return yield lockdev.requestAPI(_this154.defaultCacheValidity);
                }
                baseUrl = lockdev.imm_getRootUrl();
            }
            // map str_device to a URL
            /** @type {string[]} **/
            let words = lines[0].split(' ');
            if (words.length < 2) {
                res.errorType = YAPI_INVALID_ARGUMENT;
                res.errorMsg = 'Invalid request, not enough words; expected a method name and a URL';
                return res;
            } else if (words.length > 2) {
                res.errorType = YAPI_INVALID_ARGUMENT;
                res.errorMsg = 'Invalid request, too many words; make sure the URL is URI-encoded';
                return res;
            }
            /** @type {YGenericHub} **/
            let hub = _this154.imm_getHub(baseUrl);
            /** @type {string} **/
            let method = words[0];
            /** @type {string} **/
            let devUrl = words[1];
            if (devUrl.substr(0, 1) == '/') devUrl = devUrl.substr(1);
            // keep only root URL in baseUrl, move the rest to devUrl
            let pos = baseUrl.indexOf('//');
            pos = baseUrl.indexOf('/', pos + 3);
            devUrl = baseUrl.slice(pos) + devUrl;
            baseUrl = baseUrl.slice(0, pos);
            if (!obj_body) obj_body = '';

            // queue the call to user callback function in the pending queries promise chain
            let delayedCode = () => {
                return hub.request(method, baseUrl, devUrl, obj_body);
            };
            if (lockdev) {
                let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
                lockdev._pendingQueries = newPromise;
                res = yield newPromise;
            } else {
                res = yield delayedCode();
            }
            return res;
        })();
    }

    /** Locate the device to access a specified function, without causing any I/O
     *
     * @param str_className {string}
     * @param str_func {string}
     * @returns {YFuncRequest}
     */
    imm_funcDev_internal(str_className, str_func) {
        var res = new YFuncRequest(null);
        var resolve = this.imm_resolveFunction(str_className, str_func);
        if (resolve.errorType != YAPI_SUCCESS) {
            res.errorType = resolve.errorType;
            res.errorMsg = resolve.errorMsg;
        } else {
            str_func = resolve.result;
            let dotpos = str_func.indexOf('.');
            let devid = str_func.substr(0, dotpos);
            let funcid = str_func.substr(dotpos + 1);
            let dev = this.imm_getDevice(devid);
            if (dev == null) {
                res.errorType = YAPI_DEVICE_NOT_FOUND;
                res.errorMsg = 'Device [' + devid + '] not found';
            } else {
                res.obj_result = { device: dev, deviceid: devid, functionid: funcid, hwid: str_func };
            }
        }
        return res;
    }

    /** Locate the device to access a specified function. May cause device list update if needed
     *
     * @param str_className {string}
     * @param str_func {string}
     * @returns {YFuncRequest}
     */
    _funcDev(str_className, str_func) {
        var _this155 = this;

        return _asyncToGenerator(function* () {
            var resolve = _this155.imm_funcDev_internal(str_className, str_func);
            if (resolve.errorType == YAPI_SUCCESS) {
                return resolve;
            } else if (resolve.errorType == YAPI_DEVICE_NOT_FOUND && _this155._hubs.length == 0) {
                // when USB is supported, check if no USB device is connected before outputing this message
                resolve.errorMsg = 'Impossible to contact any device because no hub has been registered';
                return resolve;
            }
            var updRes = yield _this155._updateDeviceList_internal(true, false);
            if (updRes.errorType != YAPI_SUCCESS) {
                resolve.errorType = updRes.errorType;
                resolve.errorMsg = updRes.errorMsg;
                return resolve;
            }
            return _this155.imm_funcDev_internal(str_className, str_func);
        })();
    }

    /** Load and parse the REST API for a function given by class name and identifier, possibly applying changes
     * Device cache will be preloaded when loading function 'module' and leveraged for other modules
     *
     * @param str_className {string}
     * @param str_func {string}
     * @param str_extra {string}
     * @param int_msValidity {number}
     * @returns {YFuncRequest}
     */
    funcRequest(str_className, str_func, str_extra) {
        var _arguments2 = arguments,
            _this156 = this;

        return _asyncToGenerator(function* () {
            let int_msValidity = _arguments2.length <= 3 || _arguments2[3] === undefined ? null : _arguments2[3];

            /** @type {YFuncRequest} **/
            let funcreq = yield _this156._funcDev(str_className, str_func);
            if (funcreq.errorType != YAPI_SUCCESS) {
                return funcreq;
            }
            let devreq = funcreq.obj_result;
            let loadval = null;
            let yreq;
            if (str_extra == '') {
                // use a cached API string (reload if needed)
                /** @type {YHTTPRequest} **/
                yreq = yield devreq.device.requestAPI(int_msValidity);
                if (yreq != null) {
                    if (yreq.errorType != YAPI_SUCCESS) return yreq;
                    try {
                        let jsonData = JSON.parse(_this156.imm_bin2str(yreq.bin_result));
                        loadval = jsonData[devreq.functionid];
                    } catch (err) {
                        //console.log('RequestAPI parse error: ', err);
                    }
                }
            } else {
                    devreq.device.imm_dropCache();
                }
            if (!loadval) {
                // request specified function only to minimize traffic
                if (str_extra == '') str_extra = '.json';
                let httpreq = 'GET /api/' + devreq.functionid + str_extra;
                /** @type {YHTTPRequest} **/
                yreq = yield _this156.devRequest(devreq.deviceid, httpreq);
                if (yreq.errorType != YAPI_SUCCESS) return yreq;
                if (yreq.bin_result.length == 0 && httpreq.indexOf('?') >= 0) {
                    funcreq.obj_result = yreq.bin_result;
                    return funcreq;
                }
                try {
                    loadval = JSON.parse(_this156.imm_bin2str(yreq.bin_result));
                } catch (err) {
                    //console.log('RequestAPI parse error: ', err);
                }
            }
            if (!loadval) {
                funcreq.errorType = YAPI_IO_ERROR;
                funcreq.errorMsg = 'Request failed, could not parse API value for function ' + devreq.hwid;
            } else {
                for (let key in devreq) {
                    loadval[key] = devreq[key];
                }
                funcreq.obj_result = loadval;
            }
            return funcreq;
        })();
    }

    /** Perform an HTTP request on a device and return the result string
     *
     * @param str_device {string}
     * @param str_request {string}
     * @returns {Uint8Array}
     */
    HTTPRequest(str_device, str_request) {
        var _this157 = this;

        return _asyncToGenerator(function* () {
            /** @type {YHTTPRequest} **/
            let yreq = yield _this157.devRequest(str_device, str_request);
            if (yreq.errorType != YAPI_SUCCESS) {
                return _this157._throw(yreq.errorType, yreq.errorMsg, null);
            }
            return yreq.bin_result;
        })();
    }

    /**
     * Returns the version identifier for the Yoctopuce library in use.
     * The version is a string in the form "Major.Minor.Build",
     * for instance "1.01.5535". For languages using an external
     * DLL (for instance C#, VisualBasic or Delphi), the character string
     * includes as well the DLL version, for instance
     * "1.01.5535 (1.01.5439)".
     *
     * If you want to verify in your code that the library version is
     * compatible with the version that you have used during development,
     * verify that the major number is strictly equal and that the minor
     * number is greater or equal. The build number is not relevant
     * with respect to the library compatibility.
     *
     * @return {string} a character string describing the library version.
     */
    GetAPIVersion() {
        return _asyncToGenerator(function* () {
            return (/* version number patched automatically */'1.10.22592-dev.34'
            );
        })();
    }

    /**
     * Initializes the Yoctopuce programming library explicitly.
     * It is not strictly needed to call yInitAPI(), as the library is
     * automatically  initialized when calling yRegisterHub() for the
     * first time.
     *
     * When YAPI.DETECT_NONE is used as detection mode,
     * you must explicitly use yRegisterHub() to point the API to the
     * VirtualHub on which your devices are connected before trying to access them.
     *
     * @param mode {number} : an integer corresponding to the type of automatic
     *         device detection to use. Possible values are
     *         YAPI.DETECT_NONE, YAPI.DETECT_USB, YAPI.DETECT_NET,
     *         and YAPI.DETECT_ALL.
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    InitAPI(mode, errmsg) {
        return _asyncToGenerator(function* () {
            // nothing to be done for now
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Frees dynamically allocated memory blocks used by the Yoctopuce library.
     * It is generally not required to call this function, unless you
     * want to free all dynamically allocated memory blocks in order to
     * track a memory leak for instance.
     * You should not call any other library function after calling
     * yFreeAPI(), or your program will crash.
     */
    FreeAPI() {
        var _this158 = this;

        return _asyncToGenerator(function* () {
            // when invoked in callback mode, close connection
            for (let i = 0; i < _this158._hubs.length; i++) {
                _this158._hubs[i].disconnect();
            }

            // clear all caches
            _this158.imm_init();
        })();
    }

    /**
     * Disables the use of exceptions to report runtime errors.
     * When exceptions are disabled, every function returns a specific
     * error value which depends on its type and which is documented in
     * this reference manual.
     */
    DisableExceptions() {
        var _this159 = this;

        return _asyncToGenerator(function* () {
            _this159.exceptionsDisabled = true;
        })();
    }

    /**
     * Re-enables the use of exceptions for runtime error handling.
     * Be aware than when exceptions are enabled, every function that fails
     * triggers an exception. If the exception is not caught by the user code,
     * it  either fires the debugger or aborts (i.e. crash) the program.
     * On failure, throws an exception or returns a negative error code.
     */
    EnableExceptions() {
        var _this160 = this;

        return _asyncToGenerator(function* () {
            _this160.exceptionsDisabled = false;
        })();
    }

    /**
     * Enable logging to the console for unhandled promise rejections,
     * such as exceptions in async functions without a try/catch.
     * This is not really a Yoctopuce thing, but since it is not obvious
     * to find out and since the code differs depending on the environment,
     * we provide it here for convenience.
     */
    LogUnhandledPromiseRejections() {
        var _this161 = this;

        return _asyncToGenerator(function* () {
            if (_this161._isNodeJS) {
                process.on('unhandledRejection', function (reason, p) {
                    console.log("Unhandled Rejection at: Promise ", p, " reason: ", reason);
                });
            } else {
                window.addEventListener('onunhandledrejection', function (event) {
                    console.error('Unhandled rejection (promise: ', event.promise, ', reason: ', event.reason, ').');
                });
            }
        })();
    }

    // Parse a hub URL
    imm_parseRegisteredUrl(str_url) {
        var user = '';
        var pass = '';
        var port = '4444';
        var host;
        var url = 'http://';

        if (str_url.slice(0, 7) == 'http://') {
            str_url = str_url.slice(7);
        } else if (str_url.slice(0, 5) == 'ws://') {
            url = 'ws://';
            str_url = str_url.slice(5);
        }
        var pos = str_url.indexOf('/');
        if (pos > 0) {
            str_url = str_url.slice(0, pos);
        }
        var authpos = str_url.indexOf('@');
        if (authpos >= 0) {
            var auth = str_url.slice(0, authpos);
            var passpos = auth.indexOf(':');
            if (passpos >= 0) {
                user = auth.slice(0, passpos);
                pass = auth.slice(passpos + 1);
                url += user + ':' + pass + '@';
            } else {
                user = auth;
                url += user + '@';
            }
            str_url = str_url.slice(authpos + 1);
        }
        pos = str_url.indexOf(':');
        if (pos < 0) {
            host = str_url;
        } else {
            host = str_url.slice(0, pos);
            port = str_url.slice(pos + 1);
        }
        if (host == 'callback') {
            if (url.slice(0, 3) == 'ws:') {
                url = 'ws://callback:4444/';
            } else {
                url = 'http://callback:4444/';
            }
        } else {
            url += host + ':' + port + '/';
        }
        var res = { 'user': user, 'pass': pass, 'host': host, 'port': port, 'url': url };
        return res;
    }

    imm_registerHub_internal(urlInfo) {
        let newhub;
        if (urlInfo.url.slice(0, 3) == 'ws:') {
            if (this._isNodeJS) {
                newhub = new YWebSocketNodeHub(this, urlInfo);
            } else {
                newhub = new YWebSocketHub(this, urlInfo);
            }
        } else {
            if (this._isNodeJS) {
                newhub = new YHttpNodeHub(this, urlInfo);
            } else {
                newhub = new YHttpHub(this, urlInfo);
            }
        }
        return newhub;
    }

    /**
     * Setup the Yoctopuce library to use modules connected on a given machine. The
     * parameter will determine how the API will work. Use the following values:
     *
     * <b>usb</b>: When the usb keyword is used, the API will work with
     * devices connected directly to the USB bus. Some programming languages such a Javascript,
     * PHP, and Java don't provide direct access to USB hardware, so usb will
     * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
     *
     * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
     * host with the given IP address or hostname. That host can be a regular computer
     * running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or
     * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
     * computer, use the IP address 127.0.0.1.
     *
     * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
     * This a special mode allowing to take control of Yoctopuce devices
     * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
     * need to configure your hub to call your server script on a regular basis.
     * This mode is currently available for PHP and Node.JS only.
     *
     * Be aware that only one application can use direct USB access at a
     * given time on a machine. Multiple access would cause conflicts
     * while trying to access the USB modules. In particular, this means
     * that you must stop the VirtualHub software before starting
     * an application that uses direct USB access. The workaround
     * for this limitation is to setup the library to use the VirtualHub
     * rather than direct USB access.
     *
     * If access control has been activated on the hub, virtual or not, you want to
     * reach, the URL parameter should look like:
     *
     * http://username:password@address:port
     *
     * You can call <i>RegisterHub</i> several times to connect to several machines.
     *
     * @param url {string} : a string containing either "usb","callback" or the
     *         root URL of the hub to monitor
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    RegisterHub(url, errmsg) {
        var _this162 = this;

        return _asyncToGenerator(function* () {
            let urlInfo = _this162.imm_parseRegisteredUrl(url);
            let newhub = _this162.imm_getHub(urlInfo.url);
            if (newhub) {
                return YAPI_SUCCESS;
            }
            newhub = _this162.imm_registerHub_internal(urlInfo);
            let retcode = yield newhub.testHub(errmsg);
            if (retcode != YAPI_SUCCESS) {
                return _this162._throw(retcode, errmsg.msg, retcode);
            }
            yield _this162._addHub(newhub);

            // Update known device list
            let yreq = yield _this162._updateDeviceList_internal(true, false);
            if (yreq.errorType != YAPI_SUCCESS) {
                if (errmsg != undefined) {
                    errmsg.msg = yreq.errorMsg;
                    _this162._serverResponse.write('\n!YoctoAPI:' + errmsg.msg + '\n');
                }
                return _this162._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Fault-tolerant alternative to RegisterHub(). This function has the same
     * purpose and same arguments as RegisterHub(), but does not trigger
     * an error when the selected hub is not available at the time of the function call.
     * This makes it possible to register a network hub independently of the current
     * connectivity, and to try to contact it only when a device is actively needed.
     *
     * @param url {string} : a string containing either "usb","callback" or the
     *         root URL of the hub to monitor
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    PreregisterHub(url, errmsg) {
        var _this163 = this;

        return _asyncToGenerator(function* () {
            let urlInfo = _this163.imm_parseRegisteredUrl(url);
            let newhub = _this163.imm_getHub(urlInfo.url);
            if (newhub) {
                return YAPI_SUCCESS;
            }
            newhub = _this163.imm_registerHub_internal(urlInfo);
            _this163._addHub(newhub);

            // trigger testHub, but don't wait for the result
            newhub.testHub(errmsg);

            return YAPI_SUCCESS;
        })();
    }

    /**
     * Setup the Yoctopuce library to use modules connected on a remote hub
     * performing an incoming connection to an HTTP server.
     *
     * @param incomingMessage {IncomingMessage} : node http incomingMessage object.
     * @param serverResponse  {ServerResponse} : node http serverResponse object.
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI_SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
        var _this164 = this;

        return _asyncToGenerator(function* () {
            let urlInfo = _this164.imm_parseRegisteredUrl('http://callback:4444');
            let newhub = _this164.imm_getHub(urlInfo.url);
            if (newhub) {
                return YAPI_SUCCESS;
            }
            newhub = new YHttpCallbackHub(_this164, urlInfo, incomingMessage, serverResponse);
            yield newhub.httpCallbackPromise;
            let retcode = yield newhub.testHub(errmsg);
            if (retcode != YAPI_SUCCESS) {
                _this164._serverResponse.write('\n!YoctoAPI:' + errmsg.msg + '\n');
                return _this164._throw(retcode, errmsg.msg, retcode);
            }
            yield _this164._addHub(newhub);

            // Update known device list
            let yreq = yield _this164._updateDeviceList_internal(true, false);
            if (yreq.errorType != YAPI_SUCCESS) {
                if (errmsg != undefined) {
                    errmsg.msg = yreq.errorMsg;
                    _this164._serverResponse.write('\n!YoctoAPI:' + errmsg.msg + '\n');
                }
                return _this164._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Setup the Yoctopuce library to use modules connected on a remote hub
     * performing an incoming connection to a websocket server.
     *
     * @param ws {WebSocket} : node-ws WebSocketServer object.
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI_SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    RegisterHubWebSocketCallback(ws, errmsg) {
        var _this165 = this;

        return _asyncToGenerator(function* () {
            let urlInfo = _this165.imm_parseRegisteredUrl('http://callback:4444');
            let newhub = _this165.imm_getHub(urlInfo.url);
            if (newhub) {
                return YAPI_SUCCESS;
            }
            newhub = new YWebSocketCallbackHub(_this165, urlInfo, ws);
            let retcode = yield newhub.testHub(errmsg);
            if (retcode != YAPI_SUCCESS) {
                return _this165._throw(retcode, errmsg.msg, retcode);
            }
            yield _this165._addHub(newhub);

            // Update known device list
            let yreq = yield _this165._updateDeviceList_internal(true, false);
            if (yreq.errorType != YAPI_SUCCESS) {
                if (errmsg != undefined) {
                    errmsg.msg = yreq.errorMsg;
                }
                return _this165._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Setup the Yoctopuce library to no more use modules connected on a previously
     * registered machine with RegisterHub.
     *
     * @param url {string} : a string containing either "usb" or the
     *         root URL of the hub to monitor
     */
    UnregisterHub(url) {
        var _this166 = this;

        return _asyncToGenerator(function* () {
            var urlInfo = _this166.imm_parseRegisteredUrl(url);
            var i, j;

            for (i = 0; i < _this166._hubs.length; i++) {
                if (_this166._hubs[i].urlInfo.url == urlInfo.url) {
                    _this166._hubs[i].disconnect();
                    for (j = 0; j < _this166._hubs[i].serialByYdx.length; j++) {
                        var serial = _this166._hubs[i].serialByYdx[j];
                        _this166.imm_forgetDevice(_this166._devs[serial]);
                    }
                    var before = _this166._hubs.slice(0, i);
                    if (i + 1 < _this166._hubs.length) {
                        var after = _this166._hubs.slice(i + 1);
                        _this166._hubs = before.concat(after);
                    }
                    _this166._hubs = before;
                    return;
                }
            }
        })();
    }

    /**
     * Triggers a (re)detection of connected Yoctopuce modules.
     * The library searches the machines or USB ports previously registered using
     * yRegisterHub(), and invokes any user-defined callback function
     * in case a change in the list of connected devices is detected.
     *
     * This function can be called as frequently as desired to refresh the device list
     * and to make the application aware of hot-plug events.
     *
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    UpdateDeviceList(errmsg) {
        var _this167 = this;

        return _asyncToGenerator(function* () {
            var yreq = yield _this167._updateDeviceList_internal(false, true);
            if (yreq.errorType != YAPI_SUCCESS) {
                if (errmsg != undefined) errmsg.msg = yreq.errorMsg;
                return _this167._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
            }
            return YAPI_SUCCESS;
        })();
    }

    /**
     * Maintains the device-to-library communication channel.
     * If your program includes significant loops, you may want to include
     * a call to this function to make sure that the library takes care of
     * the information pushed by the modules on the communication channels.
     * This is not strictly necessary, but it may improve the reactivity
     * of the library for the following commands.
     *
     * This function may signal an error in case there is a communication problem
     * while contacting a module.
     *
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    HandleEvents(errmsg) {
        var _this168 = this;

        return _asyncToGenerator(function* () {
            var nEvents = _this168._data_events.length;
            for (var i = 0; i < nEvents; i++) {
                var evt = _this168._data_events[i];
                if (typeof evt[1] == 'string') {
                    // event object is an advertised value
                    yield evt[0]._invokeValueCallback(evt[1]);
                } else {
                    // event object is an array of bytes (encoded timed report)
                    var dev = _this168.imm_getDevice(evt[0]._serial);
                    if (dev) {
                        var report = yield evt[0]._decodeTimedReport(evt[1], evt[2]);
                        yield evt[0]._invokeTimedReportCallback(report);
                    }
                }
            }
            _this168._data_events = _this168._data_events.slice(nEvents);

            return YAPI_SUCCESS;
        })();
    }

    /**
     * Pauses the execution flow for a specified duration.
     * This function implements a passive waiting loop, meaning that it does not
     * consume CPU cycles significantly. The processor is left available for
     * other threads and processes. During the pause, the library nevertheless
     * reads from time to time information from the Yoctopuce modules by
     * calling yHandleEvents(), in order to stay up-to-date.
     *
     * This function may signal an error in case there is a communication problem
     * while contacting a module.
     *
     * @param ms_duration {number} : an integer corresponding to the duration of the pause,
     *         in milliseconds.
     * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    Sleep(ms_duration, errmsg) {
        var _this169 = this;

        return _asyncToGenerator(function* () {
            var end = _this169.GetTickCount() + ms_duration;
            yield _this169.HandleEvents(errmsg);
            while (_this169.GetTickCount() < end) {
                yield _this169._microSleep_internal();
                yield _this169.HandleEvents(errmsg);
            }
            return YAPI_SUCCESS;
        })();
    }

    // internal async function to wait for a very short period
    _microSleep_internal() {
        return new Promise(function (resolve, reject) {
            setTimeout(resolve, 3);
        });
    }

    /**
     * Returns the current value of a monotone millisecond-based time counter.
     * This counter can be used to compute delays in relation with
     * Yoctopuce devices, which also uses the millisecond as timebase.
     *
     * @return {number} a long integer corresponding to the millisecond counter.
     */
    /**/GetTickCount() {
        return +new Date();
    }

    /**
     * Checks if a given string is valid as logical name for a module or a function.
     * A valid logical name has a maximum of 19 characters, all among
     * A..Z, a..z, 0..9, _, and -.
     * If you try to configure a logical name with an incorrect string,
     * the invalid characters are ignored.
     *
     * @param name {string} : a string containing the name to check.
     *
     * @return {boolean} true if the name is valid, false otherwise.
     */
    CheckLogicalName(name) {
        return _asyncToGenerator(function* () {
            if (name == '') return true;
            if (!name) return false;
            if (name.length > 19) return false;
            return (/^[A-Za-z0-9_\-]*$/.test(name)
            );
        })();
    }

    /**
     * Register a callback function, to be called each time
     * a device is plugged. This callback will be invoked while yUpdateDeviceList
     * is running. You will have to call this function on a regular basis.
     *
     * @param arrivalCallback {function} : a procedure taking a YModule parameter, or null
     *         to unregister a previously registered  callback.
     */
    RegisterDeviceArrivalCallback(arrivalCallback) {
        var _this170 = this;

        return _asyncToGenerator(function* () {
            _this170._arrivalCallback = arrivalCallback;
        })();
    }

    RegisterDeviceChangeCallback(changeCallback) {
        var _this171 = this;

        return _asyncToGenerator(function* () {
            _this171._namechgCallback = changeCallback;
        })();
    }

    /**
     * Register a callback function, to be called each time
     * a device is unplugged. This callback will be invoked while yUpdateDeviceList
     * is running. You will have to call this function on a regular basis.
     *
     * @param removalCallback {function} : a procedure taking a YModule parameter, or null
     *         to unregister a previously registered  callback.
     */
    RegisterDeviceRemovalCallback(removalCallback) {
        var _this172 = this;

        return _asyncToGenerator(function* () {
            _this172._removalCallback = removalCallback;
        })();
    }

    // Register a new value calibration handler for a given calibration type
    //
    RegisterCalibrationHandler(calibrationType, calibrationHandler) {
        var _this173 = this;

        return _asyncToGenerator(function* () {
            _this173._calibHandlers[calibrationType.toString()] = calibrationHandler;
        })();
    }

    // Standard value calibration handler (n-point linear error correction)
    //
    LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
        // calibration types n=1..10 and 11..20 are meant for linear calibration using n points
        var npt;
        var x = arr_calibRawValues[0];
        var adj = arr_calibRefValues[0] - x;
        var i = 0;

        if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
            npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
        } else {
            npt = arr_calibRefValues.length;
        }
        while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
            var x2 = x;
            var adj2 = adj;

            x = arr_calibRawValues[i];
            adj = arr_calibRefValues[i] - x;

            if (float_rawValue < x && x > x2) {
                adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
            }
        }
        return float_rawValue + adj;
    }

    // WPA preshared-key computation
    //
    imm_initshaw(str_s, int_pad, int_xinit, _shaw) {
        var i,
            j = -1,
            k = 0;
        var n = str_s.length;

        for (i = 0; i < 64; i++) {
            var c = 0;
            if (i < n) {
                c = str_s.charCodeAt(i);
            } else if (int_pad != 0) {
                if (i == n + 3) c = int_pad;else if (i == n + 4) c = 0x80;
            }
            if (k == 0) {
                j++;
                _shaw[j] = 0;
                k = 32;
            }
            k -= 8;
            _shaw[j] |= c << k;
        }
        if (int_pad != 0) {
            _shaw[15] = 8 * (64 + n + 4);
        }
        if (int_xinit != 0) {
            var xdw = int_xinit << 16 | int_xinit;
            for (j = 0; j < 16; j++) {
                _shaw[j] ^= xdw;
            }
        }
    }

    imm_itershaw(s, _shaw) {
        var a, b, c, d, e, t, k;

        a = s[0];
        b = s[1];
        c = s[2];
        d = s[3];
        e = s[4];
        for (k = 16; k < 80; k++) {
            t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
            _shaw[k] = t << 1 | t >>> 31;
        }
        for (k = 0; k < 20; k++) {
            t = (a << 5 | a >>> 27) + e + _shaw[k] + 0x5A827999 + (b & c | ~b & d);
            e = d;
            d = c;
            c = b << 30 | b >>> 2;
            b = a;
            a = t & 0xffffffff;
        }
        for (k = 20; k < 40; k++) {
            t = (a << 5 | a >>> 27) + e + _shaw[k] + 0x6ED9EBA1 + (b ^ c ^ d);
            e = d;
            d = c;
            c = b << 30 | b >>> 2;
            b = a;
            a = t & 0xffffffff;
        }
        for (k = 40; k < 60; k++) {
            t = (a << 5 | a >>> 27) + e + _shaw[k] + 0x8F1BBCDC + (b & c | b & d | c & d);
            e = d;
            d = c;
            c = b << 30 | b >>> 2;
            b = a;
            a = t & 0xffffffff;
        }
        for (k = 60; k < 80; k++) {
            t = (a << 5 | a >>> 27) + e + _shaw[k] + 0xCA62C1D6 + (b ^ c ^ d);
            e = d;
            d = c;
            c = b << 30 | b >>> 2;
            b = a;
            a = t & 0xffffffff;
        }
        _shaw[0] = s[0] + a & 0xffffffff;
        _shaw[1] = s[1] + b & 0xffffffff;
        _shaw[2] = s[2] + c & 0xffffffff;
        _shaw[3] = s[3] + d & 0xffffffff;
        _shaw[4] = s[4] + e & 0xffffffff;
    }

    /**
     * Compute the WPA Preshared key for a given SSID and passphrase
     *
     * @param ssid {string} : the access point SSID
     * @param pass {string} : the access point WPA/WPA2 passphrase
     *
     * @return {string} an hexadecimal string for the preshared key
     */
    ComputePSK(ssid, pass) {
        var _this174 = this;

        return _asyncToGenerator(function* () {
            var sha1_init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
            var inner = [],
                outer = [],
                shau = [],
                res = [];
            var iter, pos, k, _shaw;

            // precompute part of sha used in the loops
            _shaw = new Array(80);
            _this174.imm_initshaw(pass, 0, 0x3636, _shaw);
            _this174.imm_itershaw(sha1_init, _shaw);
            for (k = 0; k < 5; k++) inner[k] = _shaw[k];
            _shaw = new Array(80);
            _this174.imm_initshaw(pass, 0, 0x5c5c, _shaw);
            _this174.imm_itershaw(sha1_init, _shaw);
            for (k = 0; k < 5; k++) outer[k] = _shaw[k];

            // prepare to compute first 20 bytes
            pos = 0;
            for (k = 0; k < 5; k++) shau[k] = 0;
            _shaw = new Array(80);
            _this174.imm_initshaw(ssid, 1, 0, _shaw);

            for (iter = 0; iter < 8192;) {
                _this174.imm_itershaw(inner, _shaw);
                _shaw[5] = 0x80000000;
                for (k = 6; k < 15; k++) {
                    _shaw[k] = 0;
                }
                _shaw[15] = 8 * (64 + 20);
                _this174.imm_itershaw(outer, _shaw);
                shau[0] ^= _shaw[0];
                shau[1] ^= _shaw[1];
                shau[2] ^= _shaw[2];
                shau[3] ^= _shaw[3];
                shau[4] ^= _shaw[4];
                iter++;
                // after 4096 loops, move to 2nd half of sha1
                if ((iter & 4095) == 0) {
                    for (k = 0; k < 5 && pos < 32; k++) {
                        res[pos++] = shau[k] >>> 24 & 0xff;
                        res[pos++] = shau[k] >>> 16 & 0xff;
                        res[pos++] = shau[k] >>> 8 & 0xff;
                        res[pos++] = shau[k] & 0xff;
                    }
                    if (iter == 4096) {
                        for (k = 0; k < 5; k++) shau[k] = 0;
                        _shaw = new Array(80);
                        _this174.imm_initshaw(ssid, 2, 0, _shaw);
                    }
                }
            }
            var hex = '';
            for (k = 0; k < 32; k++) {
                hex += ('0' + Number(res[k]).toString(16)).slice(-2);
            }
            return hex;
        })();
    }
}

exports.YAPIContext = YAPIContext;
var YAPI = exports.YAPI = new YAPIContext();

// Standard value calibration handler (n-point linear error correction)
//
var yLinearCalibrationHandler = exports.yLinearCalibrationHandler = YAPI.LinearCalibrationHandler;

/**
 * Returns the version identifier for the Yoctopuce library in use.
 * The version is a string in the form "Major.Minor.Build",
 * for instance "1.01.5535". For languages using an external
 * DLL (for instance C#, VisualBasic or Delphi), the character string
 * includes as well the DLL version, for instance
 * "1.01.5535 (1.01.5439)".
 *
 * If you want to verify in your code that the library version is
 * compatible with the version that you have used during development,
 * verify that the major number is strictly equal and that the minor
 * number is greater or equal. The build number is not relevant
 * with respect to the library compatibility.
 *
 * @return {string} a character string describing the library version.
 */
function yGetAPIVersion() {
    return YAPI.GetAPIVersion();
}

/**
 * Initializes the Yoctopuce programming library explicitly.
 * It is not strictly needed to call yInitAPI(), as the library is
 * automatically  initialized when calling yRegisterHub() for the
 * first time.
 *
 * When YAPI.DETECT_NONE is used as detection mode,
 * you must explicitly use yRegisterHub() to point the API to the
 * VirtualHub on which your devices are connected before trying to access them.
 *
 * @param mode {number} : an integer corresponding to the type of automatic
 *         device detection to use. Possible values are
 *         YAPI.DETECT_NONE, YAPI.DETECT_USB, YAPI.DETECT_NET,
 *         and YAPI.DETECT_ALL.
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function yInitAPI(mode, errmsg) {
    return YAPI.InitAPI(mode, errmsg);
}

/**
 * Frees dynamically allocated memory blocks used by the Yoctopuce library.
 * It is generally not required to call this function, unless you
 * want to free all dynamically allocated memory blocks in order to
 * track a memory leak for instance.
 * You should not call any other library function after calling
 * yFreeAPI(), or your program will crash.
 */
function yFreeAPI() {
    YAPI.FreeAPI();
}

/**
 * Disables the use of exceptions to report runtime errors.
 * When exceptions are disabled, every function returns a specific
 * error value which depends on its type and which is documented in
 * this reference manual.
 */
function yDisableExceptions() {
    YAPI.DisableExceptions();
}

/**
 * Re-enables the use of exceptions for runtime error handling.
 * Be aware than when exceptions are enabled, every function that fails
 * triggers an exception. If the exception is not caught by the user code,
 * it  either fires the debugger or aborts (i.e. crash) the program.
 * On failure, throws an exception or returns a negative error code.
 */
function yEnableExceptions() {
    YAPI.EnableExceptions();
}

/**
 * Setup the Yoctopuce library to use modules connected on a given machine. The
 * parameter will determine how the API will work. Use the following values:
 *
 * <b>usb</b>: When the usb keyword is used, the API will work with
 * devices connected directly to the USB bus. Some programming languages such a Javascript,
 * PHP, and Java don't provide direct access to USB hardware, so usb will
 * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
 *
 * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
 * host with the given IP address or hostname. That host can be a regular computer
 * running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or
 * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
 * computer, use the IP address 127.0.0.1.
 *
 * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
 * This a special mode allowing to take control of Yoctopuce devices
 * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
 * need to configure your hub to call your server script on a regular basis.
 * This mode is currently available for PHP and Node.JS only.
 *
 * Be aware that only one application can use direct USB access at a
 * given time on a machine. Multiple access would cause conflicts
 * while trying to access the USB modules. In particular, this means
 * that you must stop the VirtualHub software before starting
 * an application that uses direct USB access. The workaround
 * for this limitation is to setup the library to use the VirtualHub
 * rather than direct USB access.
 *
 * If access control has been activated on the hub, virtual or not, you want to
 * reach, the URL parameter should look like:
 *
 * http://username:password@address:port
 *
 * You can call <i>RegisterHub</i> several times to connect to several machines.
 *
 * @param url {string} : a string containing either "usb","callback" or the
 *         root URL of the hub to monitor
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function yRegisterHub(url, errmsg) {
    return YAPI.RegisterHub(url, errmsg);
}

/**
 * Fault-tolerant alternative to RegisterHub(). This function has the same
 * purpose and same arguments as RegisterHub(), but does not trigger
 * an error when the selected hub is not available at the time of the function call.
 * This makes it possible to register a network hub independently of the current
 * connectivity, and to try to contact it only when a device is actively needed.
 *
 * @param url {string} : a string containing either "usb","callback" or the
 *         root URL of the hub to monitor
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function yPreregisterHub(url, errmsg) {
    return YAPI.PreregisterHub(url, errmsg);
}

/**
 * Setup the Yoctopuce library to no more use modules connected on a previously
 * registered machine with RegisterHub.
 *
 * @param url {string} : a string containing either "usb" or the
 *         root URL of the hub to monitor
 */
function yUnregisterHub(url) {
    YAPI.UnregisterHub(url);
}

/**
 * Triggers a (re)detection of connected Yoctopuce modules.
 * The library searches the machines or USB ports previously registered using
 * yRegisterHub(), and invokes any user-defined callback function
 * in case a change in the list of connected devices is detected.
 *
 * This function can be called as frequently as desired to refresh the device list
 * and to make the application aware of hot-plug events.
 *
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function yUpdateDeviceList(errmsg) {
    return YAPI.UpdateDeviceList(errmsg);
}

/**
 * Maintains the device-to-library communication channel.
 * If your program includes significant loops, you may want to include
 * a call to this function to make sure that the library takes care of
 * the information pushed by the modules on the communication channels.
 * This is not strictly necessary, but it may improve the reactivity
 * of the library for the following commands.
 *
 * This function may signal an error in case there is a communication problem
 * while contacting a module.
 *
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function yHandleEvents(errmsg) {
    return YAPI.HandleEvents(errmsg);
}

/**
 * Pauses the execution flow for a specified duration.
 * This function implements a passive waiting loop, meaning that it does not
 * consume CPU cycles significantly. The processor is left available for
 * other threads and processes. During the pause, the library nevertheless
 * reads from time to time information from the Yoctopuce modules by
 * calling yHandleEvents(), in order to stay up-to-date.
 *
 * This function may signal an error in case there is a communication problem
 * while contacting a module.
 *
 * @param ms_duration {number} : an integer corresponding to the duration of the pause,
 *         in milliseconds.
 * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
 *
 * @return {number} YAPI.SUCCESS when the call succeeds.
 *
 * On failure, throws an exception or returns a negative error code.
 */
function ySleep(ms_duration, errmsg) {
    return YAPI.Sleep(ms_duration, errmsg);
}

/**
 * Returns the current value of a monotone millisecond-based time counter.
 * This counter can be used to compute delays in relation with
 * Yoctopuce devices, which also uses the millisecond as timebase.
 *
 * @return a long integer corresponding to the millisecond counter.
 */
function yGetTickCount() {
    return YAPI.GetTickCount();
}

/**
 * Checks if a given string is valid as logical name for a module or a function.
 * A valid logical name has a maximum of 19 characters, all among
 * A..Z, a..z, 0..9, _, and -.
 * If you try to configure a logical name with an incorrect string,
 * the invalid characters are ignored.
 *
 * @param name {string} : a string containing the name to check.
 *
 * @return {boolean} true if the name is valid, false otherwise.
 */
function yCheckLogicalName(name) {
    return YAPI.CheckLogicalName(name);
}

/**
 * Register a callback function, to be called each time
 * a device is plugged. This callback will be invoked while yUpdateDeviceList
 * is running. You will have to call this function on a regular basis.
 *
 * @param arrivalCallback {DeviceArrivalCallback} : a procedure taking a YModule parameter, or null
 *         to unregister a previously registered  callback.
 */
function yRegisterDeviceArrivalCallback(arrivalCallback) {
    return YAPI.RegisterDeviceArrivalCallback(arrivalCallback);
}

function yRegisterDeviceChangeCallback(changeCallback) {
    return YAPI.RegisterDeviceChangeCallback(changeCallback);
}

/**
 * Register a callback function, to be called each time
 * a device is unplugged. This callback will be invoked while yUpdateDeviceList
 * is running. You will have to call this function on a regular basis.
 *
 * @param removalCallback {DeviceRemovalCallback} : a procedure taking a YModule parameter, or null
 *         to unregister a previously registered  callback.
 */
function yRegisterDeviceRemovalCallback(removalCallback) {
    return YAPI.RegisterDeviceRemovalCallback(removalCallback);
}

// Register a new value calibration handler for a given calibration type
//
function yRegisterCalibrationHandler(calibrationType, calibrationHandler) {
    return YAPI.RegisterCalibrationHandler(calibrationType, calibrationHandler);
}
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for AudioIn functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YAudioIn = exports.Y_NOSIGNALFOR_INVALID = exports.Y_SIGNAL_INVALID = exports.Y_VOLUMERANGE_INVALID = exports.Y_VOLUME_INVALID = exports.Y_MUTE_INVALID = exports.Y_MUTE_TRUE = exports.Y_MUTE_FALSE = undefined;
exports.yFindAudioIn = yFindAudioIn;
exports.yFirstAudioIn = yFirstAudioIn;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YAudioIn return codes)
//--- (end of YAudioIn return codes)
//--- (YAudioIn definitions)
const Y_MUTE_FALSE = exports.Y_MUTE_FALSE = 0;
const Y_MUTE_TRUE = exports.Y_MUTE_TRUE = 1;
const Y_MUTE_INVALID = exports.Y_MUTE_INVALID = -1;
const Y_VOLUME_INVALID = exports.Y_VOLUME_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_VOLUMERANGE_INVALID = exports.Y_VOLUMERANGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SIGNAL_INVALID = exports.Y_SIGNAL_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_NOSIGNALFOR_INVALID = exports.Y_NOSIGNALFOR_INVALID = _yocto_api.YAPI.INVALID_INT;
//--- (end of YAudioIn definitions)

//--- (YAudioIn class start)
/**
 * YAudioIn Class: AudioIn function interface
 *
 * The Yoctopuce application programming interface allows you to configure the volume of the input channel.
 */
//--- (end of YAudioIn class start)

class YAudioIn extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YAudioIn constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'AudioIn';
        /** @member {number} **/
        this._volume = Y_VOLUME_INVALID;
        /** @member {number} **/
        this._mute = Y_MUTE_INVALID;
        /** @member {string} **/
        this._volumeRange = Y_VOLUMERANGE_INVALID;
        /** @member {number} **/
        this._signal = Y_SIGNAL_INVALID;
        /** @member {number} **/
        this._noSignalFor = Y_NOSIGNALFOR_INVALID;
        this.imm_setConst({
            VOLUME_INVALID: _yocto_api.YAPI.INVALID_UINT,
            MUTE_FALSE: 0,
            MUTE_TRUE: 1,
            MUTE_INVALID: -1,
            VOLUMERANGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SIGNAL_INVALID: _yocto_api.YAPI.INVALID_INT,
            NOSIGNALFOR_INVALID: _yocto_api.YAPI.INVALID_INT
        });
        //--- (end of YAudioIn constructor)
    }

    //--- (YAudioIn implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'volume':
                this._volume = parseInt(val);
                return 1;
            case 'mute':
                this._mute = parseInt(val);
                return 1;
            case 'volumeRange':
                this._volumeRange = val;
                return 1;
            case 'signal':
                this._signal = parseInt(val);
                return 1;
            case 'noSignalFor':
                this._noSignalFor = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns audio input gain, in per cents.
     *
     * @return {number} an integer corresponding to audio input gain, in per cents
     *
     * On failure, throws an exception or returns YAudioIn.VOLUME_INVALID.
     */
    get_volume() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUME_INVALID;
                }
            }
            return _this._volume;
        })();
    }

    /**
     * Changes audio input gain, in per cents.
     *
     * @param newval {number} : an integer corresponding to audio input gain, in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_volume(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('volume', rest_val);
        })();
    }

    /**
     * Returns the state of the mute function.
     *
     * @return {number} either YAudioIn.MUTE_FALSE or YAudioIn.MUTE_TRUE, according to the state of the mute function
     *
     * On failure, throws an exception or returns YAudioIn.MUTE_INVALID.
     */
    get_mute() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MUTE_INVALID;
                }
            }
            return _this3._mute;
        })();
    }

    /**
     * Changes the state of the mute function. Remember to call the matching module
     * saveToFlash() method to save the setting permanently.
     *
     * @param newval {number} : either YAudioIn.MUTE_FALSE or YAudioIn.MUTE_TRUE, according to the state
     * of the mute function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_mute(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('mute', rest_val);
        })();
    }

    /**
     * Returns the supported volume range. The low value of the
     * range corresponds to the minimal audible value. To
     * completely mute the sound, use set_mute()
     * instead of the set_volume().
     *
     * @return {string} a string corresponding to the supported volume range
     *
     * On failure, throws an exception or returns YAudioIn.VOLUMERANGE_INVALID.
     */
    get_volumeRange() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUMERANGE_INVALID;
                }
            }
            return _this5._volumeRange;
        })();
    }

    /**
     * Returns the detected input signal level.
     *
     * @return {number} an integer corresponding to the detected input signal level
     *
     * On failure, throws an exception or returns YAudioIn.SIGNAL_INVALID.
     */
    get_signal() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNAL_INVALID;
                }
            }
            return _this6._signal;
        })();
    }

    /**
     * Returns the number of seconds elapsed without detecting a signal
     *
     * @return {number} an integer corresponding to the number of seconds elapsed without detecting a signal
     *
     * On failure, throws an exception or returns YAudioIn.NOSIGNALFOR_INVALID.
     */
    get_noSignalFor() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NOSIGNALFOR_INVALID;
                }
            }
            return _this7._noSignalFor;
        })();
    }

    /**
     * Retrieves an audio input for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the audio input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAudioIn.isOnline() to test if the audio input is
     * indeed online at a given time. In case of ambiguity when looking for
     * an audio input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the audio input
     *
     * @return {YAudioIn} a YAudioIn object allowing you to drive the audio input.
     */
    static FindAudioIn(func) {
        /** @type {YAudioIn} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('AudioIn', func);
        if (obj == null) {
            obj = new YAudioIn(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('AudioIn', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an audio input for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the audio input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAudioIn.isOnline() to test if the audio input is
     * indeed online at a given time. In case of ambiguity when looking for
     * an audio input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the audio input
     *
     * @return {YAudioIn} a YAudioIn object allowing you to drive the audio input.
     */
    static FindAudioInInContext(yctx, func) {
        /** @type {YAudioIn} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'AudioIn', func);
        if (obj == null) {
            obj = new YAudioIn(yctx, func);
            _yocto_api.YFunction._AddToCache('AudioIn', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of audio inputs started using yFirstAudioIn().
     *
     * @return {YAudioIn} a pointer to a YAudioIn object, corresponding to
     *         an audio input currently online, or a null pointer
     *         if there are no more audio inputs to enumerate.
     */
    /* */nextAudioIn() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YAudioIn.FindAudioInInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of audio inputs currently accessible.
     * Use the method YAudioIn.nextAudioIn() to iterate on
     * next audio inputs.
     *
     * @return {YAudioIn} a pointer to a YAudioIn object, corresponding to
     *         the first audio input currently online, or a null pointer
     *         if there are none.
     */
    static FirstAudioIn() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('AudioIn');
        if (next_hwid == null) return null;
        return YAudioIn.FindAudioIn(next_hwid);
    }

    /**
     * Starts the enumeration of audio inputs currently accessible.
     * Use the method YAudioIn.nextAudioIn() to iterate on
     * next audio inputs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YAudioIn} a pointer to a YAudioIn object, corresponding to
     *         the first audio input currently online, or a null pointer
     *         if there are none.
     */
    static FirstAudioInInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('AudioIn');
        if (next_hwid == null) return null;
        return YAudioIn.FindAudioInInContext(yctx, next_hwid);
    }

    //--- (end of YAudioIn implementation)
}

exports.YAudioIn = YAudioIn; //--- (AudioIn functions)

/**
 * comment from .yc definition
 */

function yFindAudioIn(func) {
    return YAudioIn.FindAudioIn(func);
}

/**
 * comment from .yc definition
 */
function yFirstAudioIn() {
    return YAudioIn.FirstAudioIn();
}

//--- (end of AudioIn functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for AudioOut functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YAudioOut = exports.Y_NOSIGNALFOR_INVALID = exports.Y_SIGNAL_INVALID = exports.Y_VOLUMERANGE_INVALID = exports.Y_VOLUME_INVALID = exports.Y_MUTE_INVALID = exports.Y_MUTE_TRUE = exports.Y_MUTE_FALSE = undefined;
exports.yFindAudioOut = yFindAudioOut;
exports.yFirstAudioOut = yFirstAudioOut;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YAudioOut return codes)
//--- (end of YAudioOut return codes)
//--- (YAudioOut definitions)
const Y_MUTE_FALSE = exports.Y_MUTE_FALSE = 0;
const Y_MUTE_TRUE = exports.Y_MUTE_TRUE = 1;
const Y_MUTE_INVALID = exports.Y_MUTE_INVALID = -1;
const Y_VOLUME_INVALID = exports.Y_VOLUME_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_VOLUMERANGE_INVALID = exports.Y_VOLUMERANGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SIGNAL_INVALID = exports.Y_SIGNAL_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_NOSIGNALFOR_INVALID = exports.Y_NOSIGNALFOR_INVALID = _yocto_api.YAPI.INVALID_INT;
//--- (end of YAudioOut definitions)

//--- (YAudioOut class start)
/**
 * YAudioOut Class: AudioOut function interface
 *
 * The Yoctopuce application programming interface allows you to configure the volume of the outout.
 */
//--- (end of YAudioOut class start)

class YAudioOut extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YAudioOut constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'AudioOut';
        /** @member {number} **/
        this._volume = Y_VOLUME_INVALID;
        /** @member {number} **/
        this._mute = Y_MUTE_INVALID;
        /** @member {string} **/
        this._volumeRange = Y_VOLUMERANGE_INVALID;
        /** @member {number} **/
        this._signal = Y_SIGNAL_INVALID;
        /** @member {number} **/
        this._noSignalFor = Y_NOSIGNALFOR_INVALID;
        this.imm_setConst({
            VOLUME_INVALID: _yocto_api.YAPI.INVALID_UINT,
            MUTE_FALSE: 0,
            MUTE_TRUE: 1,
            MUTE_INVALID: -1,
            VOLUMERANGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SIGNAL_INVALID: _yocto_api.YAPI.INVALID_INT,
            NOSIGNALFOR_INVALID: _yocto_api.YAPI.INVALID_INT
        });
        //--- (end of YAudioOut constructor)
    }

    //--- (YAudioOut implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'volume':
                this._volume = parseInt(val);
                return 1;
            case 'mute':
                this._mute = parseInt(val);
                return 1;
            case 'volumeRange':
                this._volumeRange = val;
                return 1;
            case 'signal':
                this._signal = parseInt(val);
                return 1;
            case 'noSignalFor':
                this._noSignalFor = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns audio output volume, in per cents.
     *
     * @return {number} an integer corresponding to audio output volume, in per cents
     *
     * On failure, throws an exception or returns YAudioOut.VOLUME_INVALID.
     */
    get_volume() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUME_INVALID;
                }
            }
            return _this._volume;
        })();
    }

    /**
     * Changes audio output volume, in per cents.
     *
     * @param newval {number} : an integer corresponding to audio output volume, in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_volume(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('volume', rest_val);
        })();
    }

    /**
     * Returns the state of the mute function.
     *
     * @return {number} either YAudioOut.MUTE_FALSE or YAudioOut.MUTE_TRUE, according to the state of the mute function
     *
     * On failure, throws an exception or returns YAudioOut.MUTE_INVALID.
     */
    get_mute() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MUTE_INVALID;
                }
            }
            return _this3._mute;
        })();
    }

    /**
     * Changes the state of the mute function. Remember to call the matching module
     * saveToFlash() method to save the setting permanently.
     *
     * @param newval {number} : either YAudioOut.MUTE_FALSE or YAudioOut.MUTE_TRUE, according to the state
     * of the mute function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_mute(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('mute', rest_val);
        })();
    }

    /**
     * Returns the supported volume range. The low value of the
     * range corresponds to the minimal audible value. To
     * completely mute the sound, use set_mute()
     * instead of the set_volume().
     *
     * @return {string} a string corresponding to the supported volume range
     *
     * On failure, throws an exception or returns YAudioOut.VOLUMERANGE_INVALID.
     */
    get_volumeRange() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUMERANGE_INVALID;
                }
            }
            return _this5._volumeRange;
        })();
    }

    /**
     * Returns the detected output current level.
     *
     * @return {number} an integer corresponding to the detected output current level
     *
     * On failure, throws an exception or returns YAudioOut.SIGNAL_INVALID.
     */
    get_signal() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNAL_INVALID;
                }
            }
            return _this6._signal;
        })();
    }

    /**
     * Returns the number of seconds elapsed without detecting a signal
     *
     * @return {number} an integer corresponding to the number of seconds elapsed without detecting a signal
     *
     * On failure, throws an exception or returns YAudioOut.NOSIGNALFOR_INVALID.
     */
    get_noSignalFor() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NOSIGNALFOR_INVALID;
                }
            }
            return _this7._noSignalFor;
        })();
    }

    /**
     * Retrieves an audio output for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the audio output is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAudioOut.isOnline() to test if the audio output is
     * indeed online at a given time. In case of ambiguity when looking for
     * an audio output by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the audio output
     *
     * @return {YAudioOut} a YAudioOut object allowing you to drive the audio output.
     */
    static FindAudioOut(func) {
        /** @type {YAudioOut} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('AudioOut', func);
        if (obj == null) {
            obj = new YAudioOut(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('AudioOut', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an audio output for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the audio output is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YAudioOut.isOnline() to test if the audio output is
     * indeed online at a given time. In case of ambiguity when looking for
     * an audio output by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the audio output
     *
     * @return {YAudioOut} a YAudioOut object allowing you to drive the audio output.
     */
    static FindAudioOutInContext(yctx, func) {
        /** @type {YAudioOut} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'AudioOut', func);
        if (obj == null) {
            obj = new YAudioOut(yctx, func);
            _yocto_api.YFunction._AddToCache('AudioOut', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of audio outputs started using yFirstAudioOut().
     *
     * @return {YAudioOut} a pointer to a YAudioOut object, corresponding to
     *         an audio output currently online, or a null pointer
     *         if there are no more audio outputs to enumerate.
     */
    /* */nextAudioOut() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YAudioOut.FindAudioOutInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of audio outputs currently accessible.
     * Use the method YAudioOut.nextAudioOut() to iterate on
     * next audio outputs.
     *
     * @return {YAudioOut} a pointer to a YAudioOut object, corresponding to
     *         the first audio output currently online, or a null pointer
     *         if there are none.
     */
    static FirstAudioOut() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('AudioOut');
        if (next_hwid == null) return null;
        return YAudioOut.FindAudioOut(next_hwid);
    }

    /**
     * Starts the enumeration of audio outputs currently accessible.
     * Use the method YAudioOut.nextAudioOut() to iterate on
     * next audio outputs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YAudioOut} a pointer to a YAudioOut object, corresponding to
     *         the first audio output currently online, or a null pointer
     *         if there are none.
     */
    static FirstAudioOutInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('AudioOut');
        if (next_hwid == null) return null;
        return YAudioOut.FindAudioOutInContext(yctx, next_hwid);
    }

    //--- (end of YAudioOut implementation)
}

exports.YAudioOut = YAudioOut; //--- (AudioOut functions)

/**
 * comment from .yc definition
 */

function yFindAudioOut(func) {
    return YAudioOut.FindAudioOut(func);
}

/**
 * comment from .yc definition
 */
function yFirstAudioOut() {
    return YAudioOut.FirstAudioOut();
}

//--- (end of AudioOut functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for BluetoothLink functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YBluetoothLink = exports.Y_COMMAND_INVALID = exports.Y_LINKQUALITY_INVALID = exports.Y_VOLUME_INVALID = exports.Y_PREAMPLIFIER_INVALID = exports.Y_REMOTENAME_INVALID = exports.Y_REMOTEADDRESS_INVALID = exports.Y_PAIRINGPIN_INVALID = exports.Y_OWNADDRESS_INVALID = exports.Y_LINKSTATE_INVALID = exports.Y_LINKSTATE_PLAY = exports.Y_LINKSTATE_LINKED = exports.Y_LINKSTATE_EXISTS = exports.Y_LINKSTATE_SEARCH = exports.Y_LINKSTATE_FREE = exports.Y_LINKSTATE_DOWN = exports.Y_MUTE_INVALID = exports.Y_MUTE_TRUE = exports.Y_MUTE_FALSE = undefined;
exports.yFindBluetoothLink = yFindBluetoothLink;
exports.yFirstBluetoothLink = yFirstBluetoothLink;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YBluetoothLink return codes)
//--- (end of YBluetoothLink return codes)
//--- (YBluetoothLink definitions)
const Y_MUTE_FALSE = exports.Y_MUTE_FALSE = 0;
const Y_MUTE_TRUE = exports.Y_MUTE_TRUE = 1;
const Y_MUTE_INVALID = exports.Y_MUTE_INVALID = -1;
const Y_LINKSTATE_DOWN = exports.Y_LINKSTATE_DOWN = 0;
const Y_LINKSTATE_FREE = exports.Y_LINKSTATE_FREE = 1;
const Y_LINKSTATE_SEARCH = exports.Y_LINKSTATE_SEARCH = 2;
const Y_LINKSTATE_EXISTS = exports.Y_LINKSTATE_EXISTS = 3;
const Y_LINKSTATE_LINKED = exports.Y_LINKSTATE_LINKED = 4;
const Y_LINKSTATE_PLAY = exports.Y_LINKSTATE_PLAY = 5;
const Y_LINKSTATE_INVALID = exports.Y_LINKSTATE_INVALID = -1;
const Y_OWNADDRESS_INVALID = exports.Y_OWNADDRESS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_PAIRINGPIN_INVALID = exports.Y_PAIRINGPIN_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_REMOTEADDRESS_INVALID = exports.Y_REMOTEADDRESS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_REMOTENAME_INVALID = exports.Y_REMOTENAME_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_PREAMPLIFIER_INVALID = exports.Y_PREAMPLIFIER_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_VOLUME_INVALID = exports.Y_VOLUME_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LINKQUALITY_INVALID = exports.Y_LINKQUALITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YBluetoothLink definitions)

//--- (YBluetoothLink class start)
/**
 * YBluetoothLink Class: BluetoothLink function interface
 *
 * BluetoothLink function provides control over bluetooth link
 * and status for devices that are bluetooth-enabled.
 */
//--- (end of YBluetoothLink class start)

class YBluetoothLink extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YBluetoothLink constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'BluetoothLink';
        /** @member {string} **/
        this._ownAddress = Y_OWNADDRESS_INVALID;
        /** @member {string} **/
        this._pairingPin = Y_PAIRINGPIN_INVALID;
        /** @member {string} **/
        this._remoteAddress = Y_REMOTEADDRESS_INVALID;
        /** @member {string} **/
        this._remoteName = Y_REMOTENAME_INVALID;
        /** @member {number} **/
        this._mute = Y_MUTE_INVALID;
        /** @member {number} **/
        this._preAmplifier = Y_PREAMPLIFIER_INVALID;
        /** @member {number} **/
        this._volume = Y_VOLUME_INVALID;
        /** @member {number} **/
        this._linkState = Y_LINKSTATE_INVALID;
        /** @member {number} **/
        this._linkQuality = Y_LINKQUALITY_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            OWNADDRESS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            PAIRINGPIN_INVALID: _yocto_api.YAPI.INVALID_STRING,
            REMOTEADDRESS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            REMOTENAME_INVALID: _yocto_api.YAPI.INVALID_STRING,
            MUTE_FALSE: 0,
            MUTE_TRUE: 1,
            MUTE_INVALID: -1,
            PREAMPLIFIER_INVALID: _yocto_api.YAPI.INVALID_UINT,
            VOLUME_INVALID: _yocto_api.YAPI.INVALID_UINT,
            LINKSTATE_DOWN: 0,
            LINKSTATE_FREE: 1,
            LINKSTATE_SEARCH: 2,
            LINKSTATE_EXISTS: 3,
            LINKSTATE_LINKED: 4,
            LINKSTATE_PLAY: 5,
            LINKSTATE_INVALID: -1,
            LINKQUALITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YBluetoothLink constructor)
    }

    //--- (YBluetoothLink implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'ownAddress':
                this._ownAddress = val;
                return 1;
            case 'pairingPin':
                this._pairingPin = val;
                return 1;
            case 'remoteAddress':
                this._remoteAddress = val;
                return 1;
            case 'remoteName':
                this._remoteName = val;
                return 1;
            case 'mute':
                this._mute = parseInt(val);
                return 1;
            case 'preAmplifier':
                this._preAmplifier = parseInt(val);
                return 1;
            case 'volume':
                this._volume = parseInt(val);
                return 1;
            case 'linkState':
                this._linkState = parseInt(val);
                return 1;
            case 'linkQuality':
                this._linkQuality = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.
     *
     * @return {string} a string corresponding to the MAC-48 address of the bluetooth interface, which is
     * unique on the bluetooth network
     *
     * On failure, throws an exception or returns YBluetoothLink.OWNADDRESS_INVALID.
     */
    get_ownAddress() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_OWNADDRESS_INVALID;
                }
            }
            return _this._ownAddress;
        })();
    }

    /**
     * Returns an opaque string if a PIN code has been configured in the device to access
     * the SIM card, or an empty string if none has been configured or if the code provided
     * was rejected by the SIM card.
     *
     * @return {string} a string corresponding to an opaque string if a PIN code has been configured in
     * the device to access
     *         the SIM card, or an empty string if none has been configured or if the code provided
     *         was rejected by the SIM card
     *
     * On failure, throws an exception or returns YBluetoothLink.PAIRINGPIN_INVALID.
     */
    get_pairingPin() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PAIRINGPIN_INVALID;
                }
            }
            return _this2._pairingPin;
        })();
    }

    /**
     * Changes the PIN code used by the module for bluetooth pairing.
     * Remember to call the saveToFlash() method of the module to save the
     * new value in the device flash.
     *
     * @param newval {string} : a string corresponding to the PIN code used by the module for bluetooth pairing
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_pairingPin(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this3._setAttr('pairingPin', rest_val);
        })();
    }

    /**
     * Returns the MAC-48 address of the remote device to connect to.
     *
     * @return {string} a string corresponding to the MAC-48 address of the remote device to connect to
     *
     * On failure, throws an exception or returns YBluetoothLink.REMOTEADDRESS_INVALID.
     */
    get_remoteAddress() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_REMOTEADDRESS_INVALID;
                }
            }
            return _this4._remoteAddress;
        })();
    }

    /**
     * Changes the MAC-48 address defining which remote device to connect to.
     *
     * @param newval {string} : a string corresponding to the MAC-48 address defining which remote device to connect to
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_remoteAddress(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this5._setAttr('remoteAddress', rest_val);
        })();
    }

    /**
     * Returns the bluetooth name the remote device, if found on the bluetooth network.
     *
     * @return {string} a string corresponding to the bluetooth name the remote device, if found on the
     * bluetooth network
     *
     * On failure, throws an exception or returns YBluetoothLink.REMOTENAME_INVALID.
     */
    get_remoteName() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_REMOTENAME_INVALID;
                }
            }
            return _this6._remoteName;
        })();
    }

    /**
     * Returns the state of the mute function.
     *
     * @return {number} either YBluetoothLink.MUTE_FALSE or YBluetoothLink.MUTE_TRUE, according to the
     * state of the mute function
     *
     * On failure, throws an exception or returns YBluetoothLink.MUTE_INVALID.
     */
    get_mute() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MUTE_INVALID;
                }
            }
            return _this7._mute;
        })();
    }

    /**
     * Changes the state of the mute function. Remember to call the matching module
     * saveToFlash() method to save the setting permanently.
     *
     * @param newval {number} : either YBluetoothLink.MUTE_FALSE or YBluetoothLink.MUTE_TRUE, according to
     * the state of the mute function
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_mute(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('mute', rest_val);
        })();
    }

    /**
     * Returns the audio pre-amplifier volume, in per cents.
     *
     * @return {number} an integer corresponding to the audio pre-amplifier volume, in per cents
     *
     * On failure, throws an exception or returns YBluetoothLink.PREAMPLIFIER_INVALID.
     */
    get_preAmplifier() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PREAMPLIFIER_INVALID;
                }
            }
            return _this9._preAmplifier;
        })();
    }

    /**
     * Changes the audio pre-amplifier volume, in per cents.
     *
     * @param newval {number} : an integer corresponding to the audio pre-amplifier volume, in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_preAmplifier(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('preAmplifier', rest_val);
        })();
    }

    /**
     * Returns the connected headset volume, in per cents.
     *
     * @return {number} an integer corresponding to the connected headset volume, in per cents
     *
     * On failure, throws an exception or returns YBluetoothLink.VOLUME_INVALID.
     */
    get_volume() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUME_INVALID;
                }
            }
            return _this11._volume;
        })();
    }

    /**
     * Changes the connected headset volume, in per cents.
     *
     * @param newval {number} : an integer corresponding to the connected headset volume, in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_volume(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this12._setAttr('volume', rest_val);
        })();
    }

    /**
     * Returns the bluetooth link state.
     *
     * @return {number} a value among YBluetoothLink.LINKSTATE_DOWN, YBluetoothLink.LINKSTATE_FREE,
     * YBluetoothLink.LINKSTATE_SEARCH, YBluetoothLink.LINKSTATE_EXISTS, YBluetoothLink.LINKSTATE_LINKED
     * and YBluetoothLink.LINKSTATE_PLAY corresponding to the bluetooth link state
     *
     * On failure, throws an exception or returns YBluetoothLink.LINKSTATE_INVALID.
     */
    get_linkState() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LINKSTATE_INVALID;
                }
            }
            return _this13._linkState;
        })();
    }

    /**
     * Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.
     *
     * @return {number} an integer corresponding to the bluetooth receiver signal strength, in pourcents,
     * or 0 if no connection is established
     *
     * On failure, throws an exception or returns YBluetoothLink.LINKQUALITY_INVALID.
     */
    get_linkQuality() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LINKQUALITY_INVALID;
                }
            }
            return _this14._linkQuality;
        })();
    }

    get_command() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this15._command;
        })();
    }

    set_command(newval) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this16._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a cellular interface for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the cellular interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YBluetoothLink.isOnline() to test if the cellular interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a cellular interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the cellular interface
     *
     * @return {YBluetoothLink} a YBluetoothLink object allowing you to drive the cellular interface.
     */
    static FindBluetoothLink(func) {
        /** @type {YBluetoothLink} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('BluetoothLink', func);
        if (obj == null) {
            obj = new YBluetoothLink(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('BluetoothLink', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a cellular interface for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the cellular interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YBluetoothLink.isOnline() to test if the cellular interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a cellular interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the cellular interface
     *
     * @return {YBluetoothLink} a YBluetoothLink object allowing you to drive the cellular interface.
     */
    static FindBluetoothLinkInContext(yctx, func) {
        /** @type {YBluetoothLink} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'BluetoothLink', func);
        if (obj == null) {
            obj = new YBluetoothLink(yctx, func);
            _yocto_api.YFunction._AddToCache('BluetoothLink', func, obj);
        }
        return obj;
    }

    /**
     * Attempt to connect to the previously selected remote device.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    connect() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            return yield _this17.set_command('C');
        })();
    }

    /**
     * Disconnect from the previously selected remote device.
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    disconnect() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            return yield _this18.set_command('D');
        })();
    }

    /**
     * Continues the enumeration of cellular interfaces started using yFirstBluetoothLink().
     *
     * @return {YBluetoothLink} a pointer to a YBluetoothLink object, corresponding to
     *         a cellular interface currently online, or a null pointer
     *         if there are no more cellular interfaces to enumerate.
     */
    /* */nextBluetoothLink() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YBluetoothLink.FindBluetoothLinkInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of cellular interfaces currently accessible.
     * Use the method YBluetoothLink.nextBluetoothLink() to iterate on
     * next cellular interfaces.
     *
     * @return {YBluetoothLink} a pointer to a YBluetoothLink object, corresponding to
     *         the first cellular interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstBluetoothLink() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('BluetoothLink');
        if (next_hwid == null) return null;
        return YBluetoothLink.FindBluetoothLink(next_hwid);
    }

    /**
     * Starts the enumeration of cellular interfaces currently accessible.
     * Use the method YBluetoothLink.nextBluetoothLink() to iterate on
     * next cellular interfaces.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YBluetoothLink} a pointer to a YBluetoothLink object, corresponding to
     *         the first cellular interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstBluetoothLinkInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('BluetoothLink');
        if (next_hwid == null) return null;
        return YBluetoothLink.FindBluetoothLinkInContext(yctx, next_hwid);
    }

    //--- (end of YBluetoothLink implementation)
}

exports.YBluetoothLink = YBluetoothLink; //--- (BluetoothLink functions)

/**
 * comment from .yc definition
 */

function yFindBluetoothLink(func) {
    return YBluetoothLink.FindBluetoothLink(func);
}

/**
 * comment from .yc definition
 */
function yFirstBluetoothLink() {
    return YBluetoothLink.FirstBluetoothLink();
}

//--- (end of BluetoothLink functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Buzzer functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YBuzzer = exports.Y_COMMAND_INVALID = exports.Y_PLAYSEQSIGNATURE_INVALID = exports.Y_PLAYSEQMAXSIZE_INVALID = exports.Y_PLAYSEQSIZE_INVALID = exports.Y_VOLUME_INVALID = exports.Y_FREQUENCY_INVALID = undefined;
exports.yFindBuzzer = yFindBuzzer;
exports.yFirstBuzzer = yFirstBuzzer;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YBuzzer return codes)
//--- (end of YBuzzer return codes)
//--- (YBuzzer definitions)
const Y_FREQUENCY_INVALID = exports.Y_FREQUENCY_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_VOLUME_INVALID = exports.Y_VOLUME_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PLAYSEQSIZE_INVALID = exports.Y_PLAYSEQSIZE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PLAYSEQMAXSIZE_INVALID = exports.Y_PLAYSEQMAXSIZE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PLAYSEQSIGNATURE_INVALID = exports.Y_PLAYSEQSIGNATURE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YBuzzer definitions)

//--- (YBuzzer class start)
/**
 * YBuzzer Class: Buzzer function interface
 *
 * The Yoctopuce application programming interface allows you to
 * choose the frequency and volume at which the buzzer must sound.
 * You can also pre-program a play sequence.
 */
//--- (end of YBuzzer class start)

class YBuzzer extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YBuzzer constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Buzzer';
        /** @member {number} **/
        this._frequency = Y_FREQUENCY_INVALID;
        /** @member {number} **/
        this._volume = Y_VOLUME_INVALID;
        /** @member {number} **/
        this._playSeqSize = Y_PLAYSEQSIZE_INVALID;
        /** @member {number} **/
        this._playSeqMaxSize = Y_PLAYSEQMAXSIZE_INVALID;
        /** @member {number} **/
        this._playSeqSignature = Y_PLAYSEQSIGNATURE_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            FREQUENCY_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            VOLUME_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PLAYSEQSIZE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PLAYSEQMAXSIZE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PLAYSEQSIGNATURE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YBuzzer constructor)
    }

    //--- (YBuzzer implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'frequency':
                this._frequency = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'volume':
                this._volume = parseInt(val);
                return 1;
            case 'playSeqSize':
                this._playSeqSize = parseInt(val);
                return 1;
            case 'playSeqMaxSize':
                this._playSeqMaxSize = parseInt(val);
                return 1;
            case 'playSeqSignature':
                this._playSeqSignature = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.
     *
     * @param newval {number} : a floating point number corresponding to the frequency of the signal sent to the buzzer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_frequency(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this._setAttr('frequency', rest_val);
        })();
    }

    /**
     * Returns the  frequency of the signal sent to the buzzer/speaker.
     *
     * @return {number} a floating point number corresponding to the  frequency of the signal sent to the
     * buzzer/speaker
     *
     * On failure, throws an exception or returns YBuzzer.FREQUENCY_INVALID.
     */
    get_frequency() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FREQUENCY_INVALID;
                }
            }
            return _this2._frequency;
        })();
    }

    /**
     * Returns the volume of the signal sent to the buzzer/speaker.
     *
     * @return {number} an integer corresponding to the volume of the signal sent to the buzzer/speaker
     *
     * On failure, throws an exception or returns YBuzzer.VOLUME_INVALID.
     */
    get_volume() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLUME_INVALID;
                }
            }
            return _this3._volume;
        })();
    }

    /**
     * Changes the volume of the signal sent to the buzzer/speaker.
     *
     * @param newval {number} : an integer corresponding to the volume of the signal sent to the buzzer/speaker
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_volume(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('volume', rest_val);
        })();
    }

    /**
     * Returns the current length of the playing sequence
     *
     * @return {number} an integer corresponding to the current length of the playing sequence
     *
     * On failure, throws an exception or returns YBuzzer.PLAYSEQSIZE_INVALID.
     */
    get_playSeqSize() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PLAYSEQSIZE_INVALID;
                }
            }
            return _this5._playSeqSize;
        })();
    }

    /**
     * Returns the maximum length of the playing sequence
     *
     * @return {number} an integer corresponding to the maximum length of the playing sequence
     *
     * On failure, throws an exception or returns YBuzzer.PLAYSEQMAXSIZE_INVALID.
     */
    get_playSeqMaxSize() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration == 0) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PLAYSEQMAXSIZE_INVALID;
                }
            }
            return _this6._playSeqMaxSize;
        })();
    }

    /**
     * Returns the playing sequence signature. As playing
     * sequences cannot be read from the device, this can be used
     * to detect if a specific playing sequence is already
     * programmed.
     *
     * @return {number} an integer corresponding to the playing sequence signature
     *
     * On failure, throws an exception or returns YBuzzer.PLAYSEQSIGNATURE_INVALID.
     */
    get_playSeqSignature() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PLAYSEQSIGNATURE_INVALID;
                }
            }
            return _this7._playSeqSignature;
        })();
    }

    get_command() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this8._command;
        })();
    }

    set_command(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this9._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a buzzer for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the buzzer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YBuzzer.isOnline() to test if the buzzer is
     * indeed online at a given time. In case of ambiguity when looking for
     * a buzzer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the buzzer
     *
     * @return {YBuzzer} a YBuzzer object allowing you to drive the buzzer.
     */
    static FindBuzzer(func) {
        /** @type {YBuzzer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Buzzer', func);
        if (obj == null) {
            obj = new YBuzzer(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Buzzer', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a buzzer for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the buzzer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YBuzzer.isOnline() to test if the buzzer is
     * indeed online at a given time. In case of ambiguity when looking for
     * a buzzer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the buzzer
     *
     * @return {YBuzzer} a YBuzzer object allowing you to drive the buzzer.
     */
    static FindBuzzerInContext(yctx, func) {
        /** @type {YBuzzer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Buzzer', func);
        if (obj == null) {
            obj = new YBuzzer(yctx, func);
            _yocto_api.YFunction._AddToCache('Buzzer', func, obj);
        }
        return obj;
    }

    sendCommand(command) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            return yield _this10.set_command(command);
        })();
    }

    /**
     * Adds a new frequency transition to the playing sequence.
     *
     * @param freq    : desired frequency when the transition is completed, in Hz
     * @param msDelay {number} : duration of the frequency transition, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    addFreqMoveToPlaySeq(freq, msDelay) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            return yield _this11.sendCommand('A' + String(Math.round(freq)) + ',' + String(Math.round(msDelay)));
        })();
    }

    /**
     * Adds a pulse to the playing sequence.
     *
     * @param freq {number} : pulse frequency, in Hz
     * @param msDuration {number} : pulse duration, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    addPulseToPlaySeq(freq, msDuration) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            return yield _this12.sendCommand('B' + String(Math.round(freq)) + ',' + String(Math.round(msDuration)));
        })();
    }

    /**
     * Adds a new volume transition to the playing sequence. Frequency stays untouched:
     * if frequency is at zero, the transition has no effect.
     *
     * @param volume    : desired volume when the transition is completed, as a percentage.
     * @param msDuration {number} : duration of the volume transition, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    addVolMoveToPlaySeq(volume, msDuration) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            return yield _this13.sendCommand('C' + String(Math.round(volume)) + ',' + String(Math.round(msDuration)));
        })();
    }

    /**
     * Starts the preprogrammed playing sequence. The sequence
     * runs in loop until it is stopped by stopPlaySeq or an explicit
     * change.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    startPlaySeq() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            return yield _this14.sendCommand('S');
        })();
    }

    /**
     * Stops the preprogrammed playing sequence and sets the frequency to zero.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    stopPlaySeq() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            return yield _this15.sendCommand('X');
        })();
    }

    /**
     * Resets the preprogrammed playing sequence and sets the frequency to zero.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    resetPlaySeq() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            return yield _this16.sendCommand('Z');
        })();
    }

    /**
     * Activates the buzzer for a short duration.
     *
     * @param frequency {number} : pulse frequency, in hertz
     * @param duration {number} : pulse duration in millseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pulse(frequency, duration) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            return yield _this17.set_command('P' + String(Math.round(frequency)) + ',' + String(Math.round(duration)));
        })();
    }

    /**
     * Makes the buzzer frequency change over a period of time.
     *
     * @param frequency {number} : frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.
     * @param duration {number} :  pulse duration in millseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    freqMove(frequency, duration) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            return yield _this18.set_command('F' + String(Math.round(frequency)) + ',' + String(Math.round(duration)));
        })();
    }

    /**
     * Makes the buzzer volume change over a period of time, frequency  stays untouched.
     *
     * @param volume {number} : volume to reach in %
     * @param duration {number} : change duration in millseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    volumeMove(volume, duration) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.set_command('V' + String(Math.round(volume)) + ',' + String(Math.round(duration)));
        })();
    }

    /**
     * Continues the enumeration of buzzers started using yFirstBuzzer().
     *
     * @return {YBuzzer} a pointer to a YBuzzer object, corresponding to
     *         a buzzer currently online, or a null pointer
     *         if there are no more buzzers to enumerate.
     */
    /* */nextBuzzer() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YBuzzer.FindBuzzerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of buzzers currently accessible.
     * Use the method YBuzzer.nextBuzzer() to iterate on
     * next buzzers.
     *
     * @return {YBuzzer} a pointer to a YBuzzer object, corresponding to
     *         the first buzzer currently online, or a null pointer
     *         if there are none.
     */
    static FirstBuzzer() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Buzzer');
        if (next_hwid == null) return null;
        return YBuzzer.FindBuzzer(next_hwid);
    }

    /**
     * Starts the enumeration of buzzers currently accessible.
     * Use the method YBuzzer.nextBuzzer() to iterate on
     * next buzzers.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YBuzzer} a pointer to a YBuzzer object, corresponding to
     *         the first buzzer currently online, or a null pointer
     *         if there are none.
     */
    static FirstBuzzerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Buzzer');
        if (next_hwid == null) return null;
        return YBuzzer.FindBuzzerInContext(yctx, next_hwid);
    }

    //--- (end of YBuzzer implementation)
}

exports.YBuzzer = YBuzzer; //--- (Buzzer functions)

/**
 * comment from .yc definition
 */

function yFindBuzzer(func) {
    return YBuzzer.FindBuzzer(func);
}

/**
 * comment from .yc definition
 */
function yFirstBuzzer() {
    return YBuzzer.FirstBuzzer();
}

//--- (end of Buzzer functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for CarbonDioxide functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YCarbonDioxide = exports.Y_COMMAND_INVALID = exports.Y_ABCPERIOD_INVALID = undefined;
exports.yFindCarbonDioxide = yFindCarbonDioxide;
exports.yFirstCarbonDioxide = yFirstCarbonDioxide;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YCarbonDioxide return codes)
//--- (end of YCarbonDioxide return codes)
//--- (YCarbonDioxide definitions)
const Y_ABCPERIOD_INVALID = exports.Y_ABCPERIOD_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YCarbonDioxide definitions)

//--- (YCarbonDioxide class start)
/**
 * YCarbonDioxide Class: CarbonDioxide function interface
 *
 * The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to perform manual calibration if reuired.
 */
//--- (end of YCarbonDioxide class start)

class YCarbonDioxide extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YCarbonDioxide constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'CarbonDioxide';
        /** @member {number} **/
        this._abcPeriod = Y_ABCPERIOD_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            ABCPERIOD_INVALID: _yocto_api.YAPI.INVALID_INT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YCarbonDioxide constructor)
    }

    //--- (YCarbonDioxide implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'abcPeriod':
                this._abcPeriod = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the Automatic Baseline Calibration period, in hours. A negative value
     * means that automatic baseline calibration is disabled.
     *
     * @return {number} an integer corresponding to the Automatic Baseline Calibration period, in hours
     *
     * On failure, throws an exception or returns YCarbonDioxide.ABCPERIOD_INVALID.
     */
    get_abcPeriod() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ABCPERIOD_INVALID;
                }
            }
            return _this._abcPeriod;
        })();
    }

    /**
     * Modifies Automatic Baseline Calibration period, in hours. If you need
     * to disable automatic baseline calibration (for instance when using the
     * sensor in an environment that is constantly above 400ppm CO2), set the
     * period to -1. Remember to call the saveToFlash() method of the
     * module if the modification must be kept.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_abcPeriod(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('abcPeriod', rest_val);
        })();
    }

    get_command() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this3._command;
        })();
    }

    set_command(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this4._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a CO2 sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the CO2 sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCarbonDioxide.isOnline() to test if the CO2 sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a CO2 sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the CO2 sensor
     *
     * @return {YCarbonDioxide} a YCarbonDioxide object allowing you to drive the CO2 sensor.
     */
    static FindCarbonDioxide(func) {
        /** @type {YCarbonDioxide} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('CarbonDioxide', func);
        if (obj == null) {
            obj = new YCarbonDioxide(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('CarbonDioxide', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a CO2 sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the CO2 sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCarbonDioxide.isOnline() to test if the CO2 sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a CO2 sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the CO2 sensor
     *
     * @return {YCarbonDioxide} a YCarbonDioxide object allowing you to drive the CO2 sensor.
     */
    static FindCarbonDioxideInContext(yctx, func) {
        /** @type {YCarbonDioxide} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'CarbonDioxide', func);
        if (obj == null) {
            obj = new YCarbonDioxide(yctx, func);
            _yocto_api.YFunction._AddToCache('CarbonDioxide', func, obj);
        }
        return obj;
    }

    /**
     * Triggers a baseline calibration at standard CO2 ambiant level (400ppm).
     * It is normally not necessary to manually calibrate the sensor, because
     * the built-in automatic baseline calibration procedure will automatically
     * fix any long-term drift based on the lowest level of CO2 observed over the
     * automatic calibration period. However, if you disable automatic baseline
     * calibration, you may want to manually trigger a calibration from time to
     * time. Before starting a baseline calibration, make sure to put the sensor
     * in a standard environment (e.g. outside in fresh air) at around 400ppm.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    triggetBaselineCalibration() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            return yield _this5.set_command('BC');
        })();
    }

    /**
     * Triggers a zero calibration of the sensor on carbon dioxide-free air.
     * It is normally not necessary to manually calibrate the sensor, because
     * the built-in automatic baseline calibration procedure will automatically
     * fix any long-term drift based on the lowest level of CO2 observed over the
     * automatic calibration period. However, if you disable automatic baseline
     * calibration, you may want to manually trigger a calibration from time to
     * time. Before starting a zero calibration, you should circulate carbon
     * dioxide-free air within the sensor for a minute or two, using a small pipe
     * connected to the sensor. Please contact support@yoctopuce.com for more details
     * on the zero calibration procedure.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    triggetZeroCalibration() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            return yield _this6.set_command('ZC');
        })();
    }

    /**
     * Continues the enumeration of CO2 sensors started using yFirstCarbonDioxide().
     *
     * @return {YCarbonDioxide} a pointer to a YCarbonDioxide object, corresponding to
     *         a CO2 sensor currently online, or a null pointer
     *         if there are no more CO2 sensors to enumerate.
     */
    /* */nextCarbonDioxide() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YCarbonDioxide.FindCarbonDioxideInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of CO2 sensors currently accessible.
     * Use the method YCarbonDioxide.nextCarbonDioxide() to iterate on
     * next CO2 sensors.
     *
     * @return {YCarbonDioxide} a pointer to a YCarbonDioxide object, corresponding to
     *         the first CO2 sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstCarbonDioxide() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('CarbonDioxide');
        if (next_hwid == null) return null;
        return YCarbonDioxide.FindCarbonDioxide(next_hwid);
    }

    /**
     * Starts the enumeration of CO2 sensors currently accessible.
     * Use the method YCarbonDioxide.nextCarbonDioxide() to iterate on
     * next CO2 sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YCarbonDioxide} a pointer to a YCarbonDioxide object, corresponding to
     *         the first CO2 sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstCarbonDioxideInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('CarbonDioxide');
        if (next_hwid == null) return null;
        return YCarbonDioxide.FindCarbonDioxideInContext(yctx, next_hwid);
    }

    //--- (end of YCarbonDioxide implementation)
}

exports.YCarbonDioxide = YCarbonDioxide; //--- (CarbonDioxide functions)

/**
 * comment from .yc definition
 */

function yFindCarbonDioxide(func) {
    return YCarbonDioxide.FindCarbonDioxide(func);
}

/**
 * comment from .yc definition
 */
function yFirstCarbonDioxide() {
    return YCarbonDioxide.FirstCarbonDioxide();
}

//--- (end of CarbonDioxide functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YCellular = exports.Y_COMMAND_INVALID = exports.Y_APNSECRET_INVALID = exports.Y_APN_INVALID = exports.Y_LOCKEDOPERATOR_INVALID = exports.Y_PIN_INVALID = exports.Y_MESSAGE_INVALID = exports.Y_IMSI_INVALID = exports.Y_CELLIDENTIFIER_INVALID = exports.Y_CELLOPERATOR_INVALID = exports.Y_LINKQUALITY_INVALID = exports.Y_ENABLEDATA_INVALID = exports.Y_ENABLEDATA_NEVER = exports.Y_ENABLEDATA_ROAMING = exports.Y_ENABLEDATA_HOMENETWORK = exports.YCellRecord = undefined;
exports.yFindCellular = yFindCellular;
exports.yFirstCellular = yFirstCellular;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_cellular.js 21680 2015-10-02 13:42:44Z seb $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements the high-level API for Cellular functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - -
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YCellRecord return codes)
//--- (end of generated code: YCellRecord return codes)
//--- (generated code: YCellRecord definitions)
//--- (end of generated code: YCellRecord definitions)

//--- (generated code: YCellRecord class start)
/**
 * YCellRecord Class: Description of a cellular antenna
 *
 *
 */
//--- (end of generated code: YCellRecord class start)

class YCellRecord {
    constructor(int_mcc, int_mnc, int_lac, int_cellId, int_dbm, int_tad, str_oper) {
        //--- (generated code: YCellRecord constructor)
        /** @member {string} **/
        this._oper = '';
        /** @member {number} **/
        this._mcc = 0;
        /** @member {number} **/
        this._mnc = 0;
        /** @member {number} **/
        this._lac = 0;
        /** @member {number} **/
        this._cid = 0;
        /** @member {number} **/
        this._dbm = 0;
        /** @member {number} **/
        this._tad = 0;
        //--- (end of generated code: YCellRecord constructor)
        this._oper = str_oper;
        this._mcc = int_mcc;
        this._mnc = int_mnc;
        this._lac = int_lac;
        this._cid = int_cellId;
        this._dbm = int_dbm;
        this._tad = int_tad;
    }

    //--- (generated code: YCellRecord implementation)

    /* */get_cellOperator() {
        return this._oper;
    }

    /* */get_mobileCountryCode() {
        return this._mcc;
    }

    /* */get_mobileNetworkCode() {
        return this._mnc;
    }

    /* */get_locationAreaCode() {
        return this._lac;
    }

    /* */get_cellId() {
        return this._cid;
    }

    /* */get_signalStrength() {
        return this._dbm;
    }

    /* */get_timingAdvance() {
        return this._tad;
    }

    //--- (end of generated code: YCellRecord implementation)
}

exports.YCellRecord = YCellRecord; //--- (generated code: CellRecord functions)
//--- (end of generated code: CellRecord functions)

//--- (generated code: YCellular return codes)
//--- (end of generated code: YCellular return codes)
//--- (generated code: YCellular definitions)

const Y_ENABLEDATA_HOMENETWORK = exports.Y_ENABLEDATA_HOMENETWORK = 0;
const Y_ENABLEDATA_ROAMING = exports.Y_ENABLEDATA_ROAMING = 1;
const Y_ENABLEDATA_NEVER = exports.Y_ENABLEDATA_NEVER = 2;
const Y_ENABLEDATA_INVALID = exports.Y_ENABLEDATA_INVALID = -1;
const Y_LINKQUALITY_INVALID = exports.Y_LINKQUALITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_CELLOPERATOR_INVALID = exports.Y_CELLOPERATOR_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CELLIDENTIFIER_INVALID = exports.Y_CELLIDENTIFIER_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_IMSI_INVALID = exports.Y_IMSI_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_MESSAGE_INVALID = exports.Y_MESSAGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_PIN_INVALID = exports.Y_PIN_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_LOCKEDOPERATOR_INVALID = exports.Y_LOCKEDOPERATOR_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_APN_INVALID = exports.Y_APN_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_APNSECRET_INVALID = exports.Y_APNSECRET_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of generated code: YCellular definitions)

//--- (generated code: YCellular class start)
/**
 * YCellular Class: Cellular function interface
 *
 * YCellular functions provides control over cellular network parameters
 * and status for devices that are GSM-enabled.
 */
//--- (end of generated code: YCellular class start)

class YCellular extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YCellular constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Cellular';
        /** @member {number} **/
        this._linkQuality = Y_LINKQUALITY_INVALID;
        /** @member {string} **/
        this._cellOperator = Y_CELLOPERATOR_INVALID;
        /** @member {string} **/
        this._cellIdentifier = Y_CELLIDENTIFIER_INVALID;
        /** @member {string} **/
        this._imsi = Y_IMSI_INVALID;
        /** @member {string} **/
        this._message = Y_MESSAGE_INVALID;
        /** @member {string} **/
        this._pin = Y_PIN_INVALID;
        /** @member {string} **/
        this._lockedOperator = Y_LOCKEDOPERATOR_INVALID;
        /** @member {number} **/
        this._enableData = Y_ENABLEDATA_INVALID;
        /** @member {string} **/
        this._apn = Y_APN_INVALID;
        /** @member {string} **/
        this._apnSecret = Y_APNSECRET_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            LINKQUALITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            CELLOPERATOR_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CELLIDENTIFIER_INVALID: _yocto_api.YAPI.INVALID_STRING,
            IMSI_INVALID: _yocto_api.YAPI.INVALID_STRING,
            MESSAGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            PIN_INVALID: _yocto_api.YAPI.INVALID_STRING,
            LOCKEDOPERATOR_INVALID: _yocto_api.YAPI.INVALID_STRING,
            ENABLEDATA_HOMENETWORK: 0,
            ENABLEDATA_ROAMING: 1,
            ENABLEDATA_NEVER: 2,
            ENABLEDATA_INVALID: -1,
            APN_INVALID: _yocto_api.YAPI.INVALID_STRING,
            APNSECRET_INVALID: _yocto_api.YAPI.INVALID_STRING,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of generated code: YCellular constructor)
    }

    //--- (generated code: YCellular implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'linkQuality':
                this._linkQuality = parseInt(val);
                return 1;
            case 'cellOperator':
                this._cellOperator = val;
                return 1;
            case 'cellIdentifier':
                this._cellIdentifier = val;
                return 1;
            case 'imsi':
                this._imsi = val;
                return 1;
            case 'message':
                this._message = val;
                return 1;
            case 'pin':
                this._pin = val;
                return 1;
            case 'lockedOperator':
                this._lockedOperator = val;
                return 1;
            case 'enableData':
                this._enableData = parseInt(val);
                return 1;
            case 'apn':
                this._apn = val;
                return 1;
            case 'apnSecret':
                this._apnSecret = val;
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the link quality, expressed in percent.
     *
     * @return {number} an integer corresponding to the link quality, expressed in percent
     *
     * On failure, throws an exception or returns YCellular.LINKQUALITY_INVALID.
     */
    get_linkQuality() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LINKQUALITY_INVALID;
                }
            }
            return _this._linkQuality;
        })();
    }

    /**
     * Returns the name of the cell operator currently in use.
     *
     * @return {string} a string corresponding to the name of the cell operator currently in use
     *
     * On failure, throws an exception or returns YCellular.CELLOPERATOR_INVALID.
     */
    get_cellOperator() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CELLOPERATOR_INVALID;
                }
            }
            return _this2._cellOperator;
        })();
    }

    /**
     * Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.
     *
     * @return {string} a string corresponding to the unique identifier of the cellular antenna in use:
     * MCC, MNC, LAC and Cell ID
     *
     * On failure, throws an exception or returns YCellular.CELLIDENTIFIER_INVALID.
     */
    get_cellIdentifier() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CELLIDENTIFIER_INVALID;
                }
            }
            return _this3._cellIdentifier;
        })();
    }

    /**
     * Returns an opaque string if a PIN code has been configured in the device to access
     * the SIM card, or an empty string if none has been configured or if the code provided
     * was rejected by the SIM card.
     *
     * @return {string} a string corresponding to an opaque string if a PIN code has been configured in
     * the device to access
     *         the SIM card, or an empty string if none has been configured or if the code provided
     *         was rejected by the SIM card
     *
     * On failure, throws an exception or returns YCellular.IMSI_INVALID.
     */
    get_imsi() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_IMSI_INVALID;
                }
            }
            return _this4._imsi;
        })();
    }

    /**
     * Returns the latest status message from the wireless interface.
     *
     * @return {string} a string corresponding to the latest status message from the wireless interface
     *
     * On failure, throws an exception or returns YCellular.MESSAGE_INVALID.
     */
    get_message() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MESSAGE_INVALID;
                }
            }
            return _this5._message;
        })();
    }

    /**
     * Returns an opaque string if a PIN code has been configured in the device to access
     * the SIM card, or an empty string if none has been configured or if the code provided
     * was rejected by the SIM card.
     *
     * @return {string} a string corresponding to an opaque string if a PIN code has been configured in
     * the device to access
     *         the SIM card, or an empty string if none has been configured or if the code provided
     *         was rejected by the SIM card
     *
     * On failure, throws an exception or returns YCellular.PIN_INVALID.
     */
    get_pin() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PIN_INVALID;
                }
            }
            return _this6._pin;
        })();
    }

    /**
     * Changes the PIN code used by the module to access the SIM card.
     * This function does not change the code on the SIM card itself, but only changes
     * the parameter used by the device to try to get access to it. If the SIM code
     * does not work immediately on first try, it will be automatically forgotten
     * and the message will be set to "Enter SIM PIN". The method should then be
     * invoked again with right correct PIN code. After three failed attempts in a row,
     * the message is changed to "Enter SIM PUK" and the SIM card PUK code must be
     * provided using method sendPUK.
     *
     * Remember to call the saveToFlash() method of the module to save the
     * new value in the device flash.
     *
     * @param newval {string} : a string corresponding to the PIN code used by the module to access the SIM card
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_pin(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this7._setAttr('pin', rest_val);
        })();
    }

    /**
     * Returns the name of the only cell operator to use if automatic choice is disabled,
     * or an empty string if the SIM card will automatically choose among available
     * cell operators.
     *
     * @return {string} a string corresponding to the name of the only cell operator to use if automatic
     * choice is disabled,
     *         or an empty string if the SIM card will automatically choose among available
     *         cell operators
     *
     * On failure, throws an exception or returns YCellular.LOCKEDOPERATOR_INVALID.
     */
    get_lockedOperator() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LOCKEDOPERATOR_INVALID;
                }
            }
            return _this8._lockedOperator;
        })();
    }

    /**
     * Changes the name of the cell operator to be used. If the name is an empty
     * string, the choice will be made automatically based on the SIM card. Otherwise,
     * the selected operator is the only one that will be used.
     *
     * @param newval {string} : a string corresponding to the name of the cell operator to be used
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_lockedOperator(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this9._setAttr('lockedOperator', rest_val);
        })();
    }

    /**
     * Returns the condition for enabling IP data services (GPRS).
     * When data services are disabled, SMS are the only mean of communication.
     *
     * @return {number} a value among YCellular.ENABLEDATA_HOMENETWORK, YCellular.ENABLEDATA_ROAMING and
     * YCellular.ENABLEDATA_NEVER corresponding to the condition for enabling IP data services (GPRS)
     *
     * On failure, throws an exception or returns YCellular.ENABLEDATA_INVALID.
     */
    get_enableData() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLEDATA_INVALID;
                }
            }
            return _this10._enableData;
        })();
    }

    /**
     * Changes the condition for enabling IP data services (GPRS).
     * The service can be either fully deactivated, or limited to the SIM home network,
     * or enabled for all partner networks (roaming). Caution: enabling data services
     * on roaming networks may cause prohibitive communication costs !
     *
     * When data services are disabled, SMS are the only mean of communication.
     *
     * @param newval {number} : a value among YCellular.ENABLEDATA_HOMENETWORK,
     * YCellular.ENABLEDATA_ROAMING and YCellular.ENABLEDATA_NEVER corresponding to the condition for
     * enabling IP data services (GPRS)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enableData(newval) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this11._setAttr('enableData', rest_val);
        })();
    }

    /**
     * Returns the Access Point Name (APN) to be used, if needed.
     * When left blank, the APN suggested by the cell operator will be used.
     *
     * @return {string} a string corresponding to the Access Point Name (APN) to be used, if needed
     *
     * On failure, throws an exception or returns YCellular.APN_INVALID.
     */
    get_apn() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_APN_INVALID;
                }
            }
            return _this12._apn;
        })();
    }

    /**
     * Returns the Access Point Name (APN) to be used, if needed.
     * When left blank, the APN suggested by the cell operator will be used.
     *
     * @param newval {string} : a string
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_apn(newval) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this13._setAttr('apn', rest_val);
        })();
    }

    /**
     * Returns an opaque string if APN authentication parameters have been configured
     * in the device, or an empty string otherwise.
     * To configure these parameters, use set_apnAuth().
     *
     * @return {string} a string corresponding to an opaque string if APN authentication parameters have
     * been configured
     *         in the device, or an empty string otherwise
     *
     * On failure, throws an exception or returns YCellular.APNSECRET_INVALID.
     */
    get_apnSecret() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_APNSECRET_INVALID;
                }
            }
            return _this14._apnSecret;
        })();
    }

    set_apnSecret(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this15._setAttr('apnSecret', rest_val);
        })();
    }

    get_command() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._cacheExpiration <= _this16._yapi.GetTickCount()) {
                if ((yield _this16.load(_this16._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this16._command;
        })();
    }

    set_command(newval) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this17._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a cellular interface for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the cellular interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCellular.isOnline() to test if the cellular interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a cellular interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the cellular interface
     *
     * @return {YCellular} a YCellular object allowing you to drive the cellular interface.
     */
    static FindCellular(func) {
        /** @type {YCellular} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Cellular', func);
        if (obj == null) {
            obj = new YCellular(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Cellular', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a cellular interface for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the cellular interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCellular.isOnline() to test if the cellular interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a cellular interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the cellular interface
     *
     * @return {YCellular} a YCellular object allowing you to drive the cellular interface.
     */
    static FindCellularInContext(yctx, func) {
        /** @type {YCellular} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Cellular', func);
        if (obj == null) {
            obj = new YCellular(yctx, func);
            _yocto_api.YFunction._AddToCache('Cellular', func, obj);
        }
        return obj;
    }

    /**
     * Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and
     * setup a new PIN into the SIM card. Only ten consecutives tentatives are permitted:
     * after that, the SIM card will be blocked permanently without any mean of recovery
     * to use it again. Note that after calling this method, you have usually to invoke
     * method set_pin() to tell the YoctoHub which PIN to use in the future.
     *
     * @param puk {string} : the SIM PUK code
     * @param newPin {string} : new PIN code to configure into the SIM card
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    sendPUK(puk, newPin) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let gsmMsg;
            gsmMsg = yield _this18.get_message();
            if (!(gsmMsg == 'Enter SIM PUK')) {
                return _this18._throw(YAPI_INVALID_ARGUMENT, 'PUK not expected at this time', YAPI_INVALID_ARGUMENT);
            }
            if (newPin == '') {
                return yield _this18.set_command('AT+CPIN=' + puk + ',0000;+CLCK=SC,0,0000');
            }
            return yield _this18.set_command('AT+CPIN=' + puk + ',' + newPin);
        })();
    }

    /**
     * Configure authentication parameters to connect to the APN. Both
     * PAP and CHAP authentication are supported.
     *
     * @param username {string} : APN username
     * @param password {string} : APN password
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_apnAuth(username, password) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.set_apnSecret(username + ',' + password);
        })();
    }

    /**
     * Sends an AT command to the GSM module and returns the command output.
     * The command will only execute when the GSM module is in standard
     * command state, and should leave it in the exact same state.
     * Use this function with great care !
     *
     * @param cmd {string} : the AT command to execute, like for instance: "+CCLK?".
     *
     * @return {string} a string with the result of the commands. Empty lines are
     *         automatically removed from the output.
     */
    _AT(cmd) {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let chrPos;
            /** @type {number} **/
            let cmdLen;
            /** @type {number} **/
            let waitMore;
            /** @type {string} **/
            let res;
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {string} **/
            let buffstr;
            /** @type {number} **/
            let buffstrlen;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let suffixlen;
            // quote dangerous characters used in AT commands
            cmdLen = cmd.length;
            chrPos = cmd.indexOf('#');
            while (chrPos >= 0) {
                cmd = cmd.substr(0, chrPos) + '' + String.fromCharCode(37) + '23' + cmd.substr(chrPos + 1, cmdLen - chrPos - 1);
                cmdLen = cmdLen + 2;
                chrPos = cmd.indexOf('#');
            }
            chrPos = cmd.indexOf('+');
            while (chrPos >= 0) {
                cmd = cmd.substr(0, chrPos) + '' + String.fromCharCode(37) + '2B' + cmd.substr(chrPos + 1, cmdLen - chrPos - 1);
                cmdLen = cmdLen + 2;
                chrPos = cmd.indexOf('+');
            }
            chrPos = cmd.indexOf('=');
            while (chrPos >= 0) {
                cmd = cmd.substr(0, chrPos) + '' + String.fromCharCode(37) + '3D' + cmd.substr(chrPos + 1, cmdLen - chrPos - 1);
                cmdLen = cmdLen + 2;
                chrPos = cmd.indexOf('=');
            }
            cmd = 'at.txt?cmd=' + cmd;
            res = '';
            // max 2 minutes (each iteration may take up to 5 seconds if waiting)
            waitMore = 24;
            while (waitMore > 0) {
                buff = yield _this20._download(cmd);
                bufflen = buff.length;
                buffstr = _this20._yapi.imm_bin2str(buff);
                buffstrlen = buffstr.length;
                idx = bufflen - 1;
                while (idx > 0 && buff[idx] != 64 && buff[idx] != 10 && buff[idx] != 13) {
                    idx = idx - 1;
                }
                if (buff[idx] == 64) {
                    suffixlen = bufflen - idx;
                    cmd = 'at.txt?cmd=' + buffstr.substr(buffstrlen - suffixlen, suffixlen);
                    buffstr = buffstr.substr(0, buffstrlen - suffixlen);
                    waitMore = waitMore - 1;
                } else {
                    waitMore = 0;
                }
                res = res + '' + buffstr;
            }
            return res;
        })();
    }

    /**
     * Returns the list detected cell operators in the neighborhood.
     * This function will typically take between 30 seconds to 1 minute to
     * return. Note that any SIM card can usually only connect to specific
     * operators. All networks returned by this function might therefore
     * not be available for connection.
     *
     * @return {string[]} a list of string (cell operator names).
     */
    get_availableOperators() {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let cops;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let slen;
            /** @type {string[]} **/
            let res = [];
            // may throw an exception
            cops = yield _this21._AT('+COPS=?');
            slen = cops.length;
            res.length = 0;
            idx = cops.indexOf('(');
            while (idx >= 0) {
                slen = slen - (idx + 1);
                cops = cops.substr(idx + 1, slen);
                idx = cops.indexOf('"');
                if (idx > 0) {
                    slen = slen - (idx + 1);
                    cops = cops.substr(idx + 1, slen);
                    idx = cops.indexOf('"');
                    if (idx > 0) {
                        res.push(cops.substr(0, idx));
                    }
                }
                idx = cops.indexOf('(');
            }
            return res;
        })();
    }

    /**
     * Returns a list of nearby cellular antennas, as required for quick
     * geolocation of the device. The first cell listed is the serving
     * cell, and the next ones are the neighboor cells reported by the
     * serving cell.
     *
     * @return {YCellRecord[]} a list of YCellRecords.
     */
    quickCellSurvey() {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let moni;
            /** @type {string[]} **/
            let recs = [];
            /** @type {number} **/
            let llen;
            /** @type {string} **/
            let mccs;
            /** @type {number} **/
            let mcc;
            /** @type {string} **/
            let mncs;
            /** @type {number} **/
            let mnc;
            /** @type {number} **/
            let lac;
            /** @type {number} **/
            let cellId;
            /** @type {string} **/
            let dbms;
            /** @type {number} **/
            let dbm;
            /** @type {string} **/
            let tads;
            /** @type {number} **/
            let tad;
            /** @type {string} **/
            let oper;
            /** @type {YCellRecord[]} **/
            let res = [];
            // may throw an exception
            moni = yield _this22._AT('+CCED=0;#MONI=7;#MONI');
            mccs = moni.substr(7, 3);
            if (mccs.substr(0, 1) == '0') {
                mccs = mccs.substr(1, 2);
            }
            if (mccs.substr(0, 1) == '0') {
                mccs = mccs.substr(1, 1);
            }
            mcc = _this22._yapi.imm_atoi(mccs);
            mncs = moni.substr(11, 3);
            if (mncs.substr(2, 1) == ',') {
                mncs = mncs.substr(0, 2);
            }
            if (mncs.substr(0, 1) == '0') {
                mncs = mncs.substr(1, mncs.length - 1);
            }
            mnc = _this22._yapi.imm_atoi(mncs);
            recs = moni.split('#');
            // process each line in turn
            res.length = 0;
            for (let ii in recs) {
                llen = recs[ii].length - 2;
                if (llen >= 44) {
                    if (recs[ii].substr(41, 3) == 'dbm') {
                        lac = parseInt(recs[ii].substr(16, 4), 16);
                        cellId = parseInt(recs[ii].substr(23, 4), 16);
                        dbms = recs[ii].substr(37, 4);
                        if (dbms.substr(0, 1) == ' ') {
                            dbms = dbms.substr(1, 3);
                        }
                        dbm = _this22._yapi.imm_atoi(dbms);
                        if (llen > 66) {
                            tads = recs[ii].substr(54, 2);
                            if (tads.substr(0, 1) == ' ') {
                                tads = tads.substr(1, 3);
                            }
                            tad = _this22._yapi.imm_atoi(tads);
                            oper = recs[ii].substr(66, llen - 66);
                        } else {
                            tad = -1;
                            oper = '';
                        }
                        if (lac < 65535) {
                            res.push(new YCellRecord(mcc, mnc, lac, cellId, dbm, tad, oper));
                        }
                    }
                }
                ;;
            }
            return res;
        })();
    }

    /**
     * Continues the enumeration of cellular interfaces started using yFirstCellular().
     *
     * @return {YCellular} a pointer to a YCellular object, corresponding to
     *         a cellular interface currently online, or a null pointer
     *         if there are no more cellular interfaces to enumerate.
     */
    /* */nextCellular() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YCellular.FindCellularInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of cellular interfaces currently accessible.
     * Use the method YCellular.nextCellular() to iterate on
     * next cellular interfaces.
     *
     * @return {YCellular} a pointer to a YCellular object, corresponding to
     *         the first cellular interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstCellular() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Cellular');
        if (next_hwid == null) return null;
        return YCellular.FindCellular(next_hwid);
    }

    /**
     * Starts the enumeration of cellular interfaces currently accessible.
     * Use the method YCellular.nextCellular() to iterate on
     * next cellular interfaces.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YCellular} a pointer to a YCellular object, corresponding to
     *         the first cellular interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstCellularInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Cellular');
        if (next_hwid == null) return null;
        return YCellular.FindCellularInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YCellular implementation)
}

exports.YCellular = YCellular; //--- (generated code: Cellular functions)

/**
 * comment from .yc definition
 */

function yFindCellular(func) {
    return YCellular.FindCellular(func);
}

/**
 * comment from .yc definition
 */
function yFirstCellular() {
    return YCellular.FirstCellular();
}

//--- (end of generated code: Cellular functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for ColorLed functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YColorLed = exports.Y_COMMAND_INVALID = exports.Y_BLINKSEQSIGNATURE_INVALID = exports.Y_BLINKSEQMAXSIZE_INVALID = exports.Y_BLINKSEQSIZE_INVALID = exports.Y_RGBCOLORATPOWERON_INVALID = exports.Y_HSLMOVE_INVALID = exports.Y_RGBMOVE_INVALID = exports.Y_HSLCOLOR_INVALID = exports.Y_RGBCOLOR_INVALID = undefined;
exports.yFindColorLed = yFindColorLed;
exports.yFirstColorLed = yFirstColorLed;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YColorLed return codes)
//--- (end of YColorLed return codes)
//--- (YColorLed definitions)
const Y_RGBCOLOR_INVALID = exports.Y_RGBCOLOR_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_HSLCOLOR_INVALID = exports.Y_HSLCOLOR_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_RGBMOVE_INVALID = exports.Y_RGBMOVE_INVALID = null;
const Y_HSLMOVE_INVALID = exports.Y_HSLMOVE_INVALID = null;
const Y_RGBCOLORATPOWERON_INVALID = exports.Y_RGBCOLORATPOWERON_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_BLINKSEQSIZE_INVALID = exports.Y_BLINKSEQSIZE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_BLINKSEQMAXSIZE_INVALID = exports.Y_BLINKSEQMAXSIZE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_BLINKSEQSIGNATURE_INVALID = exports.Y_BLINKSEQSIGNATURE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YColorLed definitions)

//--- (YColorLed class start)
/**
 * YColorLed Class: ColorLed function interface
 *
 * The Yoctopuce application programming interface
 * allows you to drive a color led using RGB coordinates as well as HSL coordinates.
 * The module performs all conversions form RGB to HSL automatically. It is then
 * self-evident to turn on a led with a given hue and to progressively vary its
 * saturation or lightness. If needed, you can find more information on the
 * difference between RGB and HSL in the section following this one.
 */
//--- (end of YColorLed class start)

class YColorLed extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YColorLed constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'ColorLed';
        /** @member {number} **/
        this._rgbColor = Y_RGBCOLOR_INVALID;
        /** @member {number} **/
        this._hslColor = Y_HSLCOLOR_INVALID;
        /** @member {YMove} **/
        this._rgbMove = Y_RGBMOVE_INVALID;
        /** @member {YMove} **/
        this._hslMove = Y_HSLMOVE_INVALID;
        /** @member {number} **/
        this._rgbColorAtPowerOn = Y_RGBCOLORATPOWERON_INVALID;
        /** @member {number} **/
        this._blinkSeqSize = Y_BLINKSEQSIZE_INVALID;
        /** @member {number} **/
        this._blinkSeqMaxSize = Y_BLINKSEQMAXSIZE_INVALID;
        /** @member {number} **/
        this._blinkSeqSignature = Y_BLINKSEQSIGNATURE_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            RGBCOLOR_INVALID: _yocto_api.YAPI.INVALID_UINT,
            HSLCOLOR_INVALID: _yocto_api.YAPI.INVALID_UINT,
            RGBCOLORATPOWERON_INVALID: _yocto_api.YAPI.INVALID_UINT,
            BLINKSEQSIZE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            BLINKSEQMAXSIZE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            BLINKSEQSIGNATURE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YColorLed constructor)
    }

    //--- (YColorLed implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'rgbColor':
                this._rgbColor = parseInt(val);
                return 1;
            case 'hslColor':
                this._hslColor = parseInt(val);
                return 1;
            case 'rgbMove':
                this._rgbMove = val;
                return 1;
            case 'hslMove':
                this._hslMove = val;
                return 1;
            case 'rgbColorAtPowerOn':
                this._rgbColorAtPowerOn = parseInt(val);
                return 1;
            case 'blinkSeqSize':
                this._blinkSeqSize = parseInt(val);
                return 1;
            case 'blinkSeqMaxSize':
                this._blinkSeqMaxSize = parseInt(val);
                return 1;
            case 'blinkSeqSignature':
                this._blinkSeqSignature = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current RGB color of the led.
     *
     * @return {number} an integer corresponding to the current RGB color of the led
     *
     * On failure, throws an exception or returns YColorLed.RGBCOLOR_INVALID.
     */
    get_rgbColor() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RGBCOLOR_INVALID;
                }
            }
            return _this._rgbColor;
        })();
    }

    /**
     * Changes the current color of the led, using a RGB color. Encoding is done as follows: 0xRRGGBB.
     *
     * @param newval {number} : an integer corresponding to the current color of the led, using a RGB color
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_rgbColor(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = '0x' + newval.toString(16);
            return yield _this2._setAttr('rgbColor', rest_val);
        })();
    }

    /**
     * Returns the current HSL color of the led.
     *
     * @return {number} an integer corresponding to the current HSL color of the led
     *
     * On failure, throws an exception or returns YColorLed.HSLCOLOR_INVALID.
     */
    get_hslColor() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_HSLCOLOR_INVALID;
                }
            }
            return _this3._hslColor;
        })();
    }

    /**
     * Changes the current color of the led, using a color HSL. Encoding is done as follows: 0xHHSSLL.
     *
     * @param newval {number} : an integer corresponding to the current color of the led, using a color HSL
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_hslColor(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = '0x' + newval.toString(16);
            return yield _this4._setAttr('hslColor', rest_val);
        })();
    }

    get_rgbMove() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RGBMOVE_INVALID;
                }
            }
            return _this5._rgbMove;
        })();
    }

    set_rgbMove(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval.target) + ':' + String(newval.ms);
            return yield _this6._setAttr('rgbMove', rest_val);
        })();
    }

    /**
     * Performs a smooth transition in the RGB color space between the current color and a target color.
     *
     * @param rgb_target  : desired RGB color at the end of the transition
     * @param ms_duration {number} : duration of the transition, in millisecond
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    rgbMove(rgb_target, ms_duration) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(rgb_target) + ':' + String(ms_duration);
            return yield _this7._setAttr('rgbMove', rest_val);
        })();
    }

    get_hslMove() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_HSLMOVE_INVALID;
                }
            }
            return _this8._hslMove;
        })();
    }

    set_hslMove(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval.target) + ':' + String(newval.ms);
            return yield _this9._setAttr('hslMove', rest_val);
        })();
    }

    /**
     * Performs a smooth transition in the HSL color space between the current color and a target color.
     *
     * @param hsl_target  : desired HSL color at the end of the transition
     * @param ms_duration {number} : duration of the transition, in millisecond
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    hslMove(hsl_target, ms_duration) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(hsl_target) + ':' + String(ms_duration);
            return yield _this10._setAttr('hslMove', rest_val);
        })();
    }

    /**
     * Returns the configured color to be displayed when the module is turned on.
     *
     * @return {number} an integer corresponding to the configured color to be displayed when the module is turned on
     *
     * On failure, throws an exception or returns YColorLed.RGBCOLORATPOWERON_INVALID.
     */
    get_rgbColorAtPowerOn() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RGBCOLORATPOWERON_INVALID;
                }
            }
            return _this11._rgbColorAtPowerOn;
        })();
    }

    /**
     * Changes the color that the led will display by default when the module is turned on.
     *
     * @param newval {number} : an integer corresponding to the color that the led will display by default
     * when the module is turned on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_rgbColorAtPowerOn(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = '0x' + newval.toString(16);
            return yield _this12._setAttr('rgbColorAtPowerOn', rest_val);
        })();
    }

    /**
     * Returns the current length of the blinking sequence
     *
     * @return {number} an integer corresponding to the current length of the blinking sequence
     *
     * On failure, throws an exception or returns YColorLed.BLINKSEQSIZE_INVALID.
     */
    get_blinkSeqSize() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BLINKSEQSIZE_INVALID;
                }
            }
            return _this13._blinkSeqSize;
        })();
    }

    /**
     * Returns the maximum length of the blinking sequence
     *
     * @return {number} an integer corresponding to the maximum length of the blinking sequence
     *
     * On failure, throws an exception or returns YColorLed.BLINKSEQMAXSIZE_INVALID.
     */
    get_blinkSeqMaxSize() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration == 0) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BLINKSEQMAXSIZE_INVALID;
                }
            }
            return _this14._blinkSeqMaxSize;
        })();
    }

    /**
     * Return the blinking sequence signature. Since blinking
     * sequences cannot be read from the device, this can be used
     * to detect if a specific blinking sequence is already
     * programmed.
     *
     * @return {number} an integer
     *
     * On failure, throws an exception or returns YColorLed.BLINKSEQSIGNATURE_INVALID.
     */
    get_blinkSeqSignature() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BLINKSEQSIGNATURE_INVALID;
                }
            }
            return _this15._blinkSeqSignature;
        })();
    }

    get_command() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._cacheExpiration <= _this16._yapi.GetTickCount()) {
                if ((yield _this16.load(_this16._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this16._command;
        })();
    }

    set_command(newval) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this17._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves an RGB led for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the RGB led is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YColorLed.isOnline() to test if the RGB led is
     * indeed online at a given time. In case of ambiguity when looking for
     * an RGB led by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the RGB led
     *
     * @return {YColorLed} a YColorLed object allowing you to drive the RGB led.
     */
    static FindColorLed(func) {
        /** @type {YColorLed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('ColorLed', func);
        if (obj == null) {
            obj = new YColorLed(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('ColorLed', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves an RGB led for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the RGB led is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YColorLed.isOnline() to test if the RGB led is
     * indeed online at a given time. In case of ambiguity when looking for
     * an RGB led by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the RGB led
     *
     * @return {YColorLed} a YColorLed object allowing you to drive the RGB led.
     */
    static FindColorLedInContext(yctx, func) {
        /** @type {YColorLed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'ColorLed', func);
        if (obj == null) {
            obj = new YColorLed(yctx, func);
            _yocto_api.YFunction._AddToCache('ColorLed', func, obj);
        }
        return obj;
    }

    sendCommand(command) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            return yield _this18.set_command(command);
        })();
    }

    /**
     * Add a new transition to the blinking sequence, the move will
     * be performed in the HSL space.
     *
     * @param HSLcolor {number} : desired HSL color when the traisntion is completed
     * @param msDelay {number} : duration of the color transition, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    addHslMoveToBlinkSeq(HSLcolor, msDelay) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.sendCommand('H' + String(Math.round(HSLcolor)) + ',' + String(Math.round(msDelay)));
        })();
    }

    /**
     * Add a new transition to the blinking sequence, the move will
     * be performed in the RGB space.
     *
     * @param RGBcolor {number} : desired RGB color when the transition is completed
     * @param msDelay {number} : duration of the color transition, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    addRgbMoveToBlinkSeq(RGBcolor, msDelay) {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            return yield _this20.sendCommand('R' + String(Math.round(RGBcolor)) + ',' + String(Math.round(msDelay)));
        })();
    }

    /**
     * Starts the preprogrammed blinking sequence. The sequence will
     * run in loop until it is stopped by stopBlinkSeq or an explicit
     * change.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    startBlinkSeq() {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            return yield _this21.sendCommand('S');
        })();
    }

    /**
     * Stops the preprogrammed blinking sequence.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    stopBlinkSeq() {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            return yield _this22.sendCommand('X');
        })();
    }

    /**
     * Resets the preprogrammed blinking sequence.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    resetBlinkSeq() {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            return yield _this23.sendCommand('Z');
        })();
    }

    /**
     * Continues the enumeration of RGB leds started using yFirstColorLed().
     *
     * @return {YColorLed} a pointer to a YColorLed object, corresponding to
     *         an RGB led currently online, or a null pointer
     *         if there are no more RGB leds to enumerate.
     */
    /* */nextColorLed() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YColorLed.FindColorLedInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of RGB leds currently accessible.
     * Use the method YColorLed.nextColorLed() to iterate on
     * next RGB leds.
     *
     * @return {YColorLed} a pointer to a YColorLed object, corresponding to
     *         the first RGB led currently online, or a null pointer
     *         if there are none.
     */
    static FirstColorLed() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('ColorLed');
        if (next_hwid == null) return null;
        return YColorLed.FindColorLed(next_hwid);
    }

    /**
     * Starts the enumeration of RGB leds currently accessible.
     * Use the method YColorLed.nextColorLed() to iterate on
     * next RGB leds.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YColorLed} a pointer to a YColorLed object, corresponding to
     *         the first RGB led currently online, or a null pointer
     *         if there are none.
     */
    static FirstColorLedInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('ColorLed');
        if (next_hwid == null) return null;
        return YColorLed.FindColorLedInContext(yctx, next_hwid);
    }

    //--- (end of YColorLed implementation)
}

exports.YColorLed = YColorLed; //--- (ColorLed functions)

/**
 * comment from .yc definition
 */

function yFindColorLed(func) {
    return YColorLed.FindColorLed(func);
}

/**
 * comment from .yc definition
 */
function yFirstColorLed() {
    return YColorLed.FirstColorLed();
}

//--- (end of ColorLed functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Compass functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YCompass = exports.Y_MAGNETICHEADING_INVALID = exports.Y_AXIS_INVALID = exports.Y_AXIS_Z = exports.Y_AXIS_Y = exports.Y_AXIS_X = undefined;
exports.yFindCompass = yFindCompass;
exports.yFirstCompass = yFirstCompass;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YCompass return codes)
//--- (end of YCompass return codes)
//--- (YCompass definitions)
const Y_AXIS_X = exports.Y_AXIS_X = 0;
const Y_AXIS_Y = exports.Y_AXIS_Y = 1;
const Y_AXIS_Z = exports.Y_AXIS_Z = 2;
const Y_AXIS_INVALID = exports.Y_AXIS_INVALID = -1;
const Y_MAGNETICHEADING_INVALID = exports.Y_MAGNETICHEADING_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YCompass definitions)

//--- (YCompass class start)
/**
 * YCompass Class: Compass function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of YCompass class start)

class YCompass extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YCompass constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Compass';
        /** @member {number} **/
        this._axis = Y_AXIS_INVALID;
        /** @member {number} **/
        this._magneticHeading = Y_MAGNETICHEADING_INVALID;
        this.imm_setConst({
            AXIS_X: 0,
            AXIS_Y: 1,
            AXIS_Z: 2,
            AXIS_INVALID: -1,
            MAGNETICHEADING_INVALID: _yocto_api.YAPI.INVALID_DOUBLE
        });
        //--- (end of YCompass constructor)
    }

    //--- (YCompass implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'axis':
                this._axis = parseInt(val);
                return 1;
            case 'magneticHeading':
                this._magneticHeading = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    get_axis() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_AXIS_INVALID;
                }
            }
            return _this._axis;
        })();
    }

    /**
     * Returns the magnetic heading, regardless of the configured bearing.
     *
     * @return {number} a floating point number corresponding to the magnetic heading, regardless of the
     * configured bearing
     *
     * On failure, throws an exception or returns YCompass.MAGNETICHEADING_INVALID.
     */
    get_magneticHeading() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MAGNETICHEADING_INVALID;
                }
            }
            return _this2._magneticHeading;
        })();
    }

    /**
     * Retrieves a compass for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the compass is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCompass.isOnline() to test if the compass is
     * indeed online at a given time. In case of ambiguity when looking for
     * a compass by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the compass
     *
     * @return {YCompass} a YCompass object allowing you to drive the compass.
     */
    static FindCompass(func) {
        /** @type {YCompass} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Compass', func);
        if (obj == null) {
            obj = new YCompass(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Compass', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a compass for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the compass is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCompass.isOnline() to test if the compass is
     * indeed online at a given time. In case of ambiguity when looking for
     * a compass by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the compass
     *
     * @return {YCompass} a YCompass object allowing you to drive the compass.
     */
    static FindCompassInContext(yctx, func) {
        /** @type {YCompass} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Compass', func);
        if (obj == null) {
            obj = new YCompass(yctx, func);
            _yocto_api.YFunction._AddToCache('Compass', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of compasses started using yFirstCompass().
     *
     * @return {YCompass} a pointer to a YCompass object, corresponding to
     *         a compass currently online, or a null pointer
     *         if there are no more compasses to enumerate.
     */
    /* */nextCompass() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YCompass.FindCompassInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of compasses currently accessible.
     * Use the method YCompass.nextCompass() to iterate on
     * next compasses.
     *
     * @return {YCompass} a pointer to a YCompass object, corresponding to
     *         the first compass currently online, or a null pointer
     *         if there are none.
     */
    static FirstCompass() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Compass');
        if (next_hwid == null) return null;
        return YCompass.FindCompass(next_hwid);
    }

    /**
     * Starts the enumeration of compasses currently accessible.
     * Use the method YCompass.nextCompass() to iterate on
     * next compasses.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YCompass} a pointer to a YCompass object, corresponding to
     *         the first compass currently online, or a null pointer
     *         if there are none.
     */
    static FirstCompassInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Compass');
        if (next_hwid == null) return null;
        return YCompass.FindCompassInContext(yctx, next_hwid);
    }

    //--- (end of YCompass implementation)
}

exports.YCompass = YCompass; //--- (Compass functions)

/**
 * comment from .yc definition
 */

function yFindCompass(func) {
    return YCompass.FindCompass(func);
}

/**
 * comment from .yc definition
 */
function yFirstCompass() {
    return YCompass.FirstCompass();
}

//--- (end of Compass functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Current functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YCurrent = undefined;
exports.yFindCurrent = yFindCurrent;
exports.yFirstCurrent = yFirstCurrent;

var _yocto_api = require('lib/yocto_api');

//--- (YCurrent return codes)
//--- (end of YCurrent return codes)
//--- (YCurrent definitions)
//--- (end of YCurrent definitions)

//--- (YCurrent class start)
/**
 * YCurrent Class: Current function interface
 *
 * The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YCurrent class start)

class YCurrent extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YCurrent constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Current';
        //--- (end of YCurrent constructor)
    }

    //--- (YCurrent implementation)

    /**
     * Retrieves a current sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the current sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCurrent.isOnline() to test if the current sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a current sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the current sensor
     *
     * @return {YCurrent} a YCurrent object allowing you to drive the current sensor.
     */
    static FindCurrent(func) {
        /** @type {YCurrent} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Current', func);
        if (obj == null) {
            obj = new YCurrent(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Current', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a current sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the current sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCurrent.isOnline() to test if the current sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a current sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the current sensor
     *
     * @return {YCurrent} a YCurrent object allowing you to drive the current sensor.
     */
    static FindCurrentInContext(yctx, func) {
        /** @type {YCurrent} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Current', func);
        if (obj == null) {
            obj = new YCurrent(yctx, func);
            _yocto_api.YFunction._AddToCache('Current', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of current sensors started using yFirstCurrent().
     *
     * @return {YCurrent} a pointer to a YCurrent object, corresponding to
     *         a current sensor currently online, or a null pointer
     *         if there are no more current sensors to enumerate.
     */
    /* */nextCurrent() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YCurrent.FindCurrentInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of current sensors currently accessible.
     * Use the method YCurrent.nextCurrent() to iterate on
     * next current sensors.
     *
     * @return {YCurrent} a pointer to a YCurrent object, corresponding to
     *         the first current sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstCurrent() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Current');
        if (next_hwid == null) return null;
        return YCurrent.FindCurrent(next_hwid);
    }

    /**
     * Starts the enumeration of current sensors currently accessible.
     * Use the method YCurrent.nextCurrent() to iterate on
     * next current sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YCurrent} a pointer to a YCurrent object, corresponding to
     *         the first current sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstCurrentInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Current');
        if (next_hwid == null) return null;
        return YCurrent.FindCurrentInContext(yctx, next_hwid);
    }

    //--- (end of YCurrent implementation)
}

exports.YCurrent = YCurrent; //--- (Current functions)

/**
 * comment from .yc definition
 */

function yFindCurrent(func) {
    return YCurrent.FindCurrent(func);
}

/**
 * comment from .yc definition
 */
function yFirstCurrent() {
    return YCurrent.FirstCurrent();
}

//--- (end of Current functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for CurrentLoopOutput functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YCurrentLoopOutput = exports.Y_CURRENTATSTARTUP_INVALID = exports.Y_CURRENTTRANSITION_INVALID = exports.Y_CURRENT_INVALID = exports.Y_LOOPPOWER_INVALID = exports.Y_LOOPPOWER_POWEROK = exports.Y_LOOPPOWER_LOWPWR = exports.Y_LOOPPOWER_NOPWR = undefined;
exports.yFindCurrentLoopOutput = yFindCurrentLoopOutput;
exports.yFirstCurrentLoopOutput = yFirstCurrentLoopOutput;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YCurrentLoopOutput return codes)
//--- (end of YCurrentLoopOutput return codes)
//--- (YCurrentLoopOutput definitions)
const Y_LOOPPOWER_NOPWR = exports.Y_LOOPPOWER_NOPWR = 0;
const Y_LOOPPOWER_LOWPWR = exports.Y_LOOPPOWER_LOWPWR = 1;
const Y_LOOPPOWER_POWEROK = exports.Y_LOOPPOWER_POWEROK = 2;
const Y_LOOPPOWER_INVALID = exports.Y_LOOPPOWER_INVALID = -1;
const Y_CURRENT_INVALID = exports.Y_CURRENT_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_CURRENTTRANSITION_INVALID = exports.Y_CURRENTTRANSITION_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CURRENTATSTARTUP_INVALID = exports.Y_CURRENTATSTARTUP_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YCurrentLoopOutput definitions)

//--- (YCurrentLoopOutput class start)
/**
 * YCurrentLoopOutput Class: CurrentLoopOutput function interface
 *
 * The Yoctopuce application programming interface allows you to change the value of the 4-20mA
 * output as well as to know the current loop state.
 */
//--- (end of YCurrentLoopOutput class start)

class YCurrentLoopOutput extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YCurrentLoopOutput constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'CurrentLoopOutput';
        /** @member {number} **/
        this._current = Y_CURRENT_INVALID;
        /** @member {string} **/
        this._currentTransition = Y_CURRENTTRANSITION_INVALID;
        /** @member {number} **/
        this._currentAtStartUp = Y_CURRENTATSTARTUP_INVALID;
        /** @member {number} **/
        this._loopPower = Y_LOOPPOWER_INVALID;
        this.imm_setConst({
            CURRENT_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            CURRENTTRANSITION_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CURRENTATSTARTUP_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            LOOPPOWER_NOPWR: 0,
            LOOPPOWER_LOWPWR: 1,
            LOOPPOWER_POWEROK: 2,
            LOOPPOWER_INVALID: -1
        });
        //--- (end of YCurrentLoopOutput constructor)
    }

    //--- (YCurrentLoopOutput implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'current':
                this._current = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'currentTransition':
                this._currentTransition = val;
                return 1;
            case 'currentAtStartUp':
                this._currentAtStartUp = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'loopPower':
                this._loopPower = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the current loop, the valid range is from 3 to 21mA. If the loop is
     * not propely powered, the  target current is not reached and
     * loopPower is set to LOWPWR.
     *
     * @param newval {number} : a floating point number corresponding to the current loop, the valid range
     * is from 3 to 21mA
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_current(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this._setAttr('current', rest_val);
        })();
    }

    /**
     * Returns the loop current set point in mA.
     *
     * @return {number} a floating point number corresponding to the loop current set point in mA
     *
     * On failure, throws an exception or returns YCurrentLoopOutput.CURRENT_INVALID.
     */
    get_current() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CURRENT_INVALID;
                }
            }
            return _this2._current;
        })();
    }

    get_currentTransition() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CURRENTTRANSITION_INVALID;
                }
            }
            return _this3._currentTransition;
        })();
    }

    set_currentTransition(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this4._setAttr('currentTransition', rest_val);
        })();
    }

    /**
     * Changes the loop current at device start up. Remember to call the matching
     * module saveToFlash() method, otherwise this call has no effect.
     *
     * @param newval {number} : a floating point number corresponding to the loop current at device start up
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_currentAtStartUp(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this5._setAttr('currentAtStartUp', rest_val);
        })();
    }

    /**
     * Returns the current in the loop at device startup, in mA
     *
     * @return {number} a floating point number corresponding to the current in the loop at device startup, in mA
     *
     * On failure, throws an exception or returns YCurrentLoopOutput.CURRENTATSTARTUP_INVALID.
     */
    get_currentAtStartUp() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CURRENTATSTARTUP_INVALID;
                }
            }
            return _this6._currentAtStartUp;
        })();
    }

    /**
     * Returns the loop powerstate.  POWEROK: the loop
     * is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not
     * powered enough to maintain the current required (insufficient voltage).
     *
     * @return {number} a value among YCurrentLoopOutput.LOOPPOWER_NOPWR,
     * YCurrentLoopOutput.LOOPPOWER_LOWPWR and YCurrentLoopOutput.LOOPPOWER_POWEROK corresponding to the
     * loop powerstate
     *
     * On failure, throws an exception or returns YCurrentLoopOutput.LOOPPOWER_INVALID.
     */
    get_loopPower() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LOOPPOWER_INVALID;
                }
            }
            return _this7._loopPower;
        })();
    }

    /**
     * Retrieves a 4-20mA output for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the 4-20mA output is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCurrentLoopOutput.isOnline() to test if the 4-20mA output is
     * indeed online at a given time. In case of ambiguity when looking for
     * a 4-20mA output by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the 4-20mA output
     *
     * @return {YCurrentLoopOutput} a YCurrentLoopOutput object allowing you to drive the 4-20mA output.
     */
    static FindCurrentLoopOutput(func) {
        /** @type {YCurrentLoopOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('CurrentLoopOutput', func);
        if (obj == null) {
            obj = new YCurrentLoopOutput(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('CurrentLoopOutput', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a 4-20mA output for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the 4-20mA output is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YCurrentLoopOutput.isOnline() to test if the 4-20mA output is
     * indeed online at a given time. In case of ambiguity when looking for
     * a 4-20mA output by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the 4-20mA output
     *
     * @return {YCurrentLoopOutput} a YCurrentLoopOutput object allowing you to drive the 4-20mA output.
     */
    static FindCurrentLoopOutputInContext(yctx, func) {
        /** @type {YCurrentLoopOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'CurrentLoopOutput', func);
        if (obj == null) {
            obj = new YCurrentLoopOutput(yctx, func);
            _yocto_api.YFunction._AddToCache('CurrentLoopOutput', func, obj);
        }
        return obj;
    }

    /**
     * Performs a smooth transistion of current flowing in the loop. Any current explicit
     * change cancels any ongoing transition process.
     *
     * @param mA_target   : new current value at the end of the transition
     *         (floating-point number, representing the transition duration in mA)
     * @param ms_duration {number} : total duration of the transition, in milliseconds
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     */
    currentMove(mA_target, ms_duration) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let newval;
            if (mA_target < 3.0) {
                mA_target = 3.0;
            }
            if (mA_target > 21.0) {
                mA_target = 21.0;
            }
            newval = String(Math.round(Math.round(mA_target * 1000))) + ':' + String(Math.round(ms_duration));
            // may throw an exception
            return yield _this8.set_currentTransition(newval);
        })();
    }

    /**
     * Continues the enumeration of 4-20mA outputs started using yFirstCurrentLoopOutput().
     *
     * @return {YCurrentLoopOutput} a pointer to a YCurrentLoopOutput object, corresponding to
     *         a 4-20mA output currently online, or a null pointer
     *         if there are no more 4-20mA outputs to enumerate.
     */
    /* */nextCurrentLoopOutput() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YCurrentLoopOutput.FindCurrentLoopOutputInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of 4-20mA outputs currently accessible.
     * Use the method YCurrentLoopOutput.nextCurrentLoopOutput() to iterate on
     * next 4-20mA outputs.
     *
     * @return {YCurrentLoopOutput} a pointer to a YCurrentLoopOutput object, corresponding to
     *         the first 4-20mA output currently online, or a null pointer
     *         if there are none.
     */
    static FirstCurrentLoopOutput() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('CurrentLoopOutput');
        if (next_hwid == null) return null;
        return YCurrentLoopOutput.FindCurrentLoopOutput(next_hwid);
    }

    /**
     * Starts the enumeration of 4-20mA outputs currently accessible.
     * Use the method YCurrentLoopOutput.nextCurrentLoopOutput() to iterate on
     * next 4-20mA outputs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YCurrentLoopOutput} a pointer to a YCurrentLoopOutput object, corresponding to
     *         the first 4-20mA output currently online, or a null pointer
     *         if there are none.
     */
    static FirstCurrentLoopOutputInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('CurrentLoopOutput');
        if (next_hwid == null) return null;
        return YCurrentLoopOutput.FindCurrentLoopOutputInContext(yctx, next_hwid);
    }

    //--- (end of YCurrentLoopOutput implementation)
}

exports.YCurrentLoopOutput = YCurrentLoopOutput; //--- (CurrentLoopOutput functions)

/**
 * comment from .yc definition
 */

function yFindCurrentLoopOutput(func) {
    return YCurrentLoopOutput.FindCurrentLoopOutput(func);
}

/**
 * comment from .yc definition
 */
function yFirstCurrentLoopOutput() {
    return YCurrentLoopOutput.FirstCurrentLoopOutput();
}

//--- (end of CurrentLoopOutput functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YDataLogger = exports.YOldDataStream = exports.Y_MAXVALUE_INVALID = exports.Y_AVERAGEVALUE_INVALID = exports.Y_MINVALUE_INVALID = exports.Y_DATA_INVALID = exports.Y_TIMEUTC_INVALID = exports.Y_CURRENTRUNINDEX_INVALID = exports.Y_CLEARHISTORY_INVALID = exports.Y_CLEARHISTORY_TRUE = exports.Y_CLEARHISTORY_FALSE = exports.Y_BEACONDRIVEN_INVALID = exports.Y_BEACONDRIVEN_ON = exports.Y_BEACONDRIVEN_OFF = exports.Y_AUTOSTART_INVALID = exports.Y_AUTOSTART_ON = exports.Y_AUTOSTART_OFF = exports.Y_RECORDING_INVALID = exports.Y_RECORDING_PENDING = exports.Y_RECORDING_ON = exports.Y_RECORDING_OFF = undefined;
exports.yFindDataLogger = yFindDataLogger;
exports.yFirstDataLogger = yFirstDataLogger;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_datalogger.js 20704 2015-06-20 19:43:34Z mvuilleu $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements yFindDataLogger(), the high-level API for DataLogger functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - - 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YDataLogger definitions)
const Y_RECORDING_OFF = exports.Y_RECORDING_OFF = 0;
const Y_RECORDING_ON = exports.Y_RECORDING_ON = 1;
const Y_RECORDING_PENDING = exports.Y_RECORDING_PENDING = 2;
const Y_RECORDING_INVALID = exports.Y_RECORDING_INVALID = -1;
const Y_AUTOSTART_OFF = exports.Y_AUTOSTART_OFF = 0;
const Y_AUTOSTART_ON = exports.Y_AUTOSTART_ON = 1;
const Y_AUTOSTART_INVALID = exports.Y_AUTOSTART_INVALID = -1;
const Y_BEACONDRIVEN_OFF = exports.Y_BEACONDRIVEN_OFF = 0;
const Y_BEACONDRIVEN_ON = exports.Y_BEACONDRIVEN_ON = 1;
const Y_BEACONDRIVEN_INVALID = exports.Y_BEACONDRIVEN_INVALID = -1;
const Y_CLEARHISTORY_FALSE = exports.Y_CLEARHISTORY_FALSE = 0;
const Y_CLEARHISTORY_TRUE = exports.Y_CLEARHISTORY_TRUE = 1;
const Y_CLEARHISTORY_INVALID = exports.Y_CLEARHISTORY_INVALID = -1;
const Y_CURRENTRUNINDEX_INVALID = exports.Y_CURRENTRUNINDEX_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_TIMEUTC_INVALID = exports.Y_TIMEUTC_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of generated code: YDataLogger definitions)

const Y_DATA_INVALID = exports.Y_DATA_INVALID = YAPI_INVALID_DOUBLE;
const Y_MINVALUE_INVALID = exports.Y_MINVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_AVERAGEVALUE_INVALID = exports.Y_AVERAGEVALUE_INVALID = YAPI_INVALID_DOUBLE;
const Y_MAXVALUE_INVALID = exports.Y_MAXVALUE_INVALID = YAPI_INVALID_DOUBLE;

/**
 * YOldDataStream Class: Sequence of measured data, returned by the data logger
 * 
 * A data stream is a small collection of consecutive measures for a set
 * of sensors. A few properties are available directly from the object itself
 * (they are preloaded at instantiation time), while most other properties and
 * the actual data are loaded on demand when accessed for the first time.
 */
class YOldDataStream extends YDataStream {
    // Data preloaded on object instantiation
    constructor(obj_parent, int_run, int_stamp, int_utc, int_itv) {
        super(obj_parent);
        this._dataLogger = obj_parent;
        this._runNo = int_run;
        this._timeStamp = int_stamp;
        this._utcStamp = int_utc == null ? -1 : int_utc;
        this._interval = int_itv == null ? 0 : int_itv;
        this._samplesPerHour = this._interval == 0 ? 3600 : 3600 / this._interval;
        this._isClosed = 1;
        this._minVal = this.DATA_INVALID;
        this._avgVal = this.DATA_INVALID;
        this._maxVal = this.DATA_INVALID;
    }

    // Internal function to preload all values into object
    //
    loadStream() {
        var _this = this;

        return _asyncToGenerator(function* () {
            var coldiv = null;
            var coltyp = null;
            var colscl = null;
            var colofs = null;
            var calhdl = null;
            var caltyp = null;
            var calpar = null;
            var calraw = null;
            var calref = null;
            var c, i;

            var loadval = _this._dataLogger.getData(_this._runNo, _this._timeStamp);
            if (loadval == null) {
                return _this._dataLogger.get_errorType();
            }
            if (loadval['time'] != null) _this._timeStamp = loadval['time'];
            if (loadval['UTC'] != null) _this._utcStamp = loadval['UTC'];
            if (loadval['interval'] != null) _this._interval = loadval['interval'];
            if (loadval['nRows'] != null) _this._nRows = loadval['nRows'];
            if (loadval['keys'] != null) {
                _this._columnNames = loadval['keys'];
                if (_this._nCols == 0) {
                    _this._nCols = _this._columnNames.length;
                } else if (_this._nCols != _this._columnNames.length) {
                    _this._nCols = 0;
                    return YAPI_IO_ERROR;
                }
            }
            if (loadval['div'] != null) {
                coldiv = loadval['div'];
                if (_this._nCols == 0) {
                    _this._nCols = coldiv.length;
                } else if (_this._nCols != coldiv.length) {
                    _this._nCols = 0;
                    return YAPI_IO_ERROR;
                }
            }
            if (loadval['type'] != null) {
                coltyp = loadval['type'];
                if (_this._nCols == 0) {
                    _this._nCols = coltyp.length;
                } else if (_this._nCols != coltyp.length) {
                    _this._nCols = 0;
                    return YAPI_IO_ERROR;
                }
            }
            if (loadval['scal'] != null) {
                colscl = loadval['scal'];
                colofs = [];
                if (_this._nCols != colscl.length) {
                    _this._nCols = 0;
                    return YAPI_IO_ERROR;
                }
                for (i = 0; i < colscl.length; i++) {
                    colscl[i] /= 65536.0;
                    colofs[i] = coltyp[i] != 0 ? -32767 : 0;
                }
            } else {
                colscl = [];
                colofs = [];
                for (i = 0; i < coldiv.length; i++) {
                    colscl[i] = 1.0 / coldiv[i];
                    colofs[i] = coltyp[i] != 0 ? -32767 : 0;
                }
            }
            if (loadval['cal'] != null) {
                calhdl = new Array(_this._nCols);
                caltyp = new Array(_this._nCols);
                calpar = new Array(_this._nCols);
                calraw = new Array(_this._nCols);
                calref = new Array(_this._nCols);
                for (c = 0; c < _this._nCols; c++) {
                    var params = loadval['cal'][c];
                    if (!params) continue;
                    params = params.split(',');
                    if (params.length < 11) continue;
                    calhdl[c] = _yocto_api.YAPI._getCalibrationHandler(params[0]);
                    if (!calhdl[c]) continue;
                    caltyp[c] = parseInt(params[0]);
                    calpar[c] = new Array(params.length - 1);
                    calraw[c] = new Array(params.length >> 1);
                    calref[c] = new Array(params.length >> 1);
                    for (i = 1; i < params.length; i += 2) {
                        calpar[c][i - 1] = parseInt(params[i]);
                        calpar[c][i] = parseInt(params[i + 1]);
                        if (caltyp[c] <= 10) {
                            calraw[c][i >> 1] = (calpar[c][i - 1] + colofs[c]) / coldiv[c];
                            calref[c][i >> 1] = (calpar[c][i] + colofs[c]) / coldiv[c];
                        } else {
                            calraw[c][i >> 1] = _yocto_api.YAPI._decimalToDouble(calpar[c][i - 1]);
                            calref[c][i >> 1] = _yocto_api.YAPI._decimalToDouble(calpar[c][i]);
                        }
                    }
                }
            }
            if (loadval['data'] != null) {
                if (_this._nCols == 0 || coldiv == null || coltyp == null) {
                    return YAPI_IO_ERROR;
                }
                _this._values = [];
                var data = loadval['data'];
                if (typeof data == 'string') {
                    data = _yocto_api.YAPI._decodeWords(data);
                }
                var dat = [];
                c = 0;
                for (var idx in data) {
                    var val;
                    if (coltyp[c] < 2) {
                        val = (data[idx] + colofs[c]) * colscl[c];
                    } else {
                        val = _yocto_api.YAPI._decimalToDouble(data[idx] - 32767);
                    }
                    if (calhdl && calhdl[c]) {
                        // use post-calibration function
                        if (caltyp[c] <= 10) {
                            // linear calibration using unscaled value
                            val = calhdl[c]((data[idx] + colofs[c]) / coldiv[c], caltyp[c], calpar[c], calraw[c], calref[c]);
                        } else if (caltyp[c] > 20) {
                            // custom calibration using raw floating-point value stored by the datalogger
                            val = calhdl[c](val, caltyp[c], calpar[c], calraw[c], calref[c]);
                        }
                    }
                    dat.push(val);
                    if (++c == _this._nCols) {
                        _this._values.push(dat);
                        dat = [];
                        c = 0;
                    }
                }
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Returns the relative start time of the data stream, measured in seconds.
     * For recent firmwares, the value is relative to the present time,
     * which means the value is always negative.
     * If the device uses a firmware older than version 13000, value is
     * relative to the start of the time the device was powered on, and
     * is always positive.
     * If you need an absolute UTC timestamp, use get_startTimeUTC().
     * 
     * @return an unsigned number corresponding to the number of seconds
     *         between the start of the run and the beginning of this data
     *         stream.
     */
    get_startTime() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            return _this2._timeStamp;
        })();
    }

    /**
     * Returns the number of seconds elapsed between  two consecutive
     * rows of this data stream. By default, the data logger records one row
     * per second, but there might be alternative streams at lower resolution
     * created by summarizing the original stream for archiving purposes.
     * 
     * This method does not cause any access to the device, as the value
     * is preloaded in the object at instantiation time.
     * 
     * @return an unsigned number corresponding to a number of seconds.
     */
    get_dataSamplesInterval() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._interval == 0) yield _this3.loadStream();
            return _this3._interval;
        })();
    }
}

exports.YOldDataStream = YOldDataStream; //--- (generated code: YDataLogger class start)
/**
 * YDataLogger Class: DataLogger function interface
 *
 * Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured
 * data automatically, without requiring a permanent connection to a computer.
 * The DataLogger function controls the global parameters of the internal data
 * logger.
 */
//--- (end of generated code: YDataLogger class start)

class YDataLogger extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YDataLogger constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'DataLogger';
        /** @member {number} **/
        this._currentRunIndex = Y_CURRENTRUNINDEX_INVALID;
        /** @member {number} **/
        this._timeUTC = Y_TIMEUTC_INVALID;
        /** @member {number} **/
        this._recording = Y_RECORDING_INVALID;
        /** @member {number} **/
        this._autoStart = Y_AUTOSTART_INVALID;
        /** @member {number} **/
        this._beaconDriven = Y_BEACONDRIVEN_INVALID;
        /** @member {number} **/
        this._clearHistory = Y_CLEARHISTORY_INVALID;
        this.imm_setConst({
            CURRENTRUNINDEX_INVALID: _yocto_api.YAPI.INVALID_UINT,
            TIMEUTC_INVALID: _yocto_api.YAPI.INVALID_LONG,
            RECORDING_OFF: 0,
            RECORDING_ON: 1,
            RECORDING_PENDING: 2,
            RECORDING_INVALID: -1,
            AUTOSTART_OFF: 0,
            AUTOSTART_ON: 1,
            AUTOSTART_INVALID: -1,
            BEACONDRIVEN_OFF: 0,
            BEACONDRIVEN_ON: 1,
            BEACONDRIVEN_INVALID: -1,
            CLEARHISTORY_FALSE: 0,
            CLEARHISTORY_TRUE: 1,
            CLEARHISTORY_INVALID: -1
        });
        //--- (end of generated code: YDataLogger constructor)
        this.const({ DATA_INVALID: -Number.MAX_VALUE });
    }

    // Internal function to retrieve datalogger memory
    //
    getData(runIdx, timeIdx) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            var loadval;

            if (_this4.dataLoggerURL == undefined) {
                _this4.dataLoggerURL = '/logger.json';
            }

            // get the device serial number
            var devid = _this4.module().get_serialNumber();
            if (devid == Y_SERIALNUMBER_INVALID) {
                return null;
            }
            var httpreq = 'GET ' + _this4.dataLoggerURL;
            if (timeIdx) {
                httpreq += '?run=' + runIdx + '&time=' + timeIdx;
            }
            var yreq = yield _yocto_api.YAPI.devRequest(devid, httpreq);
            if (yreq.errorType != _yocto_api.YAPI_SUCCESS) {
                if (yreq.errorMsg.indexOf('HTTP status 404') >= 0 && _this4.dataLoggerURL != '/dataLogger.json') {
                    _this4.dataLoggerURL = '/dataLogger.json';
                    return yield _this4.getData(runIdx, timeIdx);
                }
                return _this4._throw(yreq.errorType, yreq.errorMsg, null);
            }

            return JSON.parse(yreq.result, true);
        })();
    }

    /**
     * Builds a list of all data streams hold by the data logger (legacy method).
     * The caller must pass by reference an empty array to hold YDataStream
     * objects, and the function fills it with objects describing available
     * data sequences.
     *
     * This is the old way to retrieve data from the DataLogger.
     * For new applications, you should rather use get_dataSets()
     * method, or call directly get_recordedData() on the
     * sensor object.
     *
     * @param v {YDataStream[]} : an array of YDataStream objects to be filled in
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_dataStreams(v) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            var loadval = yield _this5.getData(null, null);
            if (loadval == null) {
                return _this5.get_errorType();
            }
            if (loadval.length == 0) {
                return _yocto_api.YAPI_SUCCESS;
            }
            if (Array.isArray(loadval[0])) {
                // old datalogger format: [runIdx, timerel, utc, interval]
                for (var idx in loadval) {
                    var arr = loadval[idx];
                    if (arr.length < 4) {
                        _throw(YAPI_IO_ERROR, 'Unexpected JSON reply format');
                        return YAPI_IO_ERROR;
                    }
                    v.push(new YOldDataStream(_this5, arr[0], arr[1], arr[2], arr[3]));
                }
            } else {
                // new datalogger format: {"id":"...","unit":"...","streams":["...",...]}
                var sets = _this5.parse_dataSets(JSON.stringify(loadval));
                for (var i = 0; i < sets.length; i++) {
                    var ds = sets[i].get_privateDataStreams();
                    for (var si = 0; si < ds.length; si++) {
                        v.push(ds[si]);
                    }
                }
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    //--- (generated code: YDataLogger implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'currentRunIndex':
                this._currentRunIndex = parseInt(val);
                return 1;
            case 'timeUTC':
                this._timeUTC = parseInt(val);
                return 1;
            case 'recording':
                this._recording = parseInt(val);
                return 1;
            case 'autoStart':
                this._autoStart = parseInt(val);
                return 1;
            case 'beaconDriven':
                this._beaconDriven = parseInt(val);
                return 1;
            case 'clearHistory':
                this._clearHistory = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current run number, corresponding to the number of times the module was
     * powered on with the dataLogger enabled at some point.
     *
     * @return {number} an integer corresponding to the current run number, corresponding to the number of
     * times the module was
     *         powered on with the dataLogger enabled at some point
     *
     * On failure, throws an exception or returns YDataLogger.CURRENTRUNINDEX_INVALID.
     */
    get_currentRunIndex() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CURRENTRUNINDEX_INVALID;
                }
            }
            return _this6._currentRunIndex;
        })();
    }

    /**
     * Returns the Unix timestamp for current UTC time, if known.
     *
     * @return {number} an integer corresponding to the Unix timestamp for current UTC time, if known
     *
     * On failure, throws an exception or returns YDataLogger.TIMEUTC_INVALID.
     */
    get_timeUTC() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TIMEUTC_INVALID;
                }
            }
            return _this7._timeUTC;
        })();
    }

    /**
     * Changes the current UTC time reference used for recorded data.
     *
     * @param newval {number} : an integer corresponding to the current UTC time reference used for recorded data
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_timeUTC(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('timeUTC', rest_val);
        })();
    }

    /**
     * Returns the current activation state of the data logger.
     *
     * @return {number} a value among YDataLogger.RECORDING_OFF, YDataLogger.RECORDING_ON and
     * YDataLogger.RECORDING_PENDING corresponding to the current activation state of the data logger
     *
     * On failure, throws an exception or returns YDataLogger.RECORDING_INVALID.
     */
    get_recording() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RECORDING_INVALID;
                }
            }
            return _this9._recording;
        })();
    }

    /**
     * Changes the activation state of the data logger to start/stop recording data.
     *
     * @param newval {number} : a value among YDataLogger.RECORDING_OFF, YDataLogger.RECORDING_ON and
     * YDataLogger.RECORDING_PENDING corresponding to the activation state of the data logger to
     * start/stop recording data
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_recording(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('recording', rest_val);
        })();
    }

    /**
     * Returns the default activation state of the data logger on power up.
     *
     * @return {number} either YDataLogger.AUTOSTART_OFF or YDataLogger.AUTOSTART_ON, according to the
     * default activation state of the data logger on power up
     *
     * On failure, throws an exception or returns YDataLogger.AUTOSTART_INVALID.
     */
    get_autoStart() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_AUTOSTART_INVALID;
                }
            }
            return _this11._autoStart;
        })();
    }

    /**
     * Changes the default activation state of the data logger on power up.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : either YDataLogger.AUTOSTART_OFF or YDataLogger.AUTOSTART_ON, according to
     * the default activation state of the data logger on power up
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_autoStart(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this12._setAttr('autoStart', rest_val);
        })();
    }

    /**
     * Return true if the data logger is synchronised with the localization beacon.
     *
     * @return {number} either YDataLogger.BEACONDRIVEN_OFF or YDataLogger.BEACONDRIVEN_ON
     *
     * On failure, throws an exception or returns YDataLogger.BEACONDRIVEN_INVALID.
     */
    get_beaconDriven() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BEACONDRIVEN_INVALID;
                }
            }
            return _this13._beaconDriven;
        })();
    }

    /**
     * Changes the type of synchronisation of the data logger.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : either YDataLogger.BEACONDRIVEN_OFF or YDataLogger.BEACONDRIVEN_ON,
     * according to the type of synchronisation of the data logger
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_beaconDriven(newval) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this14._setAttr('beaconDriven', rest_val);
        })();
    }

    get_clearHistory() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CLEARHISTORY_INVALID;
                }
            }
            return _this15._clearHistory;
        })();
    }

    set_clearHistory(newval) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this16._setAttr('clearHistory', rest_val);
        })();
    }

    /**
     * Retrieves a data logger for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the data logger is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDataLogger.isOnline() to test if the data logger is
     * indeed online at a given time. In case of ambiguity when looking for
     * a data logger by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the data logger
     *
     * @return {YDataLogger} a YDataLogger object allowing you to drive the data logger.
     */
    static FindDataLogger(func) {
        /** @type {YDataLogger} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('DataLogger', func);
        if (obj == null) {
            obj = new YDataLogger(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('DataLogger', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a data logger for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the data logger is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDataLogger.isOnline() to test if the data logger is
     * indeed online at a given time. In case of ambiguity when looking for
     * a data logger by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the data logger
     *
     * @return {YDataLogger} a YDataLogger object allowing you to drive the data logger.
     */
    static FindDataLoggerInContext(yctx, func) {
        /** @type {YDataLogger} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'DataLogger', func);
        if (obj == null) {
            obj = new YDataLogger(yctx, func);
            _yocto_api.YFunction._AddToCache('DataLogger', func, obj);
        }
        return obj;
    }

    /**
     * Clears the data logger memory and discards all recorded data streams.
     * This method also resets the current run index to zero.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    forgetAllDataStreams() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            return yield _this17.set_clearHistory(Y_CLEARHISTORY_TRUE);
        })();
    }

    /**
     * Returns a list of YDataSet objects that can be used to retrieve
     * all measures stored by the data logger.
     *
     * This function only works if the device uses a recent firmware,
     * as YDataSet objects are not supported by firmwares older than
     * version 13000.
     *
     * @return {YDataSet[]} a list of YDataSet object.
     *
     * On failure, throws an exception or returns an empty list.
     */
    get_dataSets() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            return yield _this18.parse_dataSets((yield _this18._download('logger.json')));
        })();
    }

    parse_dataSets(json) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            /** @type {string[]} **/
            let dslist = [];
            /** @type {YDataSetPtr} **/
            let dataset;
            /** @type {YDataSet[]} **/
            let res = [];
            // may throw an exception
            dslist = _this19.imm_json_get_array(json);
            res.length = 0;
            for (let ii in dslist) {
                dataset = new YDataSet(_this19);
                yield dataset._parse(dslist[ii]);
                res.push(dataset);;
            }
            return res;
        })();
    }

    /**
     * Continues the enumeration of data loggers started using yFirstDataLogger().
     *
     * @return {YDataLogger} a pointer to a YDataLogger object, corresponding to
     *         a data logger currently online, or a null pointer
     *         if there are no more data loggers to enumerate.
     */
    /* */nextDataLogger() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of data loggers currently accessible.
     * Use the method YDataLogger.nextDataLogger() to iterate on
     * next data loggers.
     *
     * @return {YDataLogger} a pointer to a YDataLogger object, corresponding to
     *         the first data logger currently online, or a null pointer
     *         if there are none.
     */
    static FirstDataLogger() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('DataLogger');
        if (next_hwid == null) return null;
        return YDataLogger.FindDataLogger(next_hwid);
    }

    /**
     * Starts the enumeration of data loggers currently accessible.
     * Use the method YDataLogger.nextDataLogger() to iterate on
     * next data loggers.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YDataLogger} a pointer to a YDataLogger object, corresponding to
     *         the first data logger currently online, or a null pointer
     *         if there are none.
     */
    static FirstDataLoggerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('DataLogger');
        if (next_hwid == null) return null;
        return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YDataLogger implementation)
}

exports.YDataLogger = YDataLogger; //--- (generated code: DataLogger functions)

/**
 * comment from .yc definition
 */

function yFindDataLogger(func) {
    return YDataLogger.FindDataLogger(func);
}

/**
 * comment from .yc definition
 */
function yFirstDataLogger() {
    return YDataLogger.FirstDataLogger();
}

//--- (end of generated code: DataLogger functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for DigitalIO functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YDigitalIO = exports.Y_COMMAND_INVALID = exports.Y_PORTSIZE_INVALID = exports.Y_PORTPOLARITY_INVALID = exports.Y_PORTOPENDRAIN_INVALID = exports.Y_PORTDIRECTION_INVALID = exports.Y_PORTSTATE_INVALID = exports.Y_OUTPUTVOLTAGE_INVALID = exports.Y_OUTPUTVOLTAGE_EXT_V = exports.Y_OUTPUTVOLTAGE_USB_3V = exports.Y_OUTPUTVOLTAGE_USB_5V = undefined;
exports.yFindDigitalIO = yFindDigitalIO;
exports.yFirstDigitalIO = yFirstDigitalIO;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YDigitalIO return codes)
//--- (end of YDigitalIO return codes)
//--- (YDigitalIO definitions)
const Y_OUTPUTVOLTAGE_USB_5V = exports.Y_OUTPUTVOLTAGE_USB_5V = 0;
const Y_OUTPUTVOLTAGE_USB_3V = exports.Y_OUTPUTVOLTAGE_USB_3V = 1;
const Y_OUTPUTVOLTAGE_EXT_V = exports.Y_OUTPUTVOLTAGE_EXT_V = 2;
const Y_OUTPUTVOLTAGE_INVALID = exports.Y_OUTPUTVOLTAGE_INVALID = -1;
const Y_PORTSTATE_INVALID = exports.Y_PORTSTATE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PORTDIRECTION_INVALID = exports.Y_PORTDIRECTION_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PORTOPENDRAIN_INVALID = exports.Y_PORTOPENDRAIN_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PORTPOLARITY_INVALID = exports.Y_PORTPOLARITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_PORTSIZE_INVALID = exports.Y_PORTSIZE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YDigitalIO definitions)

//--- (YDigitalIO class start)
/**
 * YDigitalIO Class: Digital IO function interface
 *
 * The Yoctopuce application programming interface allows you to switch the state of each
 * bit of the I/O port. You can switch all bits at once, or one by one. The library
 * can also automatically generate short pulses of a determined duration. Electrical behavior
 * of each I/O can be modified (open drain and reverse polarity).
 */
//--- (end of YDigitalIO class start)

class YDigitalIO extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YDigitalIO constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'DigitalIO';
        /** @member {number} **/
        this._portState = Y_PORTSTATE_INVALID;
        /** @member {number} **/
        this._portDirection = Y_PORTDIRECTION_INVALID;
        /** @member {number} **/
        this._portOpenDrain = Y_PORTOPENDRAIN_INVALID;
        /** @member {number} **/
        this._portPolarity = Y_PORTPOLARITY_INVALID;
        /** @member {number} **/
        this._portSize = Y_PORTSIZE_INVALID;
        /** @member {number} **/
        this._outputVoltage = Y_OUTPUTVOLTAGE_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            PORTSTATE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PORTDIRECTION_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PORTOPENDRAIN_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PORTPOLARITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            PORTSIZE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            OUTPUTVOLTAGE_USB_5V: 0,
            OUTPUTVOLTAGE_USB_3V: 1,
            OUTPUTVOLTAGE_EXT_V: 2,
            OUTPUTVOLTAGE_INVALID: -1,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YDigitalIO constructor)
    }

    //--- (YDigitalIO implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'portState':
                this._portState = parseInt(val);
                return 1;
            case 'portDirection':
                this._portDirection = parseInt(val);
                return 1;
            case 'portOpenDrain':
                this._portOpenDrain = parseInt(val);
                return 1;
            case 'portPolarity':
                this._portPolarity = parseInt(val);
                return 1;
            case 'portSize':
                this._portSize = parseInt(val);
                return 1;
            case 'outputVoltage':
                this._outputVoltage = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the digital IO port state: bit 0 represents input 0, and so on.
     *
     * @return {number} an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on
     *
     * On failure, throws an exception or returns YDigitalIO.PORTSTATE_INVALID.
     */
    get_portState() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTSTATE_INVALID;
                }
            }
            return _this._portState;
        })();
    }

    /**
     * Changes the digital IO port state: bit 0 represents input 0, and so on. This function has no effect
     * on bits configured as input in portDirection.
     *
     * @param newval {number} : an integer corresponding to the digital IO port state: bit 0 represents
     * input 0, and so on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_portState(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('portState', rest_val);
        })();
    }

    /**
     * Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.
     *
     * @return {number} an integer corresponding to the IO direction of all bits of the port: 0 makes a
     * bit an input, 1 makes it an output
     *
     * On failure, throws an exception or returns YDigitalIO.PORTDIRECTION_INVALID.
     */
    get_portDirection() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTDIRECTION_INVALID;
                }
            }
            return _this3._portDirection;
        })();
    }

    /**
     * Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.
     * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
     *
     * @param newval {number} : an integer corresponding to the IO direction of all bits of the port: 0
     * makes a bit an input, 1 makes it an output
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_portDirection(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('portDirection', rest_val);
        })();
    }

    /**
     * Returns the electrical interface for each bit of the port. For each bit set to 0  the matching I/O
     * works in the regular,
     * intuitive way, for each bit set to 1, the I/O works in reverse mode.
     *
     * @return {number} an integer corresponding to the electrical interface for each bit of the port
     *
     * On failure, throws an exception or returns YDigitalIO.PORTOPENDRAIN_INVALID.
     */
    get_portOpenDrain() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTOPENDRAIN_INVALID;
                }
            }
            return _this5._portOpenDrain;
        })();
    }

    /**
     * Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes
     * it an open-drain (open-collector) input/output. Remember to call the
     * saveToFlash() method  to make sure the setting is kept after a reboot.
     *
     * @param newval {number} : an integer corresponding to the electrical interface for each bit of the port
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_portOpenDrain(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('portOpenDrain', rest_val);
        })();
    }

    /**
     * Returns the polarity of all the bits of the port.  For each bit set to 0, the matching I/O works the regular,
     * intuitive way; for each bit set to 1, the I/O works in reverse mode.
     *
     * @return {number} an integer corresponding to the polarity of all the bits of the port
     *
     * On failure, throws an exception or returns YDigitalIO.PORTPOLARITY_INVALID.
     */
    get_portPolarity() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTPOLARITY_INVALID;
                }
            }
            return _this7._portPolarity;
        })();
    }

    /**
     * Changes the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output.
     * Remember to call the saveToFlash() method  to make sure the setting will be kept after a reboot.
     *
     * @param newval {number} : an integer corresponding to the polarity of all the bits of the port: 0
     * makes a bit an input, 1 makes it an output
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_portPolarity(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('portPolarity', rest_val);
        })();
    }

    /**
     * Returns the number of bits implemented in the I/O port.
     *
     * @return {number} an integer corresponding to the number of bits implemented in the I/O port
     *
     * On failure, throws an exception or returns YDigitalIO.PORTSIZE_INVALID.
     */
    get_portSize() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTSIZE_INVALID;
                }
            }
            return _this9._portSize;
        })();
    }

    /**
     * Returns the voltage source used to drive output bits.
     *
     * @return {number} a value among YDigitalIO.OUTPUTVOLTAGE_USB_5V, YDigitalIO.OUTPUTVOLTAGE_USB_3V and
     * YDigitalIO.OUTPUTVOLTAGE_EXT_V corresponding to the voltage source used to drive output bits
     *
     * On failure, throws an exception or returns YDigitalIO.OUTPUTVOLTAGE_INVALID.
     */
    get_outputVoltage() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_OUTPUTVOLTAGE_INVALID;
                }
            }
            return _this10._outputVoltage;
        })();
    }

    /**
     * Changes the voltage source used to drive output bits.
     * Remember to call the saveToFlash() method  to make sure the setting is kept after a reboot.
     *
     * @param newval {number} : a value among YDigitalIO.OUTPUTVOLTAGE_USB_5V,
     * YDigitalIO.OUTPUTVOLTAGE_USB_3V and YDigitalIO.OUTPUTVOLTAGE_EXT_V corresponding to the voltage
     * source used to drive output bits
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_outputVoltage(newval) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this11._setAttr('outputVoltage', rest_val);
        })();
    }

    get_command() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this12._command;
        })();
    }

    set_command(newval) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this13._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a digital IO port for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the digital IO port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDigitalIO.isOnline() to test if the digital IO port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a digital IO port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the digital IO port
     *
     * @return {YDigitalIO} a YDigitalIO object allowing you to drive the digital IO port.
     */
    static FindDigitalIO(func) {
        /** @type {YDigitalIO} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('DigitalIO', func);
        if (obj == null) {
            obj = new YDigitalIO(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('DigitalIO', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a digital IO port for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the digital IO port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDigitalIO.isOnline() to test if the digital IO port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a digital IO port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the digital IO port
     *
     * @return {YDigitalIO} a YDigitalIO object allowing you to drive the digital IO port.
     */
    static FindDigitalIOInContext(yctx, func) {
        /** @type {YDigitalIO} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'DigitalIO', func);
        if (obj == null) {
            obj = new YDigitalIO(yctx, func);
            _yocto_api.YFunction._AddToCache('DigitalIO', func, obj);
        }
        return obj;
    }

    /**
     * Sets a single bit of the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     * @param bitstate {number} : the state of the bit (1 or 0)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_bitState(bitno, bitstate) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (!(bitstate >= 0)) {
                return _this14._throw(YAPI_INVALID_ARGUMENT, 'invalid bitstate', YAPI_INVALID_ARGUMENT);
            }
            if (!(bitstate <= 1)) {
                return _this14._throw(YAPI_INVALID_ARGUMENT, 'invalid bitstate', YAPI_INVALID_ARGUMENT);
            }
            return yield _this14.set_command(String.fromCharCode(82 + bitstate) + '' + String(Math.round(bitno)));
        })();
    }

    /**
     * Returns the state of a single bit of the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     *
     * @return {number} the bit state (0 or 1)
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_bitState(bitno) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let portVal;
            portVal = yield _this15.get_portState();
            return portVal >> bitno & 1;
        })();
    }

    /**
     * Reverts a single bit of the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    toggle_bitState(bitno) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            return yield _this16.set_command('T' + String(Math.round(bitno)));
        })();
    }

    /**
     * Changes  the direction of a single bit from the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     * @param bitdirection {number} : direction to set, 0 makes the bit an input, 1 makes it an output.
     *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_bitDirection(bitno, bitdirection) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (!(bitdirection >= 0)) {
                return _this17._throw(YAPI_INVALID_ARGUMENT, 'invalid direction', YAPI_INVALID_ARGUMENT);
            }
            if (!(bitdirection <= 1)) {
                return _this17._throw(YAPI_INVALID_ARGUMENT, 'invalid direction', YAPI_INVALID_ARGUMENT);
            }
            return yield _this17.set_command(String.fromCharCode(73 + 6 * bitdirection) + '' + String(Math.round(bitno)));
        })();
    }

    /**
     * Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1  an output).
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_bitDirection(bitno) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let portDir;
            portDir = yield _this18.get_portDirection();
            return portDir >> bitno & 1;
        })();
    }

    /**
     * Changes the polarity of a single bit from the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0.
     * @param bitpolarity {number} : polarity to set, 0 makes the I/O work in regular mode, 1 makes the
     * I/O  works in reverse mode.
     *         Remember to call the   saveToFlash() method to make sure the setting is kept after a reboot.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_bitPolarity(bitno, bitpolarity) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            if (!(bitpolarity >= 0)) {
                return _this19._throw(YAPI_INVALID_ARGUMENT, 'invalid bitpolarity', YAPI_INVALID_ARGUMENT);
            }
            if (!(bitpolarity <= 1)) {
                return _this19._throw(YAPI_INVALID_ARGUMENT, 'invalid bitpolarity', YAPI_INVALID_ARGUMENT);
            }
            return yield _this19.set_command(String.fromCharCode(110 + 4 * bitpolarity) + '' + String(Math.round(bitno)));
        })();
    }

    /**
     * Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1
     * means the I/O  works in reverse mode).
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_bitPolarity(bitno) {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let portPol;
            portPol = yield _this20.get_portPolarity();
            return portPol >> bitno & 1;
        })();
    }

    /**
     * Changes  the electrical interface of a single bit from the I/O port.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     * @param opendrain {number} : 0 makes a bit a regular input/output, 1 makes
     *         it an open-drain (open-collector) input/output. Remember to call the
     *         saveToFlash() method to make sure the setting is kept after a reboot.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_bitOpenDrain(bitno, opendrain) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            if (!(opendrain >= 0)) {
                return _this21._throw(YAPI_INVALID_ARGUMENT, 'invalid state', YAPI_INVALID_ARGUMENT);
            }
            if (!(opendrain <= 1)) {
                return _this21._throw(YAPI_INVALID_ARGUMENT, 'invalid state', YAPI_INVALID_ARGUMENT);
            }
            return yield _this21.set_command(String.fromCharCode(100 - 32 * opendrain) + '' + String(Math.round(bitno)));
        })();
    }

    /**
     * Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an
     * input, 1  an output).
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     *
     * @return {number}   0 means the a bit is a regular input/output, 1 means the bit is an open-drain
     *         (open-collector) input/output.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_bitOpenDrain(bitno) {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let portOpenDrain;
            portOpenDrain = yield _this22.get_portOpenDrain();
            return portOpenDrain >> bitno & 1;
        })();
    }

    /**
     * Triggers a pulse on a single bit for a specified duration. The specified bit
     * will be turned to 1, and then back to 0 after the given duration.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     * @param ms_duration {number} : desired pulse duration in milliseconds. Be aware that the device time
     *         resolution is not guaranteed up to the millisecond.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pulse(bitno, ms_duration) {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            return yield _this23.set_command('Z' + String(Math.round(bitno)) + ',0,' + String(Math.round(ms_duration)));
        })();
    }

    /**
     * Schedules a pulse on a single bit for a specified duration. The specified bit
     * will be turned to 1, and then back to 0 after the given duration.
     *
     * @param bitno {number} : the bit number; lowest bit has index 0
     * @param ms_delay {number} : waiting time before the pulse, in milliseconds
     * @param ms_duration {number} : desired pulse duration in milliseconds. Be aware that the device time
     *         resolution is not guaranteed up to the millisecond.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    delayedPulse(bitno, ms_delay, ms_duration) {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            return yield _this24.set_command('Z' + String(Math.round(bitno)) + ',' + String(Math.round(ms_delay)) + ',' + String(Math.round(ms_duration)));
        })();
    }

    /**
     * Continues the enumeration of digital IO ports started using yFirstDigitalIO().
     *
     * @return {YDigitalIO} a pointer to a YDigitalIO object, corresponding to
     *         a digital IO port currently online, or a null pointer
     *         if there are no more digital IO ports to enumerate.
     */
    /* */nextDigitalIO() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YDigitalIO.FindDigitalIOInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of digital IO ports currently accessible.
     * Use the method YDigitalIO.nextDigitalIO() to iterate on
     * next digital IO ports.
     *
     * @return {YDigitalIO} a pointer to a YDigitalIO object, corresponding to
     *         the first digital IO port currently online, or a null pointer
     *         if there are none.
     */
    static FirstDigitalIO() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('DigitalIO');
        if (next_hwid == null) return null;
        return YDigitalIO.FindDigitalIO(next_hwid);
    }

    /**
     * Starts the enumeration of digital IO ports currently accessible.
     * Use the method YDigitalIO.nextDigitalIO() to iterate on
     * next digital IO ports.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YDigitalIO} a pointer to a YDigitalIO object, corresponding to
     *         the first digital IO port currently online, or a null pointer
     *         if there are none.
     */
    static FirstDigitalIOInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('DigitalIO');
        if (next_hwid == null) return null;
        return YDigitalIO.FindDigitalIOInContext(yctx, next_hwid);
    }

    //--- (end of YDigitalIO implementation)
}

exports.YDigitalIO = YDigitalIO; //--- (DigitalIO functions)

/**
 * comment from .yc definition
 */

function yFindDigitalIO(func) {
    return YDigitalIO.FindDigitalIO(func);
}

/**
 * comment from .yc definition
 */
function yFirstDigitalIO() {
    return YDigitalIO.FirstDigitalIO();
}

//--- (end of DigitalIO functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YDisplay = exports.Y_ALIGN_BOTTOM_RIGHT = exports.Y_ALIGN_BASELINE_RIGHT = exports.Y_ALIGN_CENTER_RIGHT = exports.Y_ALIGN_TOP_RIGHT = exports.Y_ALIGN_BOTTOM_DECIMAL = exports.Y_ALIGN_BASELINE_DECIMAL = exports.Y_ALIGN_CENTER_DECIMAL = exports.Y_ALIGN_TOP_DECIMAL = exports.Y_ALIGN_BOTTOM_CENTER = exports.Y_ALIGN_BASELINE_CENTER = exports.Y_ALIGN_CENTER = exports.Y_ALIGN_TOP_CENTER = exports.Y_ALIGN_BOTTOM_LEFT = exports.Y_ALIGN_BASELINE_LEFT = exports.Y_ALIGN_CENTER_LEFT = exports.Y_ALIGN_TOP_LEFT = exports.Y_COMMAND_INVALID = exports.Y_LAYERCOUNT_INVALID = exports.Y_LAYERHEIGHT_INVALID = exports.Y_LAYERWIDTH_INVALID = exports.Y_DISPLAYHEIGHT_INVALID = exports.Y_DISPLAYWIDTH_INVALID = exports.Y_BRIGHTNESS_INVALID = exports.Y_STARTUPSEQ_INVALID = exports.Y_DISPLAYTYPE_INVALID = exports.Y_DISPLAYTYPE_RGB = exports.Y_DISPLAYTYPE_GRAY = exports.Y_DISPLAYTYPE_MONO = exports.Y_ORIENTATION_INVALID = exports.Y_ORIENTATION_DOWN = exports.Y_ORIENTATION_RIGHT = exports.Y_ORIENTATION_UP = exports.Y_ORIENTATION_LEFT = exports.Y_ENABLED_INVALID = exports.Y_ENABLED_TRUE = exports.Y_ENABLED_FALSE = undefined;
exports.yFindDisplay = yFindDisplay;
exports.yFirstDisplay = yFirstDisplay;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_display.js 19607 2015-03-05 10:36:54Z seb $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements yFindDisplay(), the high-level API for Display functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - - 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YDisplay definitions)
const Y_ENABLED_FALSE = exports.Y_ENABLED_FALSE = 0;
const Y_ENABLED_TRUE = exports.Y_ENABLED_TRUE = 1;
const Y_ENABLED_INVALID = exports.Y_ENABLED_INVALID = -1;
const Y_ORIENTATION_LEFT = exports.Y_ORIENTATION_LEFT = 0;
const Y_ORIENTATION_UP = exports.Y_ORIENTATION_UP = 1;
const Y_ORIENTATION_RIGHT = exports.Y_ORIENTATION_RIGHT = 2;
const Y_ORIENTATION_DOWN = exports.Y_ORIENTATION_DOWN = 3;
const Y_ORIENTATION_INVALID = exports.Y_ORIENTATION_INVALID = -1;
const Y_DISPLAYTYPE_MONO = exports.Y_DISPLAYTYPE_MONO = 0;
const Y_DISPLAYTYPE_GRAY = exports.Y_DISPLAYTYPE_GRAY = 1;
const Y_DISPLAYTYPE_RGB = exports.Y_DISPLAYTYPE_RGB = 2;
const Y_DISPLAYTYPE_INVALID = exports.Y_DISPLAYTYPE_INVALID = -1;
const Y_STARTUPSEQ_INVALID = exports.Y_STARTUPSEQ_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_BRIGHTNESS_INVALID = exports.Y_BRIGHTNESS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_DISPLAYWIDTH_INVALID = exports.Y_DISPLAYWIDTH_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_DISPLAYHEIGHT_INVALID = exports.Y_DISPLAYHEIGHT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LAYERWIDTH_INVALID = exports.Y_LAYERWIDTH_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LAYERHEIGHT_INVALID = exports.Y_LAYERHEIGHT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LAYERCOUNT_INVALID = exports.Y_LAYERCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of generated code: YDisplay definitions)

//--- (generated code: YDisplayLayer definitions)
const Y_ALIGN_TOP_LEFT = exports.Y_ALIGN_TOP_LEFT = 0;
const Y_ALIGN_CENTER_LEFT = exports.Y_ALIGN_CENTER_LEFT = 1;
const Y_ALIGN_BASELINE_LEFT = exports.Y_ALIGN_BASELINE_LEFT = 2;
const Y_ALIGN_BOTTOM_LEFT = exports.Y_ALIGN_BOTTOM_LEFT = 3;
const Y_ALIGN_TOP_CENTER = exports.Y_ALIGN_TOP_CENTER = 4;
const Y_ALIGN_CENTER = exports.Y_ALIGN_CENTER = 5;
const Y_ALIGN_BASELINE_CENTER = exports.Y_ALIGN_BASELINE_CENTER = 6;
const Y_ALIGN_BOTTOM_CENTER = exports.Y_ALIGN_BOTTOM_CENTER = 7;
const Y_ALIGN_TOP_DECIMAL = exports.Y_ALIGN_TOP_DECIMAL = 8;
const Y_ALIGN_CENTER_DECIMAL = exports.Y_ALIGN_CENTER_DECIMAL = 9;
const Y_ALIGN_BASELINE_DECIMAL = exports.Y_ALIGN_BASELINE_DECIMAL = 10;
const Y_ALIGN_BOTTOM_DECIMAL = exports.Y_ALIGN_BOTTOM_DECIMAL = 11;
const Y_ALIGN_TOP_RIGHT = exports.Y_ALIGN_TOP_RIGHT = 12;
const Y_ALIGN_CENTER_RIGHT = exports.Y_ALIGN_CENTER_RIGHT = 13;
const Y_ALIGN_BASELINE_RIGHT = exports.Y_ALIGN_BASELINE_RIGHT = 14;
const Y_ALIGN_BOTTOM_RIGHT = exports.Y_ALIGN_BOTTOM_RIGHT = 15;
//--- (end of generated code: YDisplayLayer definitions)

//--- (generated code: YDisplayLayer class start)
/**
 * YDisplayLayer Class: DisplayLayer object interface
 *
 * A DisplayLayer is an image layer containing objects to display
 * (bitmaps, text, etc.). The content is displayed only when
 * the layer is active on the screen (and not masked by other
 * overlapping layers).
 */
//--- (end of generated code: YDisplayLayer class start)

class YDisplayLayer {
    constructor(obj_parent, str_id) {
        this._display = obj_parent;
        this._id = str_id;
        this._cmdbuff = '';
        this._hidden = false;
        //--- (generated code: YDisplayLayer constructor)
        /** @member {number} **/
        this.ALIGN_TOP_LEFT = 0;
        /** @member {number} **/
        this.ALIGN_CENTER_LEFT = 1;
        /** @member {number} **/
        this.ALIGN_BASELINE_LEFT = 2;
        /** @member {number} **/
        this.ALIGN_BOTTOM_LEFT = 3;
        /** @member {number} **/
        this.ALIGN_TOP_CENTER = 4;
        /** @member {number} **/
        this.ALIGN_CENTER = 5;
        /** @member {number} **/
        this.ALIGN_BASELINE_CENTER = 6;
        /** @member {number} **/
        this.ALIGN_BOTTOM_CENTER = 7;
        /** @member {number} **/
        this.ALIGN_TOP_DECIMAL = 8;
        /** @member {number} **/
        this.ALIGN_CENTER_DECIMAL = 9;
        /** @member {number} **/
        this.ALIGN_BASELINE_DECIMAL = 10;
        /** @member {number} **/
        this.ALIGN_BOTTOM_DECIMAL = 11;
        /** @member {number} **/
        this.ALIGN_TOP_RIGHT = 12;
        /** @member {number} **/
        this.ALIGN_CENTER_RIGHT = 13;
        /** @member {number} **/
        this.ALIGN_BASELINE_RIGHT = 14;
        /** @member {number} **/
        this.ALIGN_BOTTOM_RIGHT = 15;
        //--- (end of generated code: YDisplayLayer constructor)
    }

    // internal function to flush any pending command for this layer
    flush_now() {
        var _this = this;

        return _asyncToGenerator(function* () {
            var res = _yocto_api.YAPI_SUCCESS;
            if (_this._cmdbuff != '') {
                res = yield _this._display.sendCommand(_this._cmdbuff);
                _this._cmdbuff = '';
            }
            return res;
        })();
    }

    // internal function to buffer a command for this layer
    command_push(str_cmd) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            var res = _yocto_api.YAPI_SUCCESS;

            if (_this2._cmdbuff.length + str_cmd.length >= 100) {
                // force flush before, to prevent overflow
                res = yield _this2.flush_now();
            }
            if (_this2._cmdbuff == '') {
                // always prepend layer ID first
                _this2._cmdbuff = _this2._id;
            }
            _this2._cmdbuff += str_cmd;
            return res;
        })();
    }

    // internal function to send a command for this layer
    command_flush(str_cmd) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            var res = yield _this3.command_push(str_cmd);
            if (_this3._hidden) {
                return res;
            }
            return yield _this3.flush_now();
        })();
    }

    //--- (generated code: YDisplayLayer implementation)

    /**
     * Reverts the layer to its initial state (fully transparent, default settings).
     * Reinitializes the drawing pointer to the upper left position,
     * and selects the most visible pen color. If you only want to erase the layer
     * content, use the method clear() instead.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    reset() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            _this4._hidden = false;
            return yield _this4.command_flush('X');
        })();
    }

    /**
     * Erases the whole content of the layer (makes it fully transparent).
     * This method does not change any other attribute of the layer.
     * To reinitialize the layer attributes to defaults settings, use the method
     * reset() instead.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    clear() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            return yield _this5.command_flush('x');
        })();
    }

    /**
     * Selects the pen color for all subsequent drawing functions,
     * including text drawing. The pen color is provided as an RGB value.
     * For grayscale or monochrome displays, the value is
     * automatically converted to the proper range.
     *
     * @param color {number} : the desired pen color, as a 24-bit RGB value
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    selectColorPen(color) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            return yield _this6.command_push('c' + ('000000' + color.toString(16)).slice(-6));
        })();
    }

    /**
     * Selects the pen gray level for all subsequent drawing functions,
     * including text drawing. The gray level is provided as a number between
     * 0 (black) and 255 (white, or whichever the lighest color is).
     * For monochrome displays (without gray levels), any value
     * lower than 128 is rendered as black, and any value equal
     * or above to 128 is non-black.
     *
     * @param graylevel {number} : the desired gray level, from 0 to 255
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    selectGrayPen(graylevel) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            return yield _this7.command_push('g' + String(Math.round(graylevel)));
        })();
    }

    /**
     * Selects an eraser instead of a pen for all subsequent drawing functions,
     * except for bitmap copy functions. Any point drawn using the eraser
     * becomes transparent (as when the layer is empty), showing the other
     * layers beneath it.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    selectEraser() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            return yield _this8.command_push('e');
        })();
    }

    /**
     * Enables or disables anti-aliasing for drawing oblique lines and circles.
     * Anti-aliasing provides a smoother aspect when looked from far enough,
     * but it can add fuzzyness when the display is looked from very close.
     * At the end of the day, it is your personal choice.
     * Anti-aliasing is enabled by default on grayscale and color displays,
     * but you can disable it if you prefer. This setting has no effect
     * on monochrome displays.
     *
     * @param mode {boolean} : <t>true</t> to enable antialiasing, <t>false</t> to
     *         disable it.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    setAntialiasingMode(mode) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            return yield _this9.command_push('a' + (mode ? "1" : "0"));
        })();
    }

    /**
     * Draws a single pixel at the specified position.
     *
     * @param x {number} : the distance from left of layer, in pixels
     * @param y {number} : the distance from top of layer, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawPixel(x, y) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            return yield _this10.command_flush('P' + String(Math.round(x)) + ',' + String(Math.round(y)));
        })();
    }

    /**
     * Draws an empty rectangle at a specified position.
     *
     * @param x1 {number} : the distance from left of layer to the left border of the rectangle, in pixels
     * @param y1 {number} : the distance from top of layer to the top border of the rectangle, in pixels
     * @param x2 {number} : the distance from left of layer to the right border of the rectangle, in pixels
     * @param y2 {number} : the distance from top of layer to the bottom border of the rectangle, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawRect(x1, y1, x2, y2) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            return yield _this11.command_flush('R' + String(Math.round(x1)) + ',' + String(Math.round(y1)) + ',' + String(Math.round(x2)) + ',' + String(Math.round(y2)));
        })();
    }

    /**
     * Draws a filled rectangular bar at a specified position.
     *
     * @param x1 {number} : the distance from left of layer to the left border of the rectangle, in pixels
     * @param y1 {number} : the distance from top of layer to the top border of the rectangle, in pixels
     * @param x2 {number} : the distance from left of layer to the right border of the rectangle, in pixels
     * @param y2 {number} : the distance from top of layer to the bottom border of the rectangle, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawBar(x1, y1, x2, y2) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            return yield _this12.command_flush('B' + String(Math.round(x1)) + ',' + String(Math.round(y1)) + ',' + String(Math.round(x2)) + ',' + String(Math.round(y2)));
        })();
    }

    /**
     * Draws an empty circle at a specified position.
     *
     * @param x {number} : the distance from left of layer to the center of the circle, in pixels
     * @param y {number} : the distance from top of layer to the center of the circle, in pixels
     * @param r {number} : the radius of the circle, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawCircle(x, y, r) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            return yield _this13.command_flush('C' + String(Math.round(x)) + ',' + String(Math.round(y)) + ',' + String(Math.round(r)));
        })();
    }

    /**
     * Draws a filled disc at a given position.
     *
     * @param x {number} : the distance from left of layer to the center of the disc, in pixels
     * @param y {number} : the distance from top of layer to the center of the disc, in pixels
     * @param r {number} : the radius of the disc, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawDisc(x, y, r) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            return yield _this14.command_flush('D' + String(Math.round(x)) + ',' + String(Math.round(y)) + ',' + String(Math.round(r)));
        })();
    }

    /**
     * Selects a font to use for the next text drawing functions, by providing the name of the
     * font file. You can use a built-in font as well as a font file that you have previously
     * uploaded to the device built-in memory. If you experience problems selecting a font
     * file, check the device logs for any error message such as missing font file or bad font
     * file format.
     *
     * @param fontname {string} : the font file name
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    selectFont(fontname) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            return yield _this15.command_push('&' + fontname + '' + String.fromCharCode(27));
        })();
    }

    /**
     * Draws a text string at the specified position. The point of the text that is aligned
     * to the specified pixel position is called the anchor point, and can be chosen among
     * several options. Text is rendered from left to right, without implicit wrapping.
     *
     * @param x {number} : the distance from left of layer to the text anchor point, in pixels
     * @param y {number} : the distance from top of layer to the text anchor point, in pixels
     * @param anchor {ALIGN} : the text anchor point, chosen among the YDisplayLayer.ALIGN enumeration:
     *         YDisplayLayer.ALIGN_TOP_LEFT,    YDisplayLayer.ALIGN_CENTER_LEFT,   
     *         YDisplayLayer.ALIGN_BASELINE_LEFT,    YDisplayLayer.ALIGN_BOTTOM_LEFT,
     *         YDisplayLayer.ALIGN_TOP_CENTER,  YDisplayLayer.ALIGN_CENTER,        
     *         YDisplayLayer.ALIGN_BASELINE_CENTER,  YDisplayLayer.ALIGN_BOTTOM_CENTER,
     *         YDisplayLayer.ALIGN_TOP_DECIMAL, YDisplayLayer.ALIGN_CENTER_DECIMAL,
     *         YDisplayLayer.ALIGN_BASELINE_DECIMAL, YDisplayLayer.ALIGN_BOTTOM_DECIMAL,
     *         YDisplayLayer.ALIGN_TOP_RIGHT,   YDisplayLayer.ALIGN_CENTER_RIGHT,  
     *         YDisplayLayer.ALIGN_BASELINE_RIGHT,   YDisplayLayer.ALIGN_BOTTOM_RIGHT.
     * @param text {string} : the text string to draw
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawText(x, y, anchor, text) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            return yield _this16.command_flush('T' + String(Math.round(x)) + ',' + String(Math.round(y)) + ',' + String(anchor) + ',' + text + '' + String.fromCharCode(27));
        })();
    }

    /**
     * Draws a GIF image at the specified position. The GIF image must have been previously
     * uploaded to the device built-in memory. If you experience problems using an image
     * file, check the device logs for any error message such as missing image file or bad
     * image file format.
     *
     * @param x {number} : the distance from left of layer to the left of the image, in pixels
     * @param y {number} : the distance from top of layer to the top of the image, in pixels
     * @param imagename {string} : the GIF file name
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawImage(x, y, imagename) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            return yield _this17.command_flush('*' + String(Math.round(x)) + ',' + String(Math.round(y)) + ',' + imagename + '' + String.fromCharCode(27));
        })();
    }

    /**
     * Draws a bitmap at the specified position. The bitmap is provided as a binary object,
     * where each pixel maps to a bit, from left to right and from top to bottom.
     * The most significant bit of each byte maps to the leftmost pixel, and the least
     * significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the
     * layer selected pen color. Bits set to 0 are drawn using the specified background
     * gray level, unless -1 is specified, in which case they are not drawn at all
     * (as if transparent).
     *
     * @param x {number} : the distance from left of layer to the left of the bitmap, in pixels
     * @param y {number} : the distance from top of layer to the top of the bitmap, in pixels
     * @param w {number} : the width of the bitmap, in pixels
     * @param bitmap {Uint8Array} : a binary object
     * @param bgcol {number} : the background gray level to use for zero bits (0 = black,
     *         255 = white), or -1 to leave the pixels unchanged
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drawBitmap(x, y, w, bitmap, bgcol) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let destname;
            destname = 'layer' + String(Math.round(_this18._id)) + ':' + String(Math.round(w)) + ',' + String(Math.round(bgcol)) + '@' + String(Math.round(x)) + ',' + String(Math.round(y));
            return yield _this18._display.upload(destname, bitmap);
        })();
    }

    /**
     * Moves the drawing pointer of this layer to the specified position.
     *
     * @param x {number} : the distance from left of layer, in pixels
     * @param y {number} : the distance from top of layer, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    moveTo(x, y) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.command_push('@' + String(Math.round(x)) + ',' + String(Math.round(y)));
        })();
    }

    /**
     * Draws a line from current drawing pointer position to the specified position.
     * The specified destination pixel is included in the line. The pointer position
     * is then moved to the end point of the line.
     *
     * @param x {number} : the distance from left of layer to the end point of the line, in pixels
     * @param y {number} : the distance from top of layer to the end point of the line, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    lineTo(x, y) {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            return yield _this20.command_flush('-' + String(Math.round(x)) + ',' + String(Math.round(y)));
        })();
    }

    /**
     * Outputs a message in the console area, and advances the console pointer accordingly.
     * The console pointer position is automatically moved to the beginning
     * of the next line when a newline character is met, or when the right margin
     * is hit. When the new text to display extends below the lower margin, the
     * console area is automatically scrolled up.
     *
     * @param text {string} : the message to display
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    consoleOut(text) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            return yield _this21.command_flush('!' + text + '' + String.fromCharCode(27));
        })();
    }

    /**
     * Sets up display margins for the consoleOut function.
     *
     * @param x1 {number} : the distance from left of layer to the left margin, in pixels
     * @param y1 {number} : the distance from top of layer to the top margin, in pixels
     * @param x2 {number} : the distance from left of layer to the right margin, in pixels
     * @param y2 {number} : the distance from top of layer to the bottom margin, in pixels
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    setConsoleMargins(x1, y1, x2, y2) {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            return yield _this22.command_push('m' + String(Math.round(x1)) + ',' + String(Math.round(y1)) + ',' + String(Math.round(x2)) + ',' + String(Math.round(y2)));
        })();
    }

    /**
     * Sets up the background color used by the clearConsole function and by
     * the console scrolling feature.
     *
     * @param bgcol {number} : the background gray level to use when scrolling (0 = black,
     *         255 = white), or -1 for transparent
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    setConsoleBackground(bgcol) {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            return yield _this23.command_push('b' + String(Math.round(bgcol)));
        })();
    }

    /**
     * Sets up the wrapping behaviour used by the consoleOut function.
     *
     * @param wordwrap {boolean} : true to wrap only between words,
     *         false to wrap on the last column anyway.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    setConsoleWordWrap(wordwrap) {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            return yield _this24.command_push('w' + (wordwrap ? "1" : "0"));
        })();
    }

    /**
     * Blanks the console area within console margins, and resets the console pointer
     * to the upper left corner of the console.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    clearConsole() {
        var _this25 = this;

        return _asyncToGenerator(function* () {
            return yield _this25.command_flush('^');
        })();
    }

    /**
     * Sets the position of the layer relative to the display upper left corner.
     * When smooth scrolling is used, the display offset of the layer is
     * automatically updated during the next milliseconds to animate the move of the layer.
     *
     * @param x {number} : the distance from left of display to the upper left corner of the layer
     * @param y {number} : the distance from top of display to the upper left corner of the layer
     * @param scrollTime {number} : number of milliseconds to use for smooth scrolling, or
     *         0 if the scrolling should be immediate.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    setLayerPosition(x, y, scrollTime) {
        var _this26 = this;

        return _asyncToGenerator(function* () {
            return yield _this26.command_flush('#' + String(Math.round(x)) + ',' + String(Math.round(y)) + ',' + String(Math.round(scrollTime)));
        })();
    }

    /**
     * Hides the layer. The state of the layer is perserved but the layer is not displayed
     * on the screen until the next call to unhide(). Hiding the layer can positively
     * affect the drawing speed, since it postpones the rendering until all operations are
     * completed (double-buffering).
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    hide() {
        var _this27 = this;

        return _asyncToGenerator(function* () {
            yield _this27.command_push('h');
            _this27._hidden = true;
            return yield _this27.flush_now();
        })();
    }

    /**
     * Shows the layer. Shows the layer again after a hide command.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    unhide() {
        var _this28 = this;

        return _asyncToGenerator(function* () {
            _this28._hidden = false;
            return yield _this28.command_flush('s');
        })();
    }

    /**
     * Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.
     *
     * @return {YDisplay} an YDisplay object
     */
    get_display() {
        var _this29 = this;

        return _asyncToGenerator(function* () {
            return _this29._display;
        })();
    }

    /**
     * Returns the display width, in pixels.
     *
     * @return {number} an integer corresponding to the display width, in pixels
     *
     * On failure, throws an exception or returns YDisplayLayer.DISPLAYWIDTH_INVALID.
     */
    get_displayWidth() {
        var _this30 = this;

        return _asyncToGenerator(function* () {
            return yield _this30._display.get_displayWidth();
        })();
    }

    /**
     * Returns the display height, in pixels.
     *
     * @return {number} an integer corresponding to the display height, in pixels
     *
     * On failure, throws an exception or returns YDisplayLayer.DISPLAYHEIGHT_INVALID.
     */
    get_displayHeight() {
        var _this31 = this;

        return _asyncToGenerator(function* () {
            return yield _this31._display.get_displayHeight();
        })();
    }

    /**
     * Returns the width of the layers to draw on, in pixels.
     *
     * @return {number} an integer corresponding to the width of the layers to draw on, in pixels
     *
     * On failure, throws an exception or returns YDisplayLayer.LAYERWIDTH_INVALID.
     */
    get_layerWidth() {
        var _this32 = this;

        return _asyncToGenerator(function* () {
            return yield _this32._display.get_layerWidth();
        })();
    }

    /**
     * Returns the height of the layers to draw on, in pixels.
     *
     * @return {number} an integer corresponding to the height of the layers to draw on, in pixels
     *
     * On failure, throws an exception or returns YDisplayLayer.LAYERHEIGHT_INVALID.
     */
    get_layerHeight() {
        var _this33 = this;

        return _asyncToGenerator(function* () {
            return yield _this33._display.get_layerHeight();
        })();
    }

    resetHiddenFlag() {
        var _this34 = this;

        return _asyncToGenerator(function* () {
            _this34._hidden = false;
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    //--- (end of generated code: YDisplayLayer implementation)
};

//--- (generated code: YDisplay class start)
/**
 * YDisplay Class: Display function interface
 *
 * Yoctopuce display interface has been designed to easily
 * show information and images. The device provides built-in
 * multi-layer rendering. Layers can be drawn offline, individually,
 * and freely moved on the display. It can also replay recorded
 * sequences (animations).
 */
//--- (end of generated code: YDisplay class start)
class YDisplay extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YDisplay constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Display';
        /** @member {number} **/
        this._enabled = Y_ENABLED_INVALID;
        /** @member {string} **/
        this._startupSeq = Y_STARTUPSEQ_INVALID;
        /** @member {number} **/
        this._brightness = Y_BRIGHTNESS_INVALID;
        /** @member {number} **/
        this._orientation = Y_ORIENTATION_INVALID;
        /** @member {number} **/
        this._displayWidth = Y_DISPLAYWIDTH_INVALID;
        /** @member {number} **/
        this._displayHeight = Y_DISPLAYHEIGHT_INVALID;
        /** @member {number} **/
        this._displayType = Y_DISPLAYTYPE_INVALID;
        /** @member {number} **/
        this._layerWidth = Y_LAYERWIDTH_INVALID;
        /** @member {number} **/
        this._layerHeight = Y_LAYERHEIGHT_INVALID;
        /** @member {number} **/
        this._layerCount = Y_LAYERCOUNT_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            ENABLED_FALSE: 0,
            ENABLED_TRUE: 1,
            ENABLED_INVALID: -1,
            STARTUPSEQ_INVALID: _yocto_api.YAPI.INVALID_STRING,
            BRIGHTNESS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            ORIENTATION_LEFT: 0,
            ORIENTATION_UP: 1,
            ORIENTATION_RIGHT: 2,
            ORIENTATION_DOWN: 3,
            ORIENTATION_INVALID: -1,
            DISPLAYWIDTH_INVALID: _yocto_api.YAPI.INVALID_UINT,
            DISPLAYHEIGHT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            DISPLAYTYPE_MONO: 0,
            DISPLAYTYPE_GRAY: 1,
            DISPLAYTYPE_RGB: 2,
            DISPLAYTYPE_INVALID: -1,
            LAYERWIDTH_INVALID: _yocto_api.YAPI.INVALID_UINT,
            LAYERHEIGHT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            LAYERCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of generated code: YDisplay constructor)

        this._allDisplayLayers;
        this._sequence = '';
        this._recording = false;
    }

    //--- (generated code: YDisplay implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'enabled':
                this._enabled = parseInt(val);
                return 1;
            case 'startupSeq':
                this._startupSeq = val;
                return 1;
            case 'brightness':
                this._brightness = parseInt(val);
                return 1;
            case 'orientation':
                this._orientation = parseInt(val);
                return 1;
            case 'displayWidth':
                this._displayWidth = parseInt(val);
                return 1;
            case 'displayHeight':
                this._displayHeight = parseInt(val);
                return 1;
            case 'displayType':
                this._displayType = parseInt(val);
                return 1;
            case 'layerWidth':
                this._layerWidth = parseInt(val);
                return 1;
            case 'layerHeight':
                this._layerHeight = parseInt(val);
                return 1;
            case 'layerCount':
                this._layerCount = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns true if the screen is powered, false otherwise.
     *
     * @return {number} either YDisplay.ENABLED_FALSE or YDisplay.ENABLED_TRUE, according to true if the
     * screen is powered, false otherwise
     *
     * On failure, throws an exception or returns YDisplay.ENABLED_INVALID.
     */
    get_enabled() {
        var _this35 = this;

        return _asyncToGenerator(function* () {
            if (_this35._cacheExpiration <= _this35._yapi.GetTickCount()) {
                if ((yield _this35.load(_this35._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLED_INVALID;
                }
            }
            return _this35._enabled;
        })();
    }

    /**
     * Changes the power state of the display.
     *
     * @param newval {number} : either YDisplay.ENABLED_FALSE or YDisplay.ENABLED_TRUE, according to the
     * power state of the display
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabled(newval) {
        var _this36 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this36._setAttr('enabled', rest_val);
        })();
    }

    /**
     * Returns the name of the sequence to play when the displayed is powered on.
     *
     * @return {string} a string corresponding to the name of the sequence to play when the displayed is powered on
     *
     * On failure, throws an exception or returns YDisplay.STARTUPSEQ_INVALID.
     */
    get_startupSeq() {
        var _this37 = this;

        return _asyncToGenerator(function* () {
            if (_this37._cacheExpiration <= _this37._yapi.GetTickCount()) {
                if ((yield _this37.load(_this37._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STARTUPSEQ_INVALID;
                }
            }
            return _this37._startupSeq;
        })();
    }

    /**
     * Changes the name of the sequence to play when the displayed is powered on.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the name of the sequence to play when the
     * displayed is powered on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_startupSeq(newval) {
        var _this38 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this38._setAttr('startupSeq', rest_val);
        })();
    }

    /**
     * Returns the luminosity of the  module informative leds (from 0 to 100).
     *
     * @return {number} an integer corresponding to the luminosity of the  module informative leds (from 0 to 100)
     *
     * On failure, throws an exception or returns YDisplay.BRIGHTNESS_INVALID.
     */
    get_brightness() {
        var _this39 = this;

        return _asyncToGenerator(function* () {
            if (_this39._cacheExpiration <= _this39._yapi.GetTickCount()) {
                if ((yield _this39.load(_this39._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BRIGHTNESS_INVALID;
                }
            }
            return _this39._brightness;
        })();
    }

    /**
     * Changes the brightness of the display. The parameter is a value between 0 and
     * 100. Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : an integer corresponding to the brightness of the display
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_brightness(newval) {
        var _this40 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this40._setAttr('brightness', rest_val);
        })();
    }

    /**
     * Returns the currently selected display orientation.
     *
     * @return {number} a value among YDisplay.ORIENTATION_LEFT, YDisplay.ORIENTATION_UP,
     * YDisplay.ORIENTATION_RIGHT and YDisplay.ORIENTATION_DOWN corresponding to the currently selected
     * display orientation
     *
     * On failure, throws an exception or returns YDisplay.ORIENTATION_INVALID.
     */
    get_orientation() {
        var _this41 = this;

        return _asyncToGenerator(function* () {
            if (_this41._cacheExpiration <= _this41._yapi.GetTickCount()) {
                if ((yield _this41.load(_this41._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ORIENTATION_INVALID;
                }
            }
            return _this41._orientation;
        })();
    }

    /**
     * Changes the display orientation. Remember to call the saveToFlash()
     * method of the module if the modification must be kept.
     *
     * @param newval {number} : a value among YDisplay.ORIENTATION_LEFT, YDisplay.ORIENTATION_UP,
     * YDisplay.ORIENTATION_RIGHT and YDisplay.ORIENTATION_DOWN corresponding to the display orientation
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_orientation(newval) {
        var _this42 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this42._setAttr('orientation', rest_val);
        })();
    }

    /**
     * Returns the display width, in pixels.
     *
     * @return {number} an integer corresponding to the display width, in pixels
     *
     * On failure, throws an exception or returns YDisplay.DISPLAYWIDTH_INVALID.
     */
    get_displayWidth() {
        var _this43 = this;

        return _asyncToGenerator(function* () {
            if (_this43._cacheExpiration <= _this43._yapi.GetTickCount()) {
                if ((yield _this43.load(_this43._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISPLAYWIDTH_INVALID;
                }
            }
            return _this43._displayWidth;
        })();
    }

    /**
     * Returns the display height, in pixels.
     *
     * @return {number} an integer corresponding to the display height, in pixels
     *
     * On failure, throws an exception or returns YDisplay.DISPLAYHEIGHT_INVALID.
     */
    get_displayHeight() {
        var _this44 = this;

        return _asyncToGenerator(function* () {
            if (_this44._cacheExpiration <= _this44._yapi.GetTickCount()) {
                if ((yield _this44.load(_this44._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISPLAYHEIGHT_INVALID;
                }
            }
            return _this44._displayHeight;
        })();
    }

    /**
     * Returns the display type: monochrome, gray levels or full color.
     *
     * @return {number} a value among YDisplay.DISPLAYTYPE_MONO, YDisplay.DISPLAYTYPE_GRAY and
     * YDisplay.DISPLAYTYPE_RGB corresponding to the display type: monochrome, gray levels or full color
     *
     * On failure, throws an exception or returns YDisplay.DISPLAYTYPE_INVALID.
     */
    get_displayType() {
        var _this45 = this;

        return _asyncToGenerator(function* () {
            if (_this45._cacheExpiration == 0) {
                if ((yield _this45.load(_this45._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISPLAYTYPE_INVALID;
                }
            }
            return _this45._displayType;
        })();
    }

    /**
     * Returns the width of the layers to draw on, in pixels.
     *
     * @return {number} an integer corresponding to the width of the layers to draw on, in pixels
     *
     * On failure, throws an exception or returns YDisplay.LAYERWIDTH_INVALID.
     */
    get_layerWidth() {
        var _this46 = this;

        return _asyncToGenerator(function* () {
            if (_this46._cacheExpiration == 0) {
                if ((yield _this46.load(_this46._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LAYERWIDTH_INVALID;
                }
            }
            return _this46._layerWidth;
        })();
    }

    /**
     * Returns the height of the layers to draw on, in pixels.
     *
     * @return {number} an integer corresponding to the height of the layers to draw on, in pixels
     *
     * On failure, throws an exception or returns YDisplay.LAYERHEIGHT_INVALID.
     */
    get_layerHeight() {
        var _this47 = this;

        return _asyncToGenerator(function* () {
            if (_this47._cacheExpiration == 0) {
                if ((yield _this47.load(_this47._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LAYERHEIGHT_INVALID;
                }
            }
            return _this47._layerHeight;
        })();
    }

    /**
     * Returns the number of available layers to draw on.
     *
     * @return {number} an integer corresponding to the number of available layers to draw on
     *
     * On failure, throws an exception or returns YDisplay.LAYERCOUNT_INVALID.
     */
    get_layerCount() {
        var _this48 = this;

        return _asyncToGenerator(function* () {
            if (_this48._cacheExpiration == 0) {
                if ((yield _this48.load(_this48._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LAYERCOUNT_INVALID;
                }
            }
            return _this48._layerCount;
        })();
    }

    get_command() {
        var _this49 = this;

        return _asyncToGenerator(function* () {
            if (_this49._cacheExpiration <= _this49._yapi.GetTickCount()) {
                if ((yield _this49.load(_this49._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this49._command;
        })();
    }

    set_command(newval) {
        var _this50 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this50._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a display for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the display is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDisplay.isOnline() to test if the display is
     * indeed online at a given time. In case of ambiguity when looking for
     * a display by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the display
     *
     * @return {YDisplay} a YDisplay object allowing you to drive the display.
     */
    static FindDisplay(func) {
        /** @type {YDisplay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Display', func);
        if (obj == null) {
            obj = new YDisplay(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Display', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a display for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the display is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDisplay.isOnline() to test if the display is
     * indeed online at a given time. In case of ambiguity when looking for
     * a display by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the display
     *
     * @return {YDisplay} a YDisplay object allowing you to drive the display.
     */
    static FindDisplayInContext(yctx, func) {
        /** @type {YDisplay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Display', func);
        if (obj == null) {
            obj = new YDisplay(yctx, func);
            _yocto_api.YFunction._AddToCache('Display', func, obj);
        }
        return obj;
    }

    /**
     * Clears the display screen and resets all display layers to their default state.
     * Using this function in a sequence will kill the sequence play-back. Don't use that
     * function to reset the display at sequence start-up.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    resetAll() {
        var _this51 = this;

        return _asyncToGenerator(function* () {
            yield _this51.flushLayers();
            yield _this51.resetHiddenLayerFlags();
            return yield _this51.sendCommand('Z');
        })();
    }

    /**
     * Smoothly changes the brightness of the screen to produce a fade-in or fade-out
     * effect.
     *
     * @param brightness {number} : the new screen brightness
     * @param duration {number} : duration of the brightness transition, in milliseconds.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    fade(brightness, duration) {
        var _this52 = this;

        return _asyncToGenerator(function* () {
            yield _this52.flushLayers();
            return yield _this52.sendCommand('+' + String(Math.round(brightness)) + ',' + String(Math.round(duration)));
        })();
    }

    /**
     * Starts to record all display commands into a sequence, for later replay.
     * The name used to store the sequence is specified when calling
     * saveSequence(), once the recording is complete.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    newSequence() {
        var _this53 = this;

        return _asyncToGenerator(function* () {
            yield _this53.flushLayers();
            _this53._sequence = '';
            _this53._recording = true;
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Stops recording display commands and saves the sequence into the specified
     * file on the display internal memory. The sequence can be later replayed
     * using playSequence().
     *
     * @param sequenceName {string} : the name of the newly created sequence
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    saveSequence(sequenceName) {
        var _this54 = this;

        return _asyncToGenerator(function* () {
            yield _this54.flushLayers();
            _this54._recording = false;
            yield _this54._upload(sequenceName, _this54._yapi.imm_str2bin(_this54._sequence));
            //We need to use YPRINTF("") for Objective-C
            _this54._sequence = '';
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Replays a display sequence previously recorded using
     * newSequence() and saveSequence().
     *
     * @param sequenceName {string} : the name of the newly created sequence
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    playSequence(sequenceName) {
        var _this55 = this;

        return _asyncToGenerator(function* () {
            yield _this55.flushLayers();
            return yield _this55.sendCommand('S' + sequenceName);
        })();
    }

    /**
     * Waits for a specified delay (in milliseconds) before playing next
     * commands in current sequence. This method can be used while
     * recording a display sequence, to insert a timed wait in the sequence
     * (without any immediate effect). It can also be used dynamically while
     * playing a pre-recorded sequence, to suspend or resume the execution of
     * the sequence. To cancel a delay, call the same method with a zero delay.
     *
     * @param delay_ms {number} : the duration to wait, in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pauseSequence(delay_ms) {
        var _this56 = this;

        return _asyncToGenerator(function* () {
            yield _this56.flushLayers();
            return yield _this56.sendCommand('W' + String(Math.round(delay_ms)));
        })();
    }

    /**
     * Stops immediately any ongoing sequence replay.
     * The display is left as is.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    stopSequence() {
        var _this57 = this;

        return _asyncToGenerator(function* () {
            yield _this57.flushLayers();
            return yield _this57.sendCommand('S');
        })();
    }

    /**
     * Uploads an arbitrary file (for instance a GIF file) to the display, to the
     * specified full path name. If a file already exists with the same path name,
     * its content is overwritten.
     *
     * @param pathname {string} : path and name of the new file to create
     * @param content {Uint8Array} : binary buffer with the content to set
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    upload(pathname, content) {
        var _this58 = this;

        return _asyncToGenerator(function* () {
            return yield _this58._upload(pathname, content);
        })();
    }

    /**
     * Copies the whole content of a layer to another layer. The color and transparency
     * of all the pixels from the destination layer are set to match the source pixels.
     * This method only affects the displayed content, but does not change any
     * property of the layer object.
     * Note that layer 0 has no transparency support (it is always completely opaque).
     *
     * @param srcLayerId {number} : the identifier of the source layer (a number in range 0..layerCount-1)
     * @param dstLayerId {number} : the identifier of the destination layer (a number in range 0..layerCount-1)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    copyLayerContent(srcLayerId, dstLayerId) {
        var _this59 = this;

        return _asyncToGenerator(function* () {
            yield _this59.flushLayers();
            return yield _this59.sendCommand('o' + String(Math.round(srcLayerId)) + ',' + String(Math.round(dstLayerId)));
        })();
    }

    /**
     * Swaps the whole content of two layers. The color and transparency of all the pixels from
     * the two layers are swapped. This method only affects the displayed content, but does
     * not change any property of the layer objects. In particular, the visibility of each
     * layer stays unchanged. When used between onae hidden layer and a visible layer,
     * this method makes it possible to easily implement double-buffering.
     * Note that layer 0 has no transparency support (it is always completely opaque).
     *
     * @param layerIdA {number} : the first layer (a number in range 0..layerCount-1)
     * @param layerIdB {number} : the second layer (a number in range 0..layerCount-1)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    swapLayerContent(layerIdA, layerIdB) {
        var _this60 = this;

        return _asyncToGenerator(function* () {
            yield _this60.flushLayers();
            return yield _this60.sendCommand('E' + String(Math.round(layerIdA)) + ',' + String(Math.round(layerIdB)));
        })();
    }

    /**
     * Continues the enumeration of displays started using yFirstDisplay().
     *
     * @return {YDisplay} a pointer to a YDisplay object, corresponding to
     *         a display currently online, or a null pointer
     *         if there are no more displays to enumerate.
     */
    /* */nextDisplay() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YDisplay.FindDisplayInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of displays currently accessible.
     * Use the method YDisplay.nextDisplay() to iterate on
     * next displays.
     *
     * @return {YDisplay} a pointer to a YDisplay object, corresponding to
     *         the first display currently online, or a null pointer
     *         if there are none.
     */
    static FirstDisplay() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Display');
        if (next_hwid == null) return null;
        return YDisplay.FindDisplay(next_hwid);
    }

    /**
     * Starts the enumeration of displays currently accessible.
     * Use the method YDisplay.nextDisplay() to iterate on
     * next displays.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YDisplay} a pointer to a YDisplay object, corresponding to
     *         the first display currently online, or a null pointer
     *         if there are none.
     */
    static FirstDisplayInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Display');
        if (next_hwid == null) return null;
        return YDisplay.FindDisplayInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YDisplay implementation)

    /**
     * Returns a YDisplayLayer object that can be used to draw on the specified
     * layer. The content is displayed only when the layer is active on the
     * screen (and not masked by other overlapping layers).
     *
     * @param layerId {number} : the identifier of the layer (a number in range 0..layerCount-1)
     *
     * @return {synchronized YDisplayLayer} an YDisplayLayer object
     *
     * On failure, throws an exception or returns null.
     */
    get_displayLayer(layerId) {
        var _this61 = this;

        return _asyncToGenerator(function* () {
            if (!_this61._allDisplayLayers) {
                var nb_display_layer = yield _this61.get_layerCount();
                _this61._allDisplayLayers = [];
                for (var i = 0; i < nb_display_layer; i++) {
                    _this61._allDisplayLayers[i] = new YDisplayLayer(_this61, '' + i);
                }
            }
            if (layerId < 0 || layerId >= _this61._allDisplayLayers.length) {
                throw new YAPI_Exception(_yocto_api.YAPI.INVALID_ARGUMENT, 'Invalid layerId');
            }
            return _this61._allDisplayLayers[layerId];
        })();
    }

    flushLayers() {
        var _this62 = this;

        return _asyncToGenerator(function* () {
            if (_this62._allDisplayLayers) {
                for (var i = 0; i < _this62._allDisplayLayers.length; i++) {
                    yield _this62._allDisplayLayers[i].flush_now();
                }
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    resetHiddenLayerFlags() {
        var _this63 = this;

        return _asyncToGenerator(function* () {
            if (_this63._allDisplayLayers) {
                for (var i = 0; i < _this63._allDisplayLayers.length; i++) {
                    yield _this63._allDisplayLayers[i].resetHiddenFlag();
                }
            }
        })();
    }

    sendCommand(cmd) {
        var _this64 = this;

        return _asyncToGenerator(function* () {
            if (!_this64._recording) {
                // ignore call when there is no ongoing sequence
                return yield _this64.set_command(cmd);
            }
            _this64._sequence += cmd + '\n';
            return _yocto_api.YAPI_SUCCESS;
        })();
    }
}

exports.YDisplay = YDisplay; //--- (generated code: Display functions)

/**
 * comment from .yc definition
 */

function yFindDisplay(func) {
    return YDisplay.FindDisplay(func);
}

/**
 * comment from .yc definition
 */
function yFirstDisplay() {
    return YDisplay.FirstDisplay();
}

//--- (end of generated code: Display functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for DualPower functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YDualPower = exports.Y_EXTVOLTAGE_INVALID = exports.Y_POWERCONTROL_INVALID = exports.Y_POWERCONTROL_OFF = exports.Y_POWERCONTROL_FROM_EXT = exports.Y_POWERCONTROL_FROM_USB = exports.Y_POWERCONTROL_AUTO = exports.Y_POWERSTATE_INVALID = exports.Y_POWERSTATE_FROM_EXT = exports.Y_POWERSTATE_FROM_USB = exports.Y_POWERSTATE_OFF = undefined;
exports.yFindDualPower = yFindDualPower;
exports.yFirstDualPower = yFirstDualPower;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YDualPower return codes)
//--- (end of YDualPower return codes)
//--- (YDualPower definitions)
const Y_POWERSTATE_OFF = exports.Y_POWERSTATE_OFF = 0;
const Y_POWERSTATE_FROM_USB = exports.Y_POWERSTATE_FROM_USB = 1;
const Y_POWERSTATE_FROM_EXT = exports.Y_POWERSTATE_FROM_EXT = 2;
const Y_POWERSTATE_INVALID = exports.Y_POWERSTATE_INVALID = -1;
const Y_POWERCONTROL_AUTO = exports.Y_POWERCONTROL_AUTO = 0;
const Y_POWERCONTROL_FROM_USB = exports.Y_POWERCONTROL_FROM_USB = 1;
const Y_POWERCONTROL_FROM_EXT = exports.Y_POWERCONTROL_FROM_EXT = 2;
const Y_POWERCONTROL_OFF = exports.Y_POWERCONTROL_OFF = 3;
const Y_POWERCONTROL_INVALID = exports.Y_POWERCONTROL_INVALID = -1;
const Y_EXTVOLTAGE_INVALID = exports.Y_EXTVOLTAGE_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YDualPower definitions)

//--- (YDualPower class start)
/**
 * YDualPower Class: External power supply control interface
 *
 * Yoctopuce application programming interface allows you to control
 * the power source to use for module functions that require high current.
 * The module can also automatically disconnect the external power
 * when a voltage drop is observed on the external power source
 * (external battery running out of power).
 */
//--- (end of YDualPower class start)

class YDualPower extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YDualPower constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'DualPower';
        /** @member {number} **/
        this._powerState = Y_POWERSTATE_INVALID;
        /** @member {number} **/
        this._powerControl = Y_POWERCONTROL_INVALID;
        /** @member {number} **/
        this._extVoltage = Y_EXTVOLTAGE_INVALID;
        this.imm_setConst({
            POWERSTATE_OFF: 0,
            POWERSTATE_FROM_USB: 1,
            POWERSTATE_FROM_EXT: 2,
            POWERSTATE_INVALID: -1,
            POWERCONTROL_AUTO: 0,
            POWERCONTROL_FROM_USB: 1,
            POWERCONTROL_FROM_EXT: 2,
            POWERCONTROL_OFF: 3,
            POWERCONTROL_INVALID: -1,
            EXTVOLTAGE_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of YDualPower constructor)
    }

    //--- (YDualPower implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'powerState':
                this._powerState = parseInt(val);
                return 1;
            case 'powerControl':
                this._powerControl = parseInt(val);
                return 1;
            case 'extVoltage':
                this._extVoltage = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current power source for module functions that require lots of current.
     *
     * @return {number} a value among YDualPower.POWERSTATE_OFF, YDualPower.POWERSTATE_FROM_USB and
     * YDualPower.POWERSTATE_FROM_EXT corresponding to the current power source for module functions that
     * require lots of current
     *
     * On failure, throws an exception or returns YDualPower.POWERSTATE_INVALID.
     */
    get_powerState() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POWERSTATE_INVALID;
                }
            }
            return _this._powerState;
        })();
    }

    /**
     * Returns the selected power source for module functions that require lots of current.
     *
     * @return {number} a value among YDualPower.POWERCONTROL_AUTO, YDualPower.POWERCONTROL_FROM_USB,
     * YDualPower.POWERCONTROL_FROM_EXT and YDualPower.POWERCONTROL_OFF corresponding to the selected
     * power source for module functions that require lots of current
     *
     * On failure, throws an exception or returns YDualPower.POWERCONTROL_INVALID.
     */
    get_powerControl() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POWERCONTROL_INVALID;
                }
            }
            return _this2._powerControl;
        })();
    }

    /**
     * Changes the selected power source for module functions that require lots of current.
     *
     * @param newval {number} : a value among YDualPower.POWERCONTROL_AUTO,
     * YDualPower.POWERCONTROL_FROM_USB, YDualPower.POWERCONTROL_FROM_EXT and YDualPower.POWERCONTROL_OFF
     * corresponding to the selected power source for module functions that require lots of current
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_powerControl(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this3._setAttr('powerControl', rest_val);
        })();
    }

    /**
     * Returns the measured voltage on the external power source, in millivolts.
     *
     * @return {number} an integer corresponding to the measured voltage on the external power source, in millivolts
     *
     * On failure, throws an exception or returns YDualPower.EXTVOLTAGE_INVALID.
     */
    get_extVoltage() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_EXTVOLTAGE_INVALID;
                }
            }
            return _this4._extVoltage;
        })();
    }

    /**
     * Retrieves a dual power control for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the power control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDualPower.isOnline() to test if the power control is
     * indeed online at a given time. In case of ambiguity when looking for
     * a dual power control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the power control
     *
     * @return {YDualPower} a YDualPower object allowing you to drive the power control.
     */
    static FindDualPower(func) {
        /** @type {YDualPower} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('DualPower', func);
        if (obj == null) {
            obj = new YDualPower(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('DualPower', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a dual power control for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the power control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YDualPower.isOnline() to test if the power control is
     * indeed online at a given time. In case of ambiguity when looking for
     * a dual power control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the power control
     *
     * @return {YDualPower} a YDualPower object allowing you to drive the power control.
     */
    static FindDualPowerInContext(yctx, func) {
        /** @type {YDualPower} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'DualPower', func);
        if (obj == null) {
            obj = new YDualPower(yctx, func);
            _yocto_api.YFunction._AddToCache('DualPower', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of dual power controls started using yFirstDualPower().
     *
     * @return {YDualPower} a pointer to a YDualPower object, corresponding to
     *         a dual power control currently online, or a null pointer
     *         if there are no more dual power controls to enumerate.
     */
    /* */nextDualPower() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YDualPower.FindDualPowerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of dual power controls currently accessible.
     * Use the method YDualPower.nextDualPower() to iterate on
     * next dual power controls.
     *
     * @return {YDualPower} a pointer to a YDualPower object, corresponding to
     *         the first dual power control currently online, or a null pointer
     *         if there are none.
     */
    static FirstDualPower() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('DualPower');
        if (next_hwid == null) return null;
        return YDualPower.FindDualPower(next_hwid);
    }

    /**
     * Starts the enumeration of dual power controls currently accessible.
     * Use the method YDualPower.nextDualPower() to iterate on
     * next dual power controls.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YDualPower} a pointer to a YDualPower object, corresponding to
     *         the first dual power control currently online, or a null pointer
     *         if there are none.
     */
    static FirstDualPowerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('DualPower');
        if (next_hwid == null) return null;
        return YDualPower.FindDualPowerInContext(yctx, next_hwid);
    }

    //--- (end of YDualPower implementation)
}

exports.YDualPower = YDualPower; //--- (DualPower functions)

/**
 * comment from .yc definition
 */

function yFindDualPower(func) {
    return YDualPower.FindDualPower(func);
}

/**
 * comment from .yc definition
 */
function yFirstDualPower() {
    return YDualPower.FirstDualPower();
}

//--- (end of DualPower functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YFiles = exports.Y_FREESPACE_INVALID = exports.Y_FILESCOUNT_INVALID = undefined;
exports.yFindFiles = yFindFiles;
exports.yFirstFiles = yFirstFiles;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_files.js 19607 2015-03-05 10:36:54Z seb $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements yFindFiles(), the high-level API for Files functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - - 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YFiles definitions)
const Y_FILESCOUNT_INVALID = exports.Y_FILESCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_FREESPACE_INVALID = exports.Y_FREESPACE_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of generated code: YFiles definitions)

//--- (generated code: YFileRecord definitions)
//--- (end of generated code: YFileRecord definitions)

//--- (generated code: YFileRecord class start)
/**
 * YFileRecord Class: Description of a file on the device filesystem
 *
 *
 */
//--- (end of generated code: YFileRecord class start)

class YFileRecord {
    constructor(str_json) {
        //--- (generated code: YFileRecord constructor)
        /** @member {string} **/
        this._name = '';
        /** @member {number} **/
        this._size = 0;
        /** @member {number} **/
        this._crc = 0;
        //--- (end of generated code: YFileRecord constructor)
        var loadval = JSON.parse(str_json);
        this._name = loadval.name;
        this._size = loadval.size;
        this._crc = loadval.crc;
    }

    //--- (generated code: YFileRecord implementation)

    get_name() {
        var _this = this;

        return _asyncToGenerator(function* () {
            return _this._name;
        })();
    }

    get_size() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            return _this2._size;
        })();
    }

    get_crc() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            return _this3._crc;
        })();
    }

    //--- (end of generated code: YFileRecord implementation)
}

//--- (generated code: YFiles class start)
/**
 * YFiles Class: Files function interface
 *
 * The filesystem interface makes it possible to store files
 * on some devices, for instance to design a custom web UI
 * (for networked devices) or to add fonts (on display
 * devices).
 */
//--- (end of generated code: YFiles class start)

class YFiles extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YFiles constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Files';
        /** @member {number} **/
        this._filesCount = Y_FILESCOUNT_INVALID;
        /** @member {number} **/
        this._freeSpace = Y_FREESPACE_INVALID;
        this.imm_setConst({
            FILESCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            FREESPACE_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of generated code: YFiles constructor)
    }

    //--- (generated code: YFiles implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'filesCount':
                this._filesCount = parseInt(val);
                return 1;
            case 'freeSpace':
                this._freeSpace = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the number of files currently loaded in the filesystem.
     *
     * @return {number} an integer corresponding to the number of files currently loaded in the filesystem
     *
     * On failure, throws an exception or returns YFiles.FILESCOUNT_INVALID.
     */
    get_filesCount() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FILESCOUNT_INVALID;
                }
            }
            return _this4._filesCount;
        })();
    }

    /**
     * Returns the free space for uploading new files to the filesystem, in bytes.
     *
     * @return {number} an integer corresponding to the free space for uploading new files to the filesystem, in bytes
     *
     * On failure, throws an exception or returns YFiles.FREESPACE_INVALID.
     */
    get_freeSpace() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FREESPACE_INVALID;
                }
            }
            return _this5._freeSpace;
        })();
    }

    /**
     * Retrieves a filesystem for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the filesystem is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YFiles.isOnline() to test if the filesystem is
     * indeed online at a given time. In case of ambiguity when looking for
     * a filesystem by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the filesystem
     *
     * @return {YFiles} a YFiles object allowing you to drive the filesystem.
     */
    static FindFiles(func) {
        /** @type {YFiles} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Files', func);
        if (obj == null) {
            obj = new YFiles(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Files', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a filesystem for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the filesystem is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YFiles.isOnline() to test if the filesystem is
     * indeed online at a given time. In case of ambiguity when looking for
     * a filesystem by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the filesystem
     *
     * @return {YFiles} a YFiles object allowing you to drive the filesystem.
     */
    static FindFilesInContext(yctx, func) {
        /** @type {YFiles} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Files', func);
        if (obj == null) {
            obj = new YFiles(yctx, func);
            _yocto_api.YFunction._AddToCache('Files', func, obj);
        }
        return obj;
    }

    sendCommand(command) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let url;
            url = 'files.json?a=' + command;
            // may throw an exception
            return yield _this6._download(url);
        })();
    }

    /**
     * Reinitialize the filesystem to its clean, unfragmented, empty state.
     * All files previously uploaded are permanently lost.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    format_fs() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let json;
            /** @type {string} **/
            let res;
            json = yield _this7.sendCommand('format');
            res = _this7.imm_json_get_key(json, 'res');
            if (!(res == 'ok')) {
                return _this7._throw(YAPI_IO_ERROR, 'format failed', YAPI_IO_ERROR);
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Returns a list of YFileRecord objects that describe files currently loaded
     * in the filesystem.
     *
     * @param pattern {string} : an optional filter pattern, using star and question marks
     *         as wildcards. When an empty pattern is provided, all file records
     *         are returned.
     *
     * @return {YFileRecord[]} a list of YFileRecord objects, containing the file path
     *         and name, byte size and 32-bit CRC of the file content.
     *
     * On failure, throws an exception or returns an empty list.
     */
    get_list(pattern) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let json;
            /** @type {string[]} **/
            let filelist = [];
            /** @type {YFileRecord[]} **/
            let res = [];
            json = yield _this8.sendCommand('dir&f=' + pattern);
            filelist = _this8.imm_json_get_array(json);
            res.length = 0;
            for (let ii in filelist) {
                res.push(new YFileRecord(filelist[ii]));
            }
            return res;
        })();
    }

    /**
     * Downloads the requested file and returns a binary buffer with its content.
     *
     * @param pathname {string} : path and name of the file to download
     *
     * @return {Uint8Array} a binary buffer with the file content
     *
     * On failure, throws an exception or returns an empty content.
     */
    download(pathname) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            return yield _this9._download(pathname);
        })();
    }

    /**
     * Uploads a file to the filesystem, to the specified full path name.
     * If a file already exists with the same path name, its content is overwritten.
     *
     * @param pathname {string} : path and name of the new file to create
     * @param content {Uint8Array} : binary buffer with the content to set
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    upload(pathname, content) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            return yield _this10._upload(pathname, content);
        })();
    }

    /**
     * Deletes a file, given by its full path name, from the filesystem.
     * Because of filesystem fragmentation, deleting a file may not always
     * free up the whole space used by the file. However, rewriting a file
     * with the same path name will always reuse any space not freed previously.
     * If you need to ensure that no space is taken by previously deleted files,
     * you can use format_fs to fully reinitialize the filesystem.
     *
     * @param pathname {string} : path and name of the file to remove.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    remove(pathname) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let json;
            /** @type {string} **/
            let res;
            json = yield _this11.sendCommand('del&f=' + pathname);
            res = _this11.imm_json_get_key(json, 'res');
            if (!(res == 'ok')) {
                return _this11._throw(YAPI_IO_ERROR, 'unable to remove file', YAPI_IO_ERROR);
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Continues the enumeration of filesystems started using yFirstFiles().
     *
     * @return {YFiles} a pointer to a YFiles object, corresponding to
     *         a filesystem currently online, or a null pointer
     *         if there are no more filesystems to enumerate.
     */
    /* */nextFiles() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YFiles.FindFilesInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of filesystems currently accessible.
     * Use the method YFiles.nextFiles() to iterate on
     * next filesystems.
     *
     * @return {YFiles} a pointer to a YFiles object, corresponding to
     *         the first filesystem currently online, or a null pointer
     *         if there are none.
     */
    static FirstFiles() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Files');
        if (next_hwid == null) return null;
        return YFiles.FindFiles(next_hwid);
    }

    /**
     * Starts the enumeration of filesystems currently accessible.
     * Use the method YFiles.nextFiles() to iterate on
     * next filesystems.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YFiles} a pointer to a YFiles object, corresponding to
     *         the first filesystem currently online, or a null pointer
     *         if there are none.
     */
    static FirstFilesInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Files');
        if (next_hwid == null) return null;
        return YFiles.FindFilesInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YFiles implementation)
}

exports.YFiles = YFiles; //--- (generated code: Files functions)

/**
 * comment from .yc definition
 */

function yFindFiles(func) {
    return YFiles.FindFiles(func);
}

/**
 * comment from .yc definition
 */
function yFirstFiles() {
    return YFiles.FirstFiles();
}

//--- (end of generated code: Files functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for GenericSensor functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YGenericSensor = exports.Y_SIGNALBIAS_INVALID = exports.Y_VALUERANGE_INVALID = exports.Y_SIGNALRANGE_INVALID = exports.Y_SIGNALUNIT_INVALID = exports.Y_SIGNALVALUE_INVALID = exports.Y_SIGNALSAMPLING_INVALID = exports.Y_SIGNALSAMPLING_LOW_NOISE_FILTERED = exports.Y_SIGNALSAMPLING_LOW_NOISE = exports.Y_SIGNALSAMPLING_HIGH_RATE_FILTERED = exports.Y_SIGNALSAMPLING_HIGH_RATE = undefined;
exports.yFindGenericSensor = yFindGenericSensor;
exports.yFirstGenericSensor = yFirstGenericSensor;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YGenericSensor return codes)
//--- (end of YGenericSensor return codes)
//--- (YGenericSensor definitions)
const Y_SIGNALSAMPLING_HIGH_RATE = exports.Y_SIGNALSAMPLING_HIGH_RATE = 0;
const Y_SIGNALSAMPLING_HIGH_RATE_FILTERED = exports.Y_SIGNALSAMPLING_HIGH_RATE_FILTERED = 1;
const Y_SIGNALSAMPLING_LOW_NOISE = exports.Y_SIGNALSAMPLING_LOW_NOISE = 2;
const Y_SIGNALSAMPLING_LOW_NOISE_FILTERED = exports.Y_SIGNALSAMPLING_LOW_NOISE_FILTERED = 3;
const Y_SIGNALSAMPLING_INVALID = exports.Y_SIGNALSAMPLING_INVALID = -1;
const Y_SIGNALVALUE_INVALID = exports.Y_SIGNALVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_SIGNALUNIT_INVALID = exports.Y_SIGNALUNIT_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SIGNALRANGE_INVALID = exports.Y_SIGNALRANGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_VALUERANGE_INVALID = exports.Y_VALUERANGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SIGNALBIAS_INVALID = exports.Y_SIGNALBIAS_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YGenericSensor definitions)

//--- (YGenericSensor class start)
/**
 * YGenericSensor Class: GenericSensor function interface
 *
 * The YGenericSensor class allows you to read and configure Yoctopuce signal
 * transducers. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to configure the automatic conversion between the
 * measured signal and the corresponding engineering unit.
 */
//--- (end of YGenericSensor class start)

class YGenericSensor extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YGenericSensor constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'GenericSensor';
        /** @member {number} **/
        this._signalValue = Y_SIGNALVALUE_INVALID;
        /** @member {string} **/
        this._signalUnit = Y_SIGNALUNIT_INVALID;
        /** @member {string} **/
        this._signalRange = Y_SIGNALRANGE_INVALID;
        /** @member {string} **/
        this._valueRange = Y_VALUERANGE_INVALID;
        /** @member {number} **/
        this._signalBias = Y_SIGNALBIAS_INVALID;
        /** @member {number} **/
        this._signalSampling = Y_SIGNALSAMPLING_INVALID;
        this.imm_setConst({
            SIGNALVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            SIGNALUNIT_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SIGNALRANGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            VALUERANGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SIGNALBIAS_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            SIGNALSAMPLING_HIGH_RATE: 0,
            SIGNALSAMPLING_HIGH_RATE_FILTERED: 1,
            SIGNALSAMPLING_LOW_NOISE: 2,
            SIGNALSAMPLING_LOW_NOISE_FILTERED: 3,
            SIGNALSAMPLING_INVALID: -1
        });
        //--- (end of YGenericSensor constructor)
    }

    //--- (YGenericSensor implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'signalValue':
                this._signalValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'signalUnit':
                this._signalUnit = val;
                return 1;
            case 'signalRange':
                this._signalRange = val;
                return 1;
            case 'valueRange':
                this._valueRange = val;
                return 1;
            case 'signalBias':
                this._signalBias = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'signalSampling':
                this._signalSampling = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the measuring unit for the measured value.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the measuring unit for the measured value
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_unit(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this._setAttr('unit', rest_val);
        })();
    }

    /**
     * Returns the measured value of the electrical signal used by the sensor.
     *
     * @return {number} a floating point number corresponding to the measured value of the electrical
     * signal used by the sensor
     *
     * On failure, throws an exception or returns YGenericSensor.SIGNALVALUE_INVALID.
     */
    get_signalValue() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNALVALUE_INVALID;
                }
            }
            return Math.round(_this2._signalValue * 1000) / 1000;
        })();
    }

    /**
     * Returns the measuring unit of the electrical signal used by the sensor.
     *
     * @return {string} a string corresponding to the measuring unit of the electrical signal used by the sensor
     *
     * On failure, throws an exception or returns YGenericSensor.SIGNALUNIT_INVALID.
     */
    get_signalUnit() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration == 0) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNALUNIT_INVALID;
                }
            }
            return _this3._signalUnit;
        })();
    }

    /**
     * Returns the electric signal range used by the sensor.
     *
     * @return {string} a string corresponding to the electric signal range used by the sensor
     *
     * On failure, throws an exception or returns YGenericSensor.SIGNALRANGE_INVALID.
     */
    get_signalRange() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNALRANGE_INVALID;
                }
            }
            return _this4._signalRange;
        })();
    }

    /**
     * Changes the electric signal range used by the sensor.
     *
     * @param newval {string} : a string corresponding to the electric signal range used by the sensor
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_signalRange(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this5._setAttr('signalRange', rest_val);
        })();
    }

    /**
     * Returns the physical value range measured by the sensor.
     *
     * @return {string} a string corresponding to the physical value range measured by the sensor
     *
     * On failure, throws an exception or returns YGenericSensor.VALUERANGE_INVALID.
     */
    get_valueRange() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VALUERANGE_INVALID;
                }
            }
            return _this6._valueRange;
        })();
    }

    /**
     * Changes the physical value range measured by the sensor. As a side effect, the range modification may
     * automatically modify the display resolution.
     *
     * @param newval {string} : a string corresponding to the physical value range measured by the sensor
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_valueRange(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this7._setAttr('valueRange', rest_val);
        })();
    }

    /**
     * Changes the electric signal bias for zero shift adjustment.
     * If your electric signal reads positif when it should be zero, setup
     * a positive signalBias of the same value to fix the zero shift.
     *
     * @param newval {number} : a floating point number corresponding to the electric signal bias for zero
     * shift adjustment
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_signalBias(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this8._setAttr('signalBias', rest_val);
        })();
    }

    /**
     * Returns the electric signal bias for zero shift adjustment.
     * A positive bias means that the signal is over-reporting the measure,
     * while a negative bias means that the signal is underreporting the measure.
     *
     * @return {number} a floating point number corresponding to the electric signal bias for zero shift adjustment
     *
     * On failure, throws an exception or returns YGenericSensor.SIGNALBIAS_INVALID.
     */
    get_signalBias() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNALBIAS_INVALID;
                }
            }
            return _this9._signalBias;
        })();
    }

    /**
     * Returns the electric signal sampling method to use.
     * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
     * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
     * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
     * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
     * to get measures as stable as possible when working on a noisy signal.
     *
     * @return {number} a value among YGenericSensor.SIGNALSAMPLING_HIGH_RATE,
     * YGenericSensor.SIGNALSAMPLING_HIGH_RATE_FILTERED, YGenericSensor.SIGNALSAMPLING_LOW_NOISE and
     * YGenericSensor.SIGNALSAMPLING_LOW_NOISE_FILTERED corresponding to the electric signal sampling method to use
     *
     * On failure, throws an exception or returns YGenericSensor.SIGNALSAMPLING_INVALID.
     */
    get_signalSampling() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SIGNALSAMPLING_INVALID;
                }
            }
            return _this10._signalSampling;
        })();
    }

    /**
     * Changes the electric signal sampling method to use.
     * The HIGH_RATE method uses the highest sampling frequency, without any filtering.
     * The HIGH_RATE_FILTERED method adds a windowed 7-sample median filter.
     * The LOW_NOISE method uses a reduced acquisition frequency to reduce noise.
     * The LOW_NOISE_FILTERED method combines a reduced frequency with the median filter
     * to get measures as stable as possible when working on a noisy signal.
     *
     * @param newval {number} : a value among YGenericSensor.SIGNALSAMPLING_HIGH_RATE,
     * YGenericSensor.SIGNALSAMPLING_HIGH_RATE_FILTERED, YGenericSensor.SIGNALSAMPLING_LOW_NOISE and
     * YGenericSensor.SIGNALSAMPLING_LOW_NOISE_FILTERED corresponding to the electric signal sampling method to use
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_signalSampling(newval) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this11._setAttr('signalSampling', rest_val);
        })();
    }

    /**
     * Retrieves a generic sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the generic sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGenericSensor.isOnline() to test if the generic sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a generic sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the generic sensor
     *
     * @return {YGenericSensor} a YGenericSensor object allowing you to drive the generic sensor.
     */
    static FindGenericSensor(func) {
        /** @type {YGenericSensor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('GenericSensor', func);
        if (obj == null) {
            obj = new YGenericSensor(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('GenericSensor', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a generic sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the generic sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGenericSensor.isOnline() to test if the generic sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a generic sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the generic sensor
     *
     * @return {YGenericSensor} a YGenericSensor object allowing you to drive the generic sensor.
     */
    static FindGenericSensorInContext(yctx, func) {
        /** @type {YGenericSensor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'GenericSensor', func);
        if (obj == null) {
            obj = new YGenericSensor(yctx, func);
            _yocto_api.YFunction._AddToCache('GenericSensor', func, obj);
        }
        return obj;
    }

    /**
     * Adjusts the signal bias so that the current signal value is need
     * precisely as zero.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    zeroAdjust() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let currSignal;
            /** @type {number} **/
            let currBias;
            currSignal = yield _this12.get_signalValue();
            currBias = yield _this12.get_signalBias();
            return yield _this12.set_signalBias(currSignal + currBias);
        })();
    }

    /**
     * Continues the enumeration of generic sensors started using yFirstGenericSensor().
     *
     * @return {YGenericSensor} a pointer to a YGenericSensor object, corresponding to
     *         a generic sensor currently online, or a null pointer
     *         if there are no more generic sensors to enumerate.
     */
    /* */nextGenericSensor() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YGenericSensor.FindGenericSensorInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of generic sensors currently accessible.
     * Use the method YGenericSensor.nextGenericSensor() to iterate on
     * next generic sensors.
     *
     * @return {YGenericSensor} a pointer to a YGenericSensor object, corresponding to
     *         the first generic sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstGenericSensor() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('GenericSensor');
        if (next_hwid == null) return null;
        return YGenericSensor.FindGenericSensor(next_hwid);
    }

    /**
     * Starts the enumeration of generic sensors currently accessible.
     * Use the method YGenericSensor.nextGenericSensor() to iterate on
     * next generic sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YGenericSensor} a pointer to a YGenericSensor object, corresponding to
     *         the first generic sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstGenericSensorInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('GenericSensor');
        if (next_hwid == null) return null;
        return YGenericSensor.FindGenericSensorInContext(yctx, next_hwid);
    }

    //--- (end of YGenericSensor implementation)
}

exports.YGenericSensor = YGenericSensor; //--- (GenericSensor functions)

/**
 * comment from .yc definition
 */

function yFindGenericSensor(func) {
    return YGenericSensor.FindGenericSensor(func);
}

/**
 * comment from .yc definition
 */
function yFirstGenericSensor() {
    return YGenericSensor.FirstGenericSensor();
}

//--- (end of GenericSensor functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Gps functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YGps = exports.Y_COMMAND_INVALID = exports.Y_UTCOFFSET_INVALID = exports.Y_DATETIME_INVALID = exports.Y_UNIXTIME_INVALID = exports.Y_DIRECTION_INVALID = exports.Y_GROUNDSPEED_INVALID = exports.Y_ALTITUDE_INVALID = exports.Y_DILUTION_INVALID = exports.Y_LONGITUDE_INVALID = exports.Y_LATITUDE_INVALID = exports.Y_SATCOUNT_INVALID = exports.Y_COORDSYSTEM_INVALID = exports.Y_COORDSYSTEM_GPS_D = exports.Y_COORDSYSTEM_GPS_DM = exports.Y_COORDSYSTEM_GPS_DMS = exports.Y_ISFIXED_INVALID = exports.Y_ISFIXED_TRUE = exports.Y_ISFIXED_FALSE = undefined;
exports.yFindGps = yFindGps;
exports.yFirstGps = yFirstGps;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YGps return codes)
//--- (end of YGps return codes)
//--- (YGps definitions)
const Y_ISFIXED_FALSE = exports.Y_ISFIXED_FALSE = 0;
const Y_ISFIXED_TRUE = exports.Y_ISFIXED_TRUE = 1;
const Y_ISFIXED_INVALID = exports.Y_ISFIXED_INVALID = -1;
const Y_COORDSYSTEM_GPS_DMS = exports.Y_COORDSYSTEM_GPS_DMS = 0;
const Y_COORDSYSTEM_GPS_DM = exports.Y_COORDSYSTEM_GPS_DM = 1;
const Y_COORDSYSTEM_GPS_D = exports.Y_COORDSYSTEM_GPS_D = 2;
const Y_COORDSYSTEM_INVALID = exports.Y_COORDSYSTEM_INVALID = -1;
const Y_SATCOUNT_INVALID = exports.Y_SATCOUNT_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_LATITUDE_INVALID = exports.Y_LATITUDE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_LONGITUDE_INVALID = exports.Y_LONGITUDE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_DILUTION_INVALID = exports.Y_DILUTION_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_ALTITUDE_INVALID = exports.Y_ALTITUDE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_GROUNDSPEED_INVALID = exports.Y_GROUNDSPEED_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_DIRECTION_INVALID = exports.Y_DIRECTION_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_UNIXTIME_INVALID = exports.Y_UNIXTIME_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_DATETIME_INVALID = exports.Y_DATETIME_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_UTCOFFSET_INVALID = exports.Y_UTCOFFSET_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YGps definitions)

//--- (YGps class start)
/**
 * YGps Class: GPS function interface
 *
 * The Gps function allows you to extract positionning
 * data from the GPS device. This class can provides
 * complete positionning information: However, if you
 * whish to define callbacks on position changes, you
 * should use the YLatitude et YLongitude classes.
 */
//--- (end of YGps class start)

class YGps extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YGps constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Gps';
        /** @member {number} **/
        this._isFixed = Y_ISFIXED_INVALID;
        /** @member {number} **/
        this._satCount = Y_SATCOUNT_INVALID;
        /** @member {number} **/
        this._coordSystem = Y_COORDSYSTEM_INVALID;
        /** @member {string} **/
        this._latitude = Y_LATITUDE_INVALID;
        /** @member {string} **/
        this._longitude = Y_LONGITUDE_INVALID;
        /** @member {number} **/
        this._dilution = Y_DILUTION_INVALID;
        /** @member {number} **/
        this._altitude = Y_ALTITUDE_INVALID;
        /** @member {number} **/
        this._groundSpeed = Y_GROUNDSPEED_INVALID;
        /** @member {number} **/
        this._direction = Y_DIRECTION_INVALID;
        /** @member {number} **/
        this._unixTime = Y_UNIXTIME_INVALID;
        /** @member {string} **/
        this._dateTime = Y_DATETIME_INVALID;
        /** @member {number} **/
        this._utcOffset = Y_UTCOFFSET_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            ISFIXED_FALSE: 0,
            ISFIXED_TRUE: 1,
            ISFIXED_INVALID: -1,
            SATCOUNT_INVALID: _yocto_api.YAPI.INVALID_LONG,
            COORDSYSTEM_GPS_DMS: 0,
            COORDSYSTEM_GPS_DM: 1,
            COORDSYSTEM_GPS_D: 2,
            COORDSYSTEM_INVALID: -1,
            LATITUDE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            LONGITUDE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            DILUTION_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            ALTITUDE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            GROUNDSPEED_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            DIRECTION_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            UNIXTIME_INVALID: _yocto_api.YAPI.INVALID_LONG,
            DATETIME_INVALID: _yocto_api.YAPI.INVALID_STRING,
            UTCOFFSET_INVALID: _yocto_api.YAPI.INVALID_INT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YGps constructor)
    }

    //--- (YGps implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'isFixed':
                this._isFixed = parseInt(val);
                return 1;
            case 'satCount':
                this._satCount = parseInt(val);
                return 1;
            case 'coordSystem':
                this._coordSystem = parseInt(val);
                return 1;
            case 'latitude':
                this._latitude = val;
                return 1;
            case 'longitude':
                this._longitude = val;
                return 1;
            case 'dilution':
                this._dilution = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'altitude':
                this._altitude = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'groundSpeed':
                this._groundSpeed = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'direction':
                this._direction = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'unixTime':
                this._unixTime = parseInt(val);
                return 1;
            case 'dateTime':
                this._dateTime = val;
                return 1;
            case 'utcOffset':
                this._utcOffset = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns TRUE if the receiver has found enough satellites to work
     *
     * @return {number} either YGps.ISFIXED_FALSE or YGps.ISFIXED_TRUE, according to TRUE if the receiver
     * has found enough satellites to work
     *
     * On failure, throws an exception or returns YGps.ISFIXED_INVALID.
     */
    get_isFixed() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ISFIXED_INVALID;
                }
            }
            return _this._isFixed;
        })();
    }

    /**
     * Returns the count of visible satellites.
     *
     * @return {number} an integer corresponding to the count of visible satellites
     *
     * On failure, throws an exception or returns YGps.SATCOUNT_INVALID.
     */
    get_satCount() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SATCOUNT_INVALID;
                }
            }
            return _this2._satCount;
        })();
    }

    /**
     * Returns the representation system used for positioning data.
     *
     * @return {number} a value among YGps.COORDSYSTEM_GPS_DMS, YGps.COORDSYSTEM_GPS_DM and
     * YGps.COORDSYSTEM_GPS_D corresponding to the representation system used for positioning data
     *
     * On failure, throws an exception or returns YGps.COORDSYSTEM_INVALID.
     */
    get_coordSystem() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COORDSYSTEM_INVALID;
                }
            }
            return _this3._coordSystem;
        })();
    }

    /**
     * Changes the representation system used for positioning data.
     *
     * @param newval {number} : a value among YGps.COORDSYSTEM_GPS_DMS, YGps.COORDSYSTEM_GPS_DM and
     * YGps.COORDSYSTEM_GPS_D corresponding to the representation system used for positioning data
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_coordSystem(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('coordSystem', rest_val);
        })();
    }

    /**
     * Returns the current latitude.
     *
     * @return {string} a string corresponding to the current latitude
     *
     * On failure, throws an exception or returns YGps.LATITUDE_INVALID.
     */
    get_latitude() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LATITUDE_INVALID;
                }
            }
            return _this5._latitude;
        })();
    }

    /**
     * Returns the current longitude.
     *
     * @return {string} a string corresponding to the current longitude
     *
     * On failure, throws an exception or returns YGps.LONGITUDE_INVALID.
     */
    get_longitude() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LONGITUDE_INVALID;
                }
            }
            return _this6._longitude;
        })();
    }

    /**
     * Returns the current horizontal dilution of precision,
     * the smaller that number is, the better .
     *
     * @return {number} a floating point number corresponding to the current horizontal dilution of precision,
     *         the smaller that number is, the better
     *
     * On failure, throws an exception or returns YGps.DILUTION_INVALID.
     */
    get_dilution() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DILUTION_INVALID;
                }
            }
            return _this7._dilution;
        })();
    }

    /**
     * Returns the current altitude. Beware:  GPS technology
     * is very inaccurate regarding altitude.
     *
     * @return {number} a floating point number corresponding to the current altitude
     *
     * On failure, throws an exception or returns YGps.ALTITUDE_INVALID.
     */
    get_altitude() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ALTITUDE_INVALID;
                }
            }
            return _this8._altitude;
        })();
    }

    /**
     * Returns the current ground speed in Km/h.
     *
     * @return {number} a floating point number corresponding to the current ground speed in Km/h
     *
     * On failure, throws an exception or returns YGps.GROUNDSPEED_INVALID.
     */
    get_groundSpeed() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_GROUNDSPEED_INVALID;
                }
            }
            return _this9._groundSpeed;
        })();
    }

    /**
     * Returns the current move bearing in degrees, zero
     * is the true (geographic) north.
     *
     * @return {number} a floating point number corresponding to the current move bearing in degrees, zero
     *         is the true (geographic) north
     *
     * On failure, throws an exception or returns YGps.DIRECTION_INVALID.
     */
    get_direction() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DIRECTION_INVALID;
                }
            }
            return _this10._direction;
        })();
    }

    /**
     * Returns the current time in Unix format (number of
     * seconds elapsed since Jan 1st, 1970).
     *
     * @return {number} an integer corresponding to the current time in Unix format (number of
     *         seconds elapsed since Jan 1st, 1970)
     *
     * On failure, throws an exception or returns YGps.UNIXTIME_INVALID.
     */
    get_unixTime() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_UNIXTIME_INVALID;
                }
            }
            return _this11._unixTime;
        })();
    }

    /**
     * Returns the current time in the form "YYYY/MM/DD hh:mm:ss"
     *
     * @return {string} a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
     *
     * On failure, throws an exception or returns YGps.DATETIME_INVALID.
     */
    get_dateTime() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DATETIME_INVALID;
                }
            }
            return _this12._dateTime;
        })();
    }

    /**
     * Returns the number of seconds between current time and UTC time (time zone).
     *
     * @return {number} an integer corresponding to the number of seconds between current time and UTC time (time zone)
     *
     * On failure, throws an exception or returns YGps.UTCOFFSET_INVALID.
     */
    get_utcOffset() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_UTCOFFSET_INVALID;
                }
            }
            return _this13._utcOffset;
        })();
    }

    /**
     * Changes the number of seconds between current time and UTC time (time zone).
     * The timezone is automatically rounded to the nearest multiple of 15 minutes.
     * If current UTC time is known, the current time is automatically be updated according to the selected time zone.
     *
     * @param newval {number} : an integer corresponding to the number of seconds between current time and
     * UTC time (time zone)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_utcOffset(newval) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this14._setAttr('utcOffset', rest_val);
        })();
    }

    get_command() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this15._command;
        })();
    }

    set_command(newval) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this16._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a GPS for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the GPS is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGps.isOnline() to test if the GPS is
     * indeed online at a given time. In case of ambiguity when looking for
     * a GPS by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the GPS
     *
     * @return {YGps} a YGps object allowing you to drive the GPS.
     */
    static FindGps(func) {
        /** @type {YGps} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Gps', func);
        if (obj == null) {
            obj = new YGps(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Gps', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a GPS for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the GPS is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGps.isOnline() to test if the GPS is
     * indeed online at a given time. In case of ambiguity when looking for
     * a GPS by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the GPS
     *
     * @return {YGps} a YGps object allowing you to drive the GPS.
     */
    static FindGpsInContext(yctx, func) {
        /** @type {YGps} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Gps', func);
        if (obj == null) {
            obj = new YGps(yctx, func);
            _yocto_api.YFunction._AddToCache('Gps', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of GPS started using yFirstGps().
     *
     * @return {YGps} a pointer to a YGps object, corresponding to
     *         a GPS currently online, or a null pointer
     *         if there are no more GPS to enumerate.
     */
    /* */nextGps() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YGps.FindGpsInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of GPS currently accessible.
     * Use the method YGps.nextGps() to iterate on
     * next GPS.
     *
     * @return {YGps} a pointer to a YGps object, corresponding to
     *         the first GPS currently online, or a null pointer
     *         if there are none.
     */
    static FirstGps() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Gps');
        if (next_hwid == null) return null;
        return YGps.FindGps(next_hwid);
    }

    /**
     * Starts the enumeration of GPS currently accessible.
     * Use the method YGps.nextGps() to iterate on
     * next GPS.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YGps} a pointer to a YGps object, corresponding to
     *         the first GPS currently online, or a null pointer
     *         if there are none.
     */
    static FirstGpsInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Gps');
        if (next_hwid == null) return null;
        return YGps.FindGpsInContext(yctx, next_hwid);
    }

    //--- (end of YGps implementation)
}

exports.YGps = YGps; //--- (Gps functions)

/**
 * comment from .yc definition
 */

function yFindGps(func) {
    return YGps.FindGps(func);
}

/**
 * comment from .yc definition
 */
function yFirstGps() {
    return YGps.FirstGps();
}

//--- (end of Gps functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for GroundSpeed functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YGroundSpeed = undefined;
exports.yFindGroundSpeed = yFindGroundSpeed;
exports.yFirstGroundSpeed = yFirstGroundSpeed;

var _yocto_api = require('lib/yocto_api');

//--- (YGroundSpeed return codes)
//--- (end of YGroundSpeed return codes)
//--- (YGroundSpeed definitions)
//--- (end of YGroundSpeed definitions)

//--- (YGroundSpeed class start)
/**
 * YGroundSpeed Class: GroundSpeed function interface
 *
 * The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce
 * geolocalization sensors. It inherits from the YSensor class the core functions to
 * read measurements, register callback functions, access the autonomous
 * datalogger.
 */
//--- (end of YGroundSpeed class start)

class YGroundSpeed extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YGroundSpeed constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'GroundSpeed';
        //--- (end of YGroundSpeed constructor)
    }

    //--- (YGroundSpeed implementation)

    /**
     * Retrieves a ground speed sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the ground speed sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGroundSpeed.isOnline() to test if the ground speed sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a ground speed sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the ground speed sensor
     *
     * @return {YGroundSpeed} a YGroundSpeed object allowing you to drive the ground speed sensor.
     */
    static FindGroundSpeed(func) {
        /** @type {YGroundSpeed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('GroundSpeed', func);
        if (obj == null) {
            obj = new YGroundSpeed(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('GroundSpeed', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a ground speed sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the ground speed sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGroundSpeed.isOnline() to test if the ground speed sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a ground speed sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the ground speed sensor
     *
     * @return {YGroundSpeed} a YGroundSpeed object allowing you to drive the ground speed sensor.
     */
    static FindGroundSpeedInContext(yctx, func) {
        /** @type {YGroundSpeed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'GroundSpeed', func);
        if (obj == null) {
            obj = new YGroundSpeed(yctx, func);
            _yocto_api.YFunction._AddToCache('GroundSpeed', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of ground speed sensors started using yFirstGroundSpeed().
     *
     * @return {YGroundSpeed} a pointer to a YGroundSpeed object, corresponding to
     *         a ground speed sensor currently online, or a null pointer
     *         if there are no more ground speed sensors to enumerate.
     */
    /* */nextGroundSpeed() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YGroundSpeed.FindGroundSpeedInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of ground speed sensors currently accessible.
     * Use the method YGroundSpeed.nextGroundSpeed() to iterate on
     * next ground speed sensors.
     *
     * @return {YGroundSpeed} a pointer to a YGroundSpeed object, corresponding to
     *         the first ground speed sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstGroundSpeed() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('GroundSpeed');
        if (next_hwid == null) return null;
        return YGroundSpeed.FindGroundSpeed(next_hwid);
    }

    /**
     * Starts the enumeration of ground speed sensors currently accessible.
     * Use the method YGroundSpeed.nextGroundSpeed() to iterate on
     * next ground speed sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YGroundSpeed} a pointer to a YGroundSpeed object, corresponding to
     *         the first ground speed sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstGroundSpeedInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('GroundSpeed');
        if (next_hwid == null) return null;
        return YGroundSpeed.FindGroundSpeedInContext(yctx, next_hwid);
    }

    //--- (end of YGroundSpeed implementation)
}

exports.YGroundSpeed = YGroundSpeed; //--- (GroundSpeed functions)

/**
 * comment from .yc definition
 */

function yFindGroundSpeed(func) {
    return YGroundSpeed.FindGroundSpeed(func);
}

/**
 * comment from .yc definition
 */
function yFirstGroundSpeed() {
    return YGroundSpeed.FirstGroundSpeed();
}

//--- (end of GroundSpeed functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YGyro = exports.YQt = exports.Y_ZVALUE_INVALID = exports.Y_YVALUE_INVALID = exports.Y_XVALUE_INVALID = undefined;
exports.yFindQt = yFindQt;
exports.yFirstQt = yFirstQt;
exports.yFindGyro = yFindGyro;
exports.yFirstGyro = yFirstGyro;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_gyro.js 19704 2015-03-13 06:10:37Z mvuilleu $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements the high-level API for Gyro functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - - 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YQt return codes)
//--- (end of generated code: YQt return codes)
//--- (generated code: YQt definitions)
//--- (end of generated code: YQt definitions)

//--- (generated code: YGyro return codes)
//--- (end of generated code: YGyro return codes)
//--- (generated code: YGyro definitions)
const Y_XVALUE_INVALID = exports.Y_XVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_YVALUE_INVALID = exports.Y_YVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_ZVALUE_INVALID = exports.Y_ZVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of generated code: YGyro definitions)

//--- (generated code: YQt class start)
/**
 * YQt Class: Quaternion interface
 *
 * The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation
 * using a quaternion. It is usually not needed to use the YQt class directly, as the
 * YGyro class provides a more convenient higher-level interface.
 */
//--- (end of generated code: YQt class start)
class YQt extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YQt constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Qt';
        //--- (end of generated code: YQt constructor)
    }

    //--- (generated code: YQt implementation)

    /**
     * Retrieves a quaternion component for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the quaternion component is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YQt.isOnline() to test if the quaternion component is
     * indeed online at a given time. In case of ambiguity when looking for
     * a quaternion component by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the quaternion component
     *
     * @return {YQt} a YQt object allowing you to drive the quaternion component.
     */
    static FindQt(func) {
        /** @type {YQt} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Qt', func);
        if (obj == null) {
            obj = new YQt(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Qt', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a quaternion component for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the quaternion component is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YQt.isOnline() to test if the quaternion component is
     * indeed online at a given time. In case of ambiguity when looking for
     * a quaternion component by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the quaternion component
     *
     * @return {YQt} a YQt object allowing you to drive the quaternion component.
     */
    static FindQtInContext(yctx, func) {
        /** @type {YQt} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Qt', func);
        if (obj == null) {
            obj = new YQt(yctx, func);
            _yocto_api.YFunction._AddToCache('Qt', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of quaternion components started using yFirstQt().
     *
     * @return {YQt} a pointer to a YQt object, corresponding to
     *         a quaternion component currently online, or a null pointer
     *         if there are no more quaternion components to enumerate.
     */
    /* */nextQt() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YQt.FindQtInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of quaternion components currently accessible.
     * Use the method YQt.nextQt() to iterate on
     * next quaternion components.
     *
     * @return {YQt} a pointer to a YQt object, corresponding to
     *         the first quaternion component currently online, or a null pointer
     *         if there are none.
     */
    static FirstQt() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Qt');
        if (next_hwid == null) return null;
        return YQt.FindQt(next_hwid);
    }

    /**
     * Starts the enumeration of quaternion components currently accessible.
     * Use the method YQt.nextQt() to iterate on
     * next quaternion components.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YQt} a pointer to a YQt object, corresponding to
     *         the first quaternion component currently online, or a null pointer
     *         if there are none.
     */
    static FirstQtInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Qt');
        if (next_hwid == null) return null;
        return YQt.FindQtInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YQt implementation)
}

exports.YQt = YQt; //--- (generated code: Qt functions)

/**
 * comment from .yc definition
 */

function yFindQt(func) {
    return YQt.FindQt(func);
}

/**
 * comment from .yc definition
 */
function yFirstQt() {
    return YQt.FirstQt();
}

//--- (end of generated code: Qt functions)

function yInternalGyroCallback(YQt_obj, str_value) {
    var gyro = YQt_obj.get_userData();
    if (!gyro) return;
    var idx = parseInt(YQt_obj.get_functionId().slice(2));
    gyro._invokeGyroCallbacks(idx, parseInt(str_value));
}

//--- (generated code: YGyro class start)
/**
 * YGyro Class: Gyroscope function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of generated code: YGyro class start)
class YGyro extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YGyro constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Gyro';
        /** @member {number} **/
        this._xValue = Y_XVALUE_INVALID;
        /** @member {number} **/
        this._yValue = Y_YVALUE_INVALID;
        /** @member {number} **/
        this._zValue = Y_ZVALUE_INVALID;
        /** @member {number} **/
        this._qt_stamp = 0;
        /** @member {YQt} **/
        this._qt_w = null;
        /** @member {YQt} **/
        this._qt_x = null;
        /** @member {YQt} **/
        this._qt_y = null;
        /** @member {YQt} **/
        this._qt_z = null;
        /** @member {number} **/
        this._w = 0;
        /** @member {number} **/
        this._x = 0;
        /** @member {number} **/
        this._y = 0;
        /** @member {number} **/
        this._z = 0;
        /** @member {number} **/
        this._angles_stamp = 0;
        /** @member {number} **/
        this._head = 0;
        /** @member {number} **/
        this._pitch = 0;
        /** @member {number} **/
        this._roll = 0;
        /** @member {function} **/
        this._quatCallback = null;
        /** @member {function} **/
        this._anglesCallback = null;
        this.imm_setConst({
            XVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            YVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            ZVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE
        });
        //--- (end of generated code: YGyro constructor)
    }

    //--- (generated code: YGyro implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'xValue':
                this._xValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'yValue':
                this._yValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'zValue':
                this._zValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the angular velocity around the X axis of the device, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the angular velocity around the X axis of
     * the device, as a floating point number
     *
     * On failure, throws an exception or returns YGyro.XVALUE_INVALID.
     */
    get_xValue() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_XVALUE_INVALID;
                }
            }
            return _this._xValue;
        })();
    }

    /**
     * Returns the angular velocity around the Y axis of the device, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the angular velocity around the Y axis of
     * the device, as a floating point number
     *
     * On failure, throws an exception or returns YGyro.YVALUE_INVALID.
     */
    get_yValue() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_YVALUE_INVALID;
                }
            }
            return _this2._yValue;
        })();
    }

    /**
     * Returns the angular velocity around the Z axis of the device, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the angular velocity around the Z axis of
     * the device, as a floating point number
     *
     * On failure, throws an exception or returns YGyro.ZVALUE_INVALID.
     */
    get_zValue() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ZVALUE_INVALID;
                }
            }
            return _this3._zValue;
        })();
    }

    /**
     * Retrieves a gyroscope for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the gyroscope is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGyro.isOnline() to test if the gyroscope is
     * indeed online at a given time. In case of ambiguity when looking for
     * a gyroscope by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the gyroscope
     *
     * @return {YGyro} a YGyro object allowing you to drive the gyroscope.
     */
    static FindGyro(func) {
        /** @type {YGyro} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Gyro', func);
        if (obj == null) {
            obj = new YGyro(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Gyro', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a gyroscope for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the gyroscope is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YGyro.isOnline() to test if the gyroscope is
     * indeed online at a given time. In case of ambiguity when looking for
     * a gyroscope by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the gyroscope
     *
     * @return {YGyro} a YGyro object allowing you to drive the gyroscope.
     */
    static FindGyroInContext(yctx, func) {
        /** @type {YGyro} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Gyro', func);
        if (obj == null) {
            obj = new YGyro(yctx, func);
            _yocto_api.YFunction._AddToCache('Gyro', func, obj);
        }
        return obj;
    }

    _loadQuaternion() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let now_stamp;
            /** @type {number} **/
            let age_ms;
            now_stamp = _this4._yapi.GetTickCount() & 0x7FFFFFFF;
            age_ms = now_stamp - _this4._qt_stamp & 0x7FFFFFFF;
            if (age_ms >= 10 || _this4._qt_stamp == 0) {
                if ((yield _this4.load(10)) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                if (_this4._qt_stamp == 0) {
                    _this4._qt_w = yield YQt.FindQtInContext(_this4._serial + '.qt1');
                    _this4._qt_x = yield YQt.FindQtInContext(_this4._serial + '.qt2');
                    _this4._qt_y = yield YQt.FindQtInContext(_this4._serial + '.qt3');
                    _this4._qt_z = yield YQt.FindQtInContext(_this4._serial + '.qt4');
                }
                if ((yield _this4._qt_w.load(9)) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                if ((yield _this4._qt_x.load(9)) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                if ((yield _this4._qt_y.load(9)) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                if ((yield _this4._qt_z.load(9)) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                _this4._w = yield _this4._qt_w.get_currentValue();
                _this4._x = yield _this4._qt_x.get_currentValue();
                _this4._y = yield _this4._qt_y.get_currentValue();
                _this4._z = yield _this4._qt_z.get_currentValue();
                _this4._qt_stamp = now_stamp;
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    _loadAngles() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let sqw;
            /** @type {number} **/
            let sqx;
            /** @type {number} **/
            let sqy;
            /** @type {number} **/
            let sqz;
            /** @type {number} **/
            let norm;
            /** @type {number} **/
            let delta;
            // may throw an exception
            if ((yield _this5._loadQuaternion()) != _yocto_api.YAPI_SUCCESS) {
                return YAPI_DEVICE_NOT_FOUND;
            }
            if (_this5._angles_stamp != _this5._qt_stamp) {
                sqw = _this5._w * _this5._w;
                sqx = _this5._x * _this5._x;
                sqy = _this5._y * _this5._y;
                sqz = _this5._z * _this5._z;
                norm = sqx + sqy + sqz + sqw;
                delta = _this5._y * _this5._w - _this5._x * _this5._z;
                if (delta > 0.499 * norm) {
                    _this5._pitch = 90.0;
                    _this5._head = Math.round(2.0 * 1800.0 / Math.PI * Math.atan2(_this5._x, _this5._w)) / 10.0;
                } else {
                    if (delta < -0.499 * norm) {
                        _this5._pitch = -90.0;
                        _this5._head = Math.round(-2.0 * 1800.0 / Math.PI * Math.atan2(_this5._x, _this5._w)) / 10.0;
                    } else {
                        _this5._roll = Math.round(1800.0 / Math.PI * Math.atan2(2.0 * (_this5._w * _this5._x + _this5._y * _this5._z), sqw - sqx - sqy + sqz)) / 10.0;
                        _this5._pitch = Math.round(1800.0 / Math.PI * Math.asin(2.0 * delta / norm)) / 10.0;
                        _this5._head = Math.round(1800.0 / Math.PI * Math.atan2(2.0 * (_this5._x * _this5._y + _this5._z * _this5._w), sqw + sqx - sqy - sqz)) / 10.0;
                    }
                }
                _this5._angles_stamp = _this5._qt_stamp;
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Returns the estimated roll angle, based on the integration of
     * gyroscopic measures combined with acceleration and
     * magnetic field measurements.
     * The axis corresponding to the roll angle can be mapped to any
     * of the device X, Y or Z physical directions using methods of
     * the class YRefFrame.
     *
     * @return {number} a floating-point number corresponding to roll angle
     *         in degrees, between -180 and +180.
     */
    get_roll() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            yield _this6._loadAngles();
            return _this6._roll;
        })();
    }

    /**
     * Returns the estimated pitch angle, based on the integration of
     * gyroscopic measures combined with acceleration and
     * magnetic field measurements.
     * The axis corresponding to the pitch angle can be mapped to any
     * of the device X, Y or Z physical directions using methods of
     * the class YRefFrame.
     *
     * @return {number} a floating-point number corresponding to pitch angle
     *         in degrees, between -90 and +90.
     */
    get_pitch() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            yield _this7._loadAngles();
            return _this7._pitch;
        })();
    }

    /**
     * Returns the estimated heading angle, based on the integration of
     * gyroscopic measures combined with acceleration and
     * magnetic field measurements.
     * The axis corresponding to the heading can be mapped to any
     * of the device X, Y or Z physical directions using methods of
     * the class YRefFrame.
     *
     * @return {number} a floating-point number corresponding to heading
     *         in degrees, between 0 and 360.
     */
    get_heading() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            yield _this8._loadAngles();
            return _this8._head;
        })();
    }

    /**
     * Returns the w component (real part) of the quaternion
     * describing the device estimated orientation, based on the
     * integration of gyroscopic measures combined with acceleration and
     * magnetic field measurements.
     *
     * @return {number} a floating-point number corresponding to the w
     *         component of the quaternion.
     */
    get_quaternionW() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            yield _this9._loadQuaternion();
            return _this9._w;
        })();
    }

    /**
     * Returns the x component of the quaternion
     * describing the device estimated orientation, based on the
     * integration of gyroscopic measures combined with acceleration and
     * magnetic field measurements. The x component is
     * mostly correlated with rotations on the roll axis.
     *
     * @return {number} a floating-point number corresponding to the x
     *         component of the quaternion.
     */
    get_quaternionX() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            yield _this10._loadQuaternion();
            return _this10._x;
        })();
    }

    /**
     * Returns the y component of the quaternion
     * describing the device estimated orientation, based on the
     * integration of gyroscopic measures combined with acceleration and
     * magnetic field measurements. The y component is
     * mostly correlated with rotations on the pitch axis.
     *
     * @return {number} a floating-point number corresponding to the y
     *         component of the quaternion.
     */
    get_quaternionY() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            yield _this11._loadQuaternion();
            return _this11._y;
        })();
    }

    /**
     * Returns the x component of the quaternion
     * describing the device estimated orientation, based on the
     * integration of gyroscopic measures combined with acceleration and
     * magnetic field measurements. The x component is
     * mostly correlated with changes of heading.
     *
     * @return {number} a floating-point number corresponding to the z
     *         component of the quaternion.
     */
    get_quaternionZ() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            yield _this12._loadQuaternion();
            return _this12._z;
        })();
    }

    /**
     * Registers a callback function that will be invoked each time that the estimated
     * device orientation has changed. The call frequency is typically around 95Hz during a move.
     * The callback is invoked only during the execution of ySleep or yHandleEvents.
     * This provides control over the time when the callback is triggered.
     * For good responsiveness, remember to call one of these two functions periodically.
     * To unregister a callback, pass a null pointer as argument.
     *
     * @param callback {function} : the callback function to invoke, or a null pointer.
     *         The callback function should take five arguments:
     *         the YGyro object of the turning device, and the floating
     *         point values of the four components w, x, y and z
     *         (as floating-point numbers).
     * @noreturn
     */
    registerQuaternionCallback(callback) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            _this13._quatCallback = callback;
            if (callback != null) {
                if ((yield _this13._loadQuaternion()) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                yield _this13._qt_w.set_userData(_this13);
                yield _this13._qt_x.set_userData(_this13);
                yield _this13._qt_y.set_userData(_this13);
                yield _this13._qt_z.set_userData(_this13);
                yield _this13._qt_w.registerValueCallback(yInternalGyroCallback);
                yield _this13._qt_x.registerValueCallback(yInternalGyroCallback);
                yield _this13._qt_y.registerValueCallback(yInternalGyroCallback);
                yield _this13._qt_z.registerValueCallback(yInternalGyroCallback);
            } else {
                if (!(_this13._anglesCallback != null)) {
                    yield _this13._qt_w.registerValueCallback(null);
                    yield _this13._qt_x.registerValueCallback(null);
                    yield _this13._qt_y.registerValueCallback(null);
                    yield _this13._qt_z.registerValueCallback(null);
                }
            }
            return 0;
        })();
    }

    /**
     * Registers a callback function that will be invoked each time that the estimated
     * device orientation has changed. The call frequency is typically around 95Hz during a move.
     * The callback is invoked only during the execution of ySleep or yHandleEvents.
     * This provides control over the time when the callback is triggered.
     * For good responsiveness, remember to call one of these two functions periodically.
     * To unregister a callback, pass a null pointer as argument.
     *
     * @param callback {function} : the callback function to invoke, or a null pointer.
     *         The callback function should take four arguments:
     *         the YGyro object of the turning device, and the floating
     *         point values of the three angles roll, pitch and heading
     *         in degrees (as floating-point numbers).
     * @noreturn
     */
    registerAnglesCallback(callback) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            _this14._anglesCallback = callback;
            if (callback != null) {
                if ((yield _this14._loadQuaternion()) != _yocto_api.YAPI_SUCCESS) {
                    return YAPI_DEVICE_NOT_FOUND;
                }
                yield _this14._qt_w.set_userData(_this14);
                yield _this14._qt_x.set_userData(_this14);
                yield _this14._qt_y.set_userData(_this14);
                yield _this14._qt_z.set_userData(_this14);
                yield _this14._qt_w.registerValueCallback(yInternalGyroCallback);
                yield _this14._qt_x.registerValueCallback(yInternalGyroCallback);
                yield _this14._qt_y.registerValueCallback(yInternalGyroCallback);
                yield _this14._qt_z.registerValueCallback(yInternalGyroCallback);
            } else {
                if (!(_this14._quatCallback != null)) {
                    yield _this14._qt_w.registerValueCallback(null);
                    yield _this14._qt_x.registerValueCallback(null);
                    yield _this14._qt_y.registerValueCallback(null);
                    yield _this14._qt_z.registerValueCallback(null);
                }
            }
            return 0;
        })();
    }

    _invokeGyroCallbacks(qtIndex, qtValue) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            switch (qtIndex - 1) {
                case 0:
                    _this15._w = qtValue;
                    break;
                case 1:
                    _this15._x = qtValue;
                    break;
                case 2:
                    _this15._y = qtValue;
                    break;
                case 3:
                    _this15._z = qtValue;
                    break;
            }
            if (qtIndex < 4) {
                return 0;
            }
            _this15._qt_stamp = _this15._yapi.GetTickCount() & 0x7FFFFFFF;
            if (_this15._quatCallback != null) {
                yield _this15._quatCallback(_this15, _this15._w, _this15._x, _this15._y, _this15._z);
            }
            if (_this15._anglesCallback != null) {
                yield _this15._loadAngles();
                yield _this15._anglesCallback(_this15, _this15._roll, _this15._pitch, _this15._head);
            }
            return 0;
        })();
    }

    /**
     * Continues the enumeration of gyroscopes started using yFirstGyro().
     *
     * @return {YGyro} a pointer to a YGyro object, corresponding to
     *         a gyroscope currently online, or a null pointer
     *         if there are no more gyroscopes to enumerate.
     */
    /* */nextGyro() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YGyro.FindGyroInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of gyroscopes currently accessible.
     * Use the method YGyro.nextGyro() to iterate on
     * next gyroscopes.
     *
     * @return {YGyro} a pointer to a YGyro object, corresponding to
     *         the first gyro currently online, or a null pointer
     *         if there are none.
     */
    static FirstGyro() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Gyro');
        if (next_hwid == null) return null;
        return YGyro.FindGyro(next_hwid);
    }

    /**
     * Starts the enumeration of gyroscopes currently accessible.
     * Use the method YGyro.nextGyro() to iterate on
     * next gyroscopes.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YGyro} a pointer to a YGyro object, corresponding to
     *         the first gyro currently online, or a null pointer
     *         if there are none.
     */
    static FirstGyroInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Gyro');
        if (next_hwid == null) return null;
        return YGyro.FindGyroInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YGyro implementation)
}

exports.YGyro = YGyro; //--- (generated code: Gyro functions)

/**
 * comment from .yc definition
 */

function yFindGyro(func) {
    return YGyro.FindGyro(func);
}

/**
 * comment from .yc definition
 */
function yFirstGyro() {
    return YGyro.FirstGyro();
}

//--- (end of generated code: Gyro functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for HubPort functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YHubPort = exports.Y_BAUDRATE_INVALID = exports.Y_PORTSTATE_INVALID = exports.Y_PORTSTATE_PROG = exports.Y_PORTSTATE_RUN = exports.Y_PORTSTATE_ON = exports.Y_PORTSTATE_OVRLD = exports.Y_PORTSTATE_OFF = exports.Y_ENABLED_INVALID = exports.Y_ENABLED_TRUE = exports.Y_ENABLED_FALSE = undefined;
exports.yFindHubPort = yFindHubPort;
exports.yFirstHubPort = yFirstHubPort;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YHubPort return codes)
//--- (end of YHubPort return codes)
//--- (YHubPort definitions)
const Y_ENABLED_FALSE = exports.Y_ENABLED_FALSE = 0;
const Y_ENABLED_TRUE = exports.Y_ENABLED_TRUE = 1;
const Y_ENABLED_INVALID = exports.Y_ENABLED_INVALID = -1;
const Y_PORTSTATE_OFF = exports.Y_PORTSTATE_OFF = 0;
const Y_PORTSTATE_OVRLD = exports.Y_PORTSTATE_OVRLD = 1;
const Y_PORTSTATE_ON = exports.Y_PORTSTATE_ON = 2;
const Y_PORTSTATE_RUN = exports.Y_PORTSTATE_RUN = 3;
const Y_PORTSTATE_PROG = exports.Y_PORTSTATE_PROG = 4;
const Y_PORTSTATE_INVALID = exports.Y_PORTSTATE_INVALID = -1;
const Y_BAUDRATE_INVALID = exports.Y_BAUDRATE_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YHubPort definitions)

//--- (YHubPort class start)
/**
 * YHubPort Class: Yocto-hub port interface
 *
 * YHubPort objects provide control over the power supply for every
 * YoctoHub port and provide information about the device connected to it.
 * The logical name of a YHubPort is always automatically set to the
 * unique serial number of the Yoctopuce device connected to it.
 */
//--- (end of YHubPort class start)

class YHubPort extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YHubPort constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'HubPort';
        /** @member {number} **/
        this._enabled = Y_ENABLED_INVALID;
        /** @member {number} **/
        this._portState = Y_PORTSTATE_INVALID;
        /** @member {number} **/
        this._baudRate = Y_BAUDRATE_INVALID;
        this.imm_setConst({
            ENABLED_FALSE: 0,
            ENABLED_TRUE: 1,
            ENABLED_INVALID: -1,
            PORTSTATE_OFF: 0,
            PORTSTATE_OVRLD: 1,
            PORTSTATE_ON: 2,
            PORTSTATE_RUN: 3,
            PORTSTATE_PROG: 4,
            PORTSTATE_INVALID: -1,
            BAUDRATE_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of YHubPort constructor)
    }

    //--- (YHubPort implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'enabled':
                this._enabled = parseInt(val);
                return 1;
            case 'portState':
                this._portState = parseInt(val);
                return 1;
            case 'baudRate':
                this._baudRate = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns true if the Yocto-hub port is powered, false otherwise.
     *
     * @return {number} either YHubPort.ENABLED_FALSE or YHubPort.ENABLED_TRUE, according to true if the
     * Yocto-hub port is powered, false otherwise
     *
     * On failure, throws an exception or returns YHubPort.ENABLED_INVALID.
     */
    get_enabled() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLED_INVALID;
                }
            }
            return _this._enabled;
        })();
    }

    /**
     * Changes the activation of the Yocto-hub port. If the port is enabled, the
     * connected module is powered. Otherwise, port power is shut down.
     *
     * @param newval {number} : either YHubPort.ENABLED_FALSE or YHubPort.ENABLED_TRUE, according to the
     * activation of the Yocto-hub port
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabled(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('enabled', rest_val);
        })();
    }

    /**
     * Returns the current state of the Yocto-hub port.
     *
     * @return {number} a value among YHubPort.PORTSTATE_OFF, YHubPort.PORTSTATE_OVRLD,
     * YHubPort.PORTSTATE_ON, YHubPort.PORTSTATE_RUN and YHubPort.PORTSTATE_PROG corresponding to the
     * current state of the Yocto-hub port
     *
     * On failure, throws an exception or returns YHubPort.PORTSTATE_INVALID.
     */
    get_portState() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PORTSTATE_INVALID;
                }
            }
            return _this3._portState;
        })();
    }

    /**
     * Returns the current baud rate used by this Yocto-hub port, in kbps.
     * The default value is 1000 kbps, but a slower rate may be used if communication
     * problems are encountered.
     *
     * @return {number} an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps
     *
     * On failure, throws an exception or returns YHubPort.BAUDRATE_INVALID.
     */
    get_baudRate() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BAUDRATE_INVALID;
                }
            }
            return _this4._baudRate;
        })();
    }

    /**
     * Retrieves a Yocto-hub port for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the Yocto-hub port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YHubPort.isOnline() to test if the Yocto-hub port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a Yocto-hub port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the Yocto-hub port
     *
     * @return {YHubPort} a YHubPort object allowing you to drive the Yocto-hub port.
     */
    static FindHubPort(func) {
        /** @type {YHubPort} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('HubPort', func);
        if (obj == null) {
            obj = new YHubPort(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('HubPort', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a Yocto-hub port for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the Yocto-hub port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YHubPort.isOnline() to test if the Yocto-hub port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a Yocto-hub port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the Yocto-hub port
     *
     * @return {YHubPort} a YHubPort object allowing you to drive the Yocto-hub port.
     */
    static FindHubPortInContext(yctx, func) {
        /** @type {YHubPort} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'HubPort', func);
        if (obj == null) {
            obj = new YHubPort(yctx, func);
            _yocto_api.YFunction._AddToCache('HubPort', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of Yocto-hub ports started using yFirstHubPort().
     *
     * @return {YHubPort} a pointer to a YHubPort object, corresponding to
     *         a Yocto-hub port currently online, or a null pointer
     *         if there are no more Yocto-hub ports to enumerate.
     */
    /* */nextHubPort() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YHubPort.FindHubPortInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of Yocto-hub ports currently accessible.
     * Use the method YHubPort.nextHubPort() to iterate on
     * next Yocto-hub ports.
     *
     * @return {YHubPort} a pointer to a YHubPort object, corresponding to
     *         the first Yocto-hub port currently online, or a null pointer
     *         if there are none.
     */
    static FirstHubPort() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('HubPort');
        if (next_hwid == null) return null;
        return YHubPort.FindHubPort(next_hwid);
    }

    /**
     * Starts the enumeration of Yocto-hub ports currently accessible.
     * Use the method YHubPort.nextHubPort() to iterate on
     * next Yocto-hub ports.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YHubPort} a pointer to a YHubPort object, corresponding to
     *         the first Yocto-hub port currently online, or a null pointer
     *         if there are none.
     */
    static FirstHubPortInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('HubPort');
        if (next_hwid == null) return null;
        return YHubPort.FindHubPortInContext(yctx, next_hwid);
    }

    //--- (end of YHubPort implementation)
}

exports.YHubPort = YHubPort; //--- (HubPort functions)

/**
 * comment from .yc definition
 */

function yFindHubPort(func) {
    return YHubPort.FindHubPort(func);
}

/**
 * comment from .yc definition
 */
function yFirstHubPort() {
    return YHubPort.FirstHubPort();
}

//--- (end of HubPort functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Humidity functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YHumidity = exports.Y_ABSHUM_INVALID = exports.Y_RELHUM_INVALID = undefined;
exports.yFindHumidity = yFindHumidity;
exports.yFirstHumidity = yFirstHumidity;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YHumidity return codes)
//--- (end of YHumidity return codes)
//--- (YHumidity definitions)
const Y_RELHUM_INVALID = exports.Y_RELHUM_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_ABSHUM_INVALID = exports.Y_ABSHUM_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YHumidity definitions)

//--- (YHumidity class start)
/**
 * YHumidity Class: Humidity function interface
 *
 * The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YHumidity class start)

class YHumidity extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YHumidity constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Humidity';
        /** @member {number} **/
        this._relHum = Y_RELHUM_INVALID;
        /** @member {number} **/
        this._absHum = Y_ABSHUM_INVALID;
        this.imm_setConst({
            RELHUM_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            ABSHUM_INVALID: _yocto_api.YAPI.INVALID_DOUBLE
        });
        //--- (end of YHumidity constructor)
    }

    //--- (YHumidity implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'relHum':
                this._relHum = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'absHum':
                this._absHum = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the primary unit for measuring humidity. That unit is a string.
     * If that strings starts with the letter 'g', the primary measured value is the absolute
     * humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity
     * (RH), in per cents.
     *
     * Remember to call the saveToFlash() method of the module if the modification
     * must be kept.
     *
     * @param newval {string} : a string corresponding to the primary unit for measuring humidity
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_unit(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this._setAttr('unit', rest_val);
        })();
    }

    /**
     * Returns the current relative humidity, in per cents.
     *
     * @return {number} a floating point number corresponding to the current relative humidity, in per cents
     *
     * On failure, throws an exception or returns YHumidity.RELHUM_INVALID.
     */
    get_relHum() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RELHUM_INVALID;
                }
            }
            return _this2._relHum;
        })();
    }

    /**
     * Returns the current absolute humidity, in grams per cubic meter of air.
     *
     * @return {number} a floating point number corresponding to the current absolute humidity, in grams
     * per cubic meter of air
     *
     * On failure, throws an exception or returns YHumidity.ABSHUM_INVALID.
     */
    get_absHum() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ABSHUM_INVALID;
                }
            }
            return _this3._absHum;
        })();
    }

    /**
     * Retrieves a humidity sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the humidity sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YHumidity.isOnline() to test if the humidity sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a humidity sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the humidity sensor
     *
     * @return {YHumidity} a YHumidity object allowing you to drive the humidity sensor.
     */
    static FindHumidity(func) {
        /** @type {YHumidity} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Humidity', func);
        if (obj == null) {
            obj = new YHumidity(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Humidity', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a humidity sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the humidity sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YHumidity.isOnline() to test if the humidity sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a humidity sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the humidity sensor
     *
     * @return {YHumidity} a YHumidity object allowing you to drive the humidity sensor.
     */
    static FindHumidityInContext(yctx, func) {
        /** @type {YHumidity} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Humidity', func);
        if (obj == null) {
            obj = new YHumidity(yctx, func);
            _yocto_api.YFunction._AddToCache('Humidity', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of humidity sensors started using yFirstHumidity().
     *
     * @return {YHumidity} a pointer to a YHumidity object, corresponding to
     *         a humidity sensor currently online, or a null pointer
     *         if there are no more humidity sensors to enumerate.
     */
    /* */nextHumidity() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YHumidity.FindHumidityInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of humidity sensors currently accessible.
     * Use the method YHumidity.nextHumidity() to iterate on
     * next humidity sensors.
     *
     * @return {YHumidity} a pointer to a YHumidity object, corresponding to
     *         the first humidity sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstHumidity() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Humidity');
        if (next_hwid == null) return null;
        return YHumidity.FindHumidity(next_hwid);
    }

    /**
     * Starts the enumeration of humidity sensors currently accessible.
     * Use the method YHumidity.nextHumidity() to iterate on
     * next humidity sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YHumidity} a pointer to a YHumidity object, corresponding to
     *         the first humidity sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstHumidityInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Humidity');
        if (next_hwid == null) return null;
        return YHumidity.FindHumidityInContext(yctx, next_hwid);
    }

    //--- (end of YHumidity implementation)
}

exports.YHumidity = YHumidity; //--- (Humidity functions)

/**
 * comment from .yc definition
 */

function yFindHumidity(func) {
    return YHumidity.FindHumidity(func);
}

/**
 * comment from .yc definition
 */
function yFirstHumidity() {
    return YHumidity.FirstHumidity();
}

//--- (end of Humidity functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Latitude functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YLatitude = undefined;
exports.yFindLatitude = yFindLatitude;
exports.yFirstLatitude = yFirstLatitude;

var _yocto_api = require('lib/yocto_api');

//--- (YLatitude return codes)
//--- (end of YLatitude return codes)
//--- (YLatitude definitions)
//--- (end of YLatitude definitions)

//--- (YLatitude class start)
/**
 * YLatitude Class: Latitude function interface
 *
 * The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce
 * geolocalization sensors. It inherits from the YSensor class the core functions to
 * read measurements, register callback functions, access the autonomous
 * datalogger.
 */
//--- (end of YLatitude class start)

class YLatitude extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YLatitude constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Latitude';
        //--- (end of YLatitude constructor)
    }

    //--- (YLatitude implementation)

    /**
     * Retrieves a latitude sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the latitude sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLatitude.isOnline() to test if the latitude sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a latitude sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the latitude sensor
     *
     * @return {YLatitude} a YLatitude object allowing you to drive the latitude sensor.
     */
    static FindLatitude(func) {
        /** @type {YLatitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Latitude', func);
        if (obj == null) {
            obj = new YLatitude(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Latitude', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a latitude sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the latitude sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLatitude.isOnline() to test if the latitude sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a latitude sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the latitude sensor
     *
     * @return {YLatitude} a YLatitude object allowing you to drive the latitude sensor.
     */
    static FindLatitudeInContext(yctx, func) {
        /** @type {YLatitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Latitude', func);
        if (obj == null) {
            obj = new YLatitude(yctx, func);
            _yocto_api.YFunction._AddToCache('Latitude', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of latitude sensors started using yFirstLatitude().
     *
     * @return {YLatitude} a pointer to a YLatitude object, corresponding to
     *         a latitude sensor currently online, or a null pointer
     *         if there are no more latitude sensors to enumerate.
     */
    /* */nextLatitude() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YLatitude.FindLatitudeInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of latitude sensors currently accessible.
     * Use the method YLatitude.nextLatitude() to iterate on
     * next latitude sensors.
     *
     * @return {YLatitude} a pointer to a YLatitude object, corresponding to
     *         the first latitude sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLatitude() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Latitude');
        if (next_hwid == null) return null;
        return YLatitude.FindLatitude(next_hwid);
    }

    /**
     * Starts the enumeration of latitude sensors currently accessible.
     * Use the method YLatitude.nextLatitude() to iterate on
     * next latitude sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YLatitude} a pointer to a YLatitude object, corresponding to
     *         the first latitude sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLatitudeInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Latitude');
        if (next_hwid == null) return null;
        return YLatitude.FindLatitudeInContext(yctx, next_hwid);
    }

    //--- (end of YLatitude implementation)
}

exports.YLatitude = YLatitude; //--- (Latitude functions)

/**
 * comment from .yc definition
 */

function yFindLatitude(func) {
    return YLatitude.FindLatitude(func);
}

/**
 * comment from .yc definition
 */
function yFirstLatitude() {
    return YLatitude.FirstLatitude();
}

//--- (end of Latitude functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Led functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YLed = exports.Y_LUMINOSITY_INVALID = exports.Y_BLINKING_INVALID = exports.Y_BLINKING_PANIC = exports.Y_BLINKING_CALL = exports.Y_BLINKING_RUN = exports.Y_BLINKING_AWARE = exports.Y_BLINKING_RELAX = exports.Y_BLINKING_STILL = exports.Y_POWER_INVALID = exports.Y_POWER_ON = exports.Y_POWER_OFF = undefined;
exports.yFindLed = yFindLed;
exports.yFirstLed = yFirstLed;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YLed return codes)
//--- (end of YLed return codes)
//--- (YLed definitions)
const Y_POWER_OFF = exports.Y_POWER_OFF = 0;
const Y_POWER_ON = exports.Y_POWER_ON = 1;
const Y_POWER_INVALID = exports.Y_POWER_INVALID = -1;
const Y_BLINKING_STILL = exports.Y_BLINKING_STILL = 0;
const Y_BLINKING_RELAX = exports.Y_BLINKING_RELAX = 1;
const Y_BLINKING_AWARE = exports.Y_BLINKING_AWARE = 2;
const Y_BLINKING_RUN = exports.Y_BLINKING_RUN = 3;
const Y_BLINKING_CALL = exports.Y_BLINKING_CALL = 4;
const Y_BLINKING_PANIC = exports.Y_BLINKING_PANIC = 5;
const Y_BLINKING_INVALID = exports.Y_BLINKING_INVALID = -1;
const Y_LUMINOSITY_INVALID = exports.Y_LUMINOSITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YLed definitions)

//--- (YLed class start)
/**
 * YLed Class: Led function interface
 *
 * Yoctopuce application programming interface
 * allows you not only to drive the intensity of the led, but also to
 * have it blink at various preset frequencies.
 */
//--- (end of YLed class start)

class YLed extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YLed constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Led';
        /** @member {number} **/
        this._power = Y_POWER_INVALID;
        /** @member {number} **/
        this._luminosity = Y_LUMINOSITY_INVALID;
        /** @member {number} **/
        this._blinking = Y_BLINKING_INVALID;
        this.imm_setConst({
            POWER_OFF: 0,
            POWER_ON: 1,
            POWER_INVALID: -1,
            LUMINOSITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            BLINKING_STILL: 0,
            BLINKING_RELAX: 1,
            BLINKING_AWARE: 2,
            BLINKING_RUN: 3,
            BLINKING_CALL: 4,
            BLINKING_PANIC: 5,
            BLINKING_INVALID: -1
        });
        //--- (end of YLed constructor)
    }

    //--- (YLed implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'power':
                this._power = parseInt(val);
                return 1;
            case 'luminosity':
                this._luminosity = parseInt(val);
                return 1;
            case 'blinking':
                this._blinking = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current led state.
     *
     * @return {number} either YLed.POWER_OFF or YLed.POWER_ON, according to the current led state
     *
     * On failure, throws an exception or returns YLed.POWER_INVALID.
     */
    get_power() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POWER_INVALID;
                }
            }
            return _this._power;
        })();
    }

    /**
     * Changes the state of the led.
     *
     * @param newval {number} : either YLed.POWER_OFF or YLed.POWER_ON, according to the state of the led
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_power(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('power', rest_val);
        })();
    }

    /**
     * Returns the current led intensity (in per cent).
     *
     * @return {number} an integer corresponding to the current led intensity (in per cent)
     *
     * On failure, throws an exception or returns YLed.LUMINOSITY_INVALID.
     */
    get_luminosity() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LUMINOSITY_INVALID;
                }
            }
            return _this3._luminosity;
        })();
    }

    /**
     * Changes the current led intensity (in per cent).
     *
     * @param newval {number} : an integer corresponding to the current led intensity (in per cent)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_luminosity(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('luminosity', rest_val);
        })();
    }

    /**
     * Returns the current led signaling mode.
     *
     * @return {number} a value among YLed.BLINKING_STILL, YLed.BLINKING_RELAX, YLed.BLINKING_AWARE,
     * YLed.BLINKING_RUN, YLed.BLINKING_CALL and YLed.BLINKING_PANIC corresponding to the current led signaling mode
     *
     * On failure, throws an exception or returns YLed.BLINKING_INVALID.
     */
    get_blinking() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BLINKING_INVALID;
                }
            }
            return _this5._blinking;
        })();
    }

    /**
     * Changes the current led signaling mode.
     *
     * @param newval {number} : a value among YLed.BLINKING_STILL, YLed.BLINKING_RELAX,
     * YLed.BLINKING_AWARE, YLed.BLINKING_RUN, YLed.BLINKING_CALL and YLed.BLINKING_PANIC corresponding to
     * the current led signaling mode
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_blinking(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('blinking', rest_val);
        })();
    }

    /**
     * Retrieves a led for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the led is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLed.isOnline() to test if the led is
     * indeed online at a given time. In case of ambiguity when looking for
     * a led by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the led
     *
     * @return {YLed} a YLed object allowing you to drive the led.
     */
    static FindLed(func) {
        /** @type {YLed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Led', func);
        if (obj == null) {
            obj = new YLed(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Led', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a led for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the led is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLed.isOnline() to test if the led is
     * indeed online at a given time. In case of ambiguity when looking for
     * a led by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the led
     *
     * @return {YLed} a YLed object allowing you to drive the led.
     */
    static FindLedInContext(yctx, func) {
        /** @type {YLed} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Led', func);
        if (obj == null) {
            obj = new YLed(yctx, func);
            _yocto_api.YFunction._AddToCache('Led', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of leds started using yFirstLed().
     *
     * @return {YLed} a pointer to a YLed object, corresponding to
     *         a led currently online, or a null pointer
     *         if there are no more leds to enumerate.
     */
    /* */nextLed() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YLed.FindLedInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of leds currently accessible.
     * Use the method YLed.nextLed() to iterate on
     * next leds.
     *
     * @return {YLed} a pointer to a YLed object, corresponding to
     *         the first led currently online, or a null pointer
     *         if there are none.
     */
    static FirstLed() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Led');
        if (next_hwid == null) return null;
        return YLed.FindLed(next_hwid);
    }

    /**
     * Starts the enumeration of leds currently accessible.
     * Use the method YLed.nextLed() to iterate on
     * next leds.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YLed} a pointer to a YLed object, corresponding to
     *         the first led currently online, or a null pointer
     *         if there are none.
     */
    static FirstLedInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Led');
        if (next_hwid == null) return null;
        return YLed.FindLedInContext(yctx, next_hwid);
    }

    //--- (end of YLed implementation)
}

exports.YLed = YLed; //--- (Led functions)

/**
 * comment from .yc definition
 */

function yFindLed(func) {
    return YLed.FindLed(func);
}

/**
 * comment from .yc definition
 */
function yFirstLed() {
    return YLed.FirstLed();
}

//--- (end of Led functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for LightSensor functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YLightSensor = exports.Y_MEASURETYPE_INVALID = exports.Y_MEASURETYPE_HIGH_ENERGY = exports.Y_MEASURETYPE_HIGH_RATE = exports.Y_MEASURETYPE_INFRARED = exports.Y_MEASURETYPE_WIDE_SPECTRUM = exports.Y_MEASURETYPE_HUMAN_EYE = undefined;
exports.yFindLightSensor = yFindLightSensor;
exports.yFirstLightSensor = yFirstLightSensor;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YLightSensor return codes)
//--- (end of YLightSensor return codes)
//--- (YLightSensor definitions)
const Y_MEASURETYPE_HUMAN_EYE = exports.Y_MEASURETYPE_HUMAN_EYE = 0;
const Y_MEASURETYPE_WIDE_SPECTRUM = exports.Y_MEASURETYPE_WIDE_SPECTRUM = 1;
const Y_MEASURETYPE_INFRARED = exports.Y_MEASURETYPE_INFRARED = 2;
const Y_MEASURETYPE_HIGH_RATE = exports.Y_MEASURETYPE_HIGH_RATE = 3;
const Y_MEASURETYPE_HIGH_ENERGY = exports.Y_MEASURETYPE_HIGH_ENERGY = 4;
const Y_MEASURETYPE_INVALID = exports.Y_MEASURETYPE_INVALID = -1;
//--- (end of YLightSensor definitions)

//--- (YLightSensor class start)
/**
 * YLightSensor Class: LightSensor function interface
 *
 * The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to easily perform a one-point linear calibration
 * to compensate the effect of a glass or filter placed in front of the sensor.
 * For some light sensors with several working modes, this class can select the
 * desired working mode.
 */
//--- (end of YLightSensor class start)

class YLightSensor extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YLightSensor constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'LightSensor';
        /** @member {number} **/
        this._measureType = Y_MEASURETYPE_INVALID;
        this.imm_setConst({
            MEASURETYPE_HUMAN_EYE: 0,
            MEASURETYPE_WIDE_SPECTRUM: 1,
            MEASURETYPE_INFRARED: 2,
            MEASURETYPE_HIGH_RATE: 3,
            MEASURETYPE_HIGH_ENERGY: 4,
            MEASURETYPE_INVALID: -1
        });
        //--- (end of YLightSensor constructor)
    }

    //--- (YLightSensor implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'measureType':
                this._measureType = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    set_currentValue(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this._setAttr('currentValue', rest_val);
        })();
    }

    /**
     * Changes the sensor-specific calibration parameter so that the current value
     * matches a desired target (linear scaling).
     *
     * @param calibratedVal {number} : the desired target value.
     *
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    calibrate(calibratedVal) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(calibratedVal * 65536.0));
            return yield _this2._setAttr('currentValue', rest_val);
        })();
    }

    /**
     * Returns the type of light measure.
     *
     * @return {number} a value among YLightSensor.MEASURETYPE_HUMAN_EYE,
     * YLightSensor.MEASURETYPE_WIDE_SPECTRUM, YLightSensor.MEASURETYPE_INFRARED,
     * YLightSensor.MEASURETYPE_HIGH_RATE and YLightSensor.MEASURETYPE_HIGH_ENERGY corresponding to the
     * type of light measure
     *
     * On failure, throws an exception or returns YLightSensor.MEASURETYPE_INVALID.
     */
    get_measureType() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MEASURETYPE_INVALID;
                }
            }
            return _this3._measureType;
        })();
    }

    /**
     * Modify the light sensor type used in the device. The measure can either
     * approximate the response of the human eye, focus on a specific light
     * spectrum, depending on the capabilities of the light-sensitive cell.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : a value among YLightSensor.MEASURETYPE_HUMAN_EYE,
     * YLightSensor.MEASURETYPE_WIDE_SPECTRUM, YLightSensor.MEASURETYPE_INFRARED,
     * YLightSensor.MEASURETYPE_HIGH_RATE and YLightSensor.MEASURETYPE_HIGH_ENERGY
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_measureType(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('measureType', rest_val);
        })();
    }

    /**
     * Retrieves a light sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the light sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLightSensor.isOnline() to test if the light sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a light sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the light sensor
     *
     * @return {YLightSensor} a YLightSensor object allowing you to drive the light sensor.
     */
    static FindLightSensor(func) {
        /** @type {YLightSensor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('LightSensor', func);
        if (obj == null) {
            obj = new YLightSensor(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('LightSensor', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a light sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the light sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLightSensor.isOnline() to test if the light sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a light sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the light sensor
     *
     * @return {YLightSensor} a YLightSensor object allowing you to drive the light sensor.
     */
    static FindLightSensorInContext(yctx, func) {
        /** @type {YLightSensor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'LightSensor', func);
        if (obj == null) {
            obj = new YLightSensor(yctx, func);
            _yocto_api.YFunction._AddToCache('LightSensor', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of light sensors started using yFirstLightSensor().
     *
     * @return {YLightSensor} a pointer to a YLightSensor object, corresponding to
     *         a light sensor currently online, or a null pointer
     *         if there are no more light sensors to enumerate.
     */
    /* */nextLightSensor() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YLightSensor.FindLightSensorInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of light sensors currently accessible.
     * Use the method YLightSensor.nextLightSensor() to iterate on
     * next light sensors.
     *
     * @return {YLightSensor} a pointer to a YLightSensor object, corresponding to
     *         the first light sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLightSensor() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('LightSensor');
        if (next_hwid == null) return null;
        return YLightSensor.FindLightSensor(next_hwid);
    }

    /**
     * Starts the enumeration of light sensors currently accessible.
     * Use the method YLightSensor.nextLightSensor() to iterate on
     * next light sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YLightSensor} a pointer to a YLightSensor object, corresponding to
     *         the first light sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLightSensorInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('LightSensor');
        if (next_hwid == null) return null;
        return YLightSensor.FindLightSensorInContext(yctx, next_hwid);
    }

    //--- (end of YLightSensor implementation)
}

exports.YLightSensor = YLightSensor; //--- (LightSensor functions)

/**
 * comment from .yc definition
 */

function yFindLightSensor(func) {
    return YLightSensor.FindLightSensor(func);
}

/**
 * comment from .yc definition
 */
function yFirstLightSensor() {
    return YLightSensor.FirstLightSensor();
}

//--- (end of LightSensor functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Longitude functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YLongitude = undefined;
exports.yFindLongitude = yFindLongitude;
exports.yFirstLongitude = yFirstLongitude;

var _yocto_api = require('lib/yocto_api');

//--- (YLongitude return codes)
//--- (end of YLongitude return codes)
//--- (YLongitude definitions)
//--- (end of YLongitude definitions)

//--- (YLongitude class start)
/**
 * YLongitude Class: Longitude function interface
 *
 * The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce
 * geolocalization sensors. It inherits from the YSensor class the core functions to
 * read measurements, register callback functions, access the autonomous
 * datalogger.
 */
//--- (end of YLongitude class start)

class YLongitude extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YLongitude constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Longitude';
        //--- (end of YLongitude constructor)
    }

    //--- (YLongitude implementation)

    /**
     * Retrieves a longitude sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the longitude sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLongitude.isOnline() to test if the longitude sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a longitude sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the longitude sensor
     *
     * @return {YLongitude} a YLongitude object allowing you to drive the longitude sensor.
     */
    static FindLongitude(func) {
        /** @type {YLongitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Longitude', func);
        if (obj == null) {
            obj = new YLongitude(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Longitude', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a longitude sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the longitude sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YLongitude.isOnline() to test if the longitude sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a longitude sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the longitude sensor
     *
     * @return {YLongitude} a YLongitude object allowing you to drive the longitude sensor.
     */
    static FindLongitudeInContext(yctx, func) {
        /** @type {YLongitude} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Longitude', func);
        if (obj == null) {
            obj = new YLongitude(yctx, func);
            _yocto_api.YFunction._AddToCache('Longitude', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of longitude sensors started using yFirstLongitude().
     *
     * @return {YLongitude} a pointer to a YLongitude object, corresponding to
     *         a longitude sensor currently online, or a null pointer
     *         if there are no more longitude sensors to enumerate.
     */
    /* */nextLongitude() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YLongitude.FindLongitudeInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of longitude sensors currently accessible.
     * Use the method YLongitude.nextLongitude() to iterate on
     * next longitude sensors.
     *
     * @return {YLongitude} a pointer to a YLongitude object, corresponding to
     *         the first longitude sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLongitude() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Longitude');
        if (next_hwid == null) return null;
        return YLongitude.FindLongitude(next_hwid);
    }

    /**
     * Starts the enumeration of longitude sensors currently accessible.
     * Use the method YLongitude.nextLongitude() to iterate on
     * next longitude sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YLongitude} a pointer to a YLongitude object, corresponding to
     *         the first longitude sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstLongitudeInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Longitude');
        if (next_hwid == null) return null;
        return YLongitude.FindLongitudeInContext(yctx, next_hwid);
    }

    //--- (end of YLongitude implementation)
}

exports.YLongitude = YLongitude; //--- (Longitude functions)

/**
 * comment from .yc definition
 */

function yFindLongitude(func) {
    return YLongitude.FindLongitude(func);
}

/**
 * comment from .yc definition
 */
function yFirstLongitude() {
    return YLongitude.FirstLongitude();
}

//--- (end of Longitude functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Magnetometer functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YMagnetometer = exports.Y_ZVALUE_INVALID = exports.Y_YVALUE_INVALID = exports.Y_XVALUE_INVALID = undefined;
exports.yFindMagnetometer = yFindMagnetometer;
exports.yFirstMagnetometer = yFirstMagnetometer;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YMagnetometer return codes)
//--- (end of YMagnetometer return codes)
//--- (YMagnetometer definitions)
const Y_XVALUE_INVALID = exports.Y_XVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_YVALUE_INVALID = exports.Y_YVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_ZVALUE_INVALID = exports.Y_ZVALUE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YMagnetometer definitions)

//--- (YMagnetometer class start)
/**
 * YMagnetometer Class: Magnetometer function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of YMagnetometer class start)

class YMagnetometer extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YMagnetometer constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Magnetometer';
        /** @member {number} **/
        this._xValue = Y_XVALUE_INVALID;
        /** @member {number} **/
        this._yValue = Y_YVALUE_INVALID;
        /** @member {number} **/
        this._zValue = Y_ZVALUE_INVALID;
        this.imm_setConst({
            XVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            YVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            ZVALUE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE
        });
        //--- (end of YMagnetometer constructor)
    }

    //--- (YMagnetometer implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'xValue':
                this._xValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'yValue':
                this._yValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'zValue':
                this._zValue = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the X component of the magnetic field, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the X component of the magnetic field, as
     * a floating point number
     *
     * On failure, throws an exception or returns YMagnetometer.XVALUE_INVALID.
     */
    get_xValue() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_XVALUE_INVALID;
                }
            }
            return _this._xValue;
        })();
    }

    /**
     * Returns the Y component of the magnetic field, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the Y component of the magnetic field, as
     * a floating point number
     *
     * On failure, throws an exception or returns YMagnetometer.YVALUE_INVALID.
     */
    get_yValue() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_YVALUE_INVALID;
                }
            }
            return _this2._yValue;
        })();
    }

    /**
     * Returns the Z component of the magnetic field, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the Z component of the magnetic field, as
     * a floating point number
     *
     * On failure, throws an exception or returns YMagnetometer.ZVALUE_INVALID.
     */
    get_zValue() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ZVALUE_INVALID;
                }
            }
            return _this3._zValue;
        })();
    }

    /**
     * Retrieves a magnetometer for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the magnetometer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YMagnetometer.isOnline() to test if the magnetometer is
     * indeed online at a given time. In case of ambiguity when looking for
     * a magnetometer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the magnetometer
     *
     * @return {YMagnetometer} a YMagnetometer object allowing you to drive the magnetometer.
     */
    static FindMagnetometer(func) {
        /** @type {YMagnetometer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Magnetometer', func);
        if (obj == null) {
            obj = new YMagnetometer(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Magnetometer', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a magnetometer for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the magnetometer is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YMagnetometer.isOnline() to test if the magnetometer is
     * indeed online at a given time. In case of ambiguity when looking for
     * a magnetometer by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the magnetometer
     *
     * @return {YMagnetometer} a YMagnetometer object allowing you to drive the magnetometer.
     */
    static FindMagnetometerInContext(yctx, func) {
        /** @type {YMagnetometer} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Magnetometer', func);
        if (obj == null) {
            obj = new YMagnetometer(yctx, func);
            _yocto_api.YFunction._AddToCache('Magnetometer', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of magnetometers started using yFirstMagnetometer().
     *
     * @return {YMagnetometer} a pointer to a YMagnetometer object, corresponding to
     *         a magnetometer currently online, or a null pointer
     *         if there are no more magnetometers to enumerate.
     */
    /* */nextMagnetometer() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YMagnetometer.FindMagnetometerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of magnetometers currently accessible.
     * Use the method YMagnetometer.nextMagnetometer() to iterate on
     * next magnetometers.
     *
     * @return {YMagnetometer} a pointer to a YMagnetometer object, corresponding to
     *         the first magnetometer currently online, or a null pointer
     *         if there are none.
     */
    static FirstMagnetometer() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Magnetometer');
        if (next_hwid == null) return null;
        return YMagnetometer.FindMagnetometer(next_hwid);
    }

    /**
     * Starts the enumeration of magnetometers currently accessible.
     * Use the method YMagnetometer.nextMagnetometer() to iterate on
     * next magnetometers.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YMagnetometer} a pointer to a YMagnetometer object, corresponding to
     *         the first magnetometer currently online, or a null pointer
     *         if there are none.
     */
    static FirstMagnetometerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Magnetometer');
        if (next_hwid == null) return null;
        return YMagnetometer.FindMagnetometerInContext(yctx, next_hwid);
    }

    //--- (end of YMagnetometer implementation)
}

exports.YMagnetometer = YMagnetometer; //--- (Magnetometer functions)

/**
 * comment from .yc definition
 */

function yFindMagnetometer(func) {
    return YMagnetometer.FindMagnetometer(func);
}

/**
 * comment from .yc definition
 */
function yFirstMagnetometer() {
    return YMagnetometer.FirstMagnetometer();
}

//--- (end of Magnetometer functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Motor functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YMotor = exports.Y_COMMAND_INVALID = exports.Y_FAILSAFETIMEOUT_INVALID = exports.Y_STARTERTIME_INVALID = exports.Y_FREQUENCY_INVALID = exports.Y_OVERCURRENTLIMIT_INVALID = exports.Y_CUTOFFVOLTAGE_INVALID = exports.Y_BRAKINGFORCE_INVALID = exports.Y_DRIVINGFORCE_INVALID = exports.Y_MOTORSTATUS_INVALID = exports.Y_MOTORSTATUS_FAILSF = exports.Y_MOTORSTATUS_HIHEAT = exports.Y_MOTORSTATUS_HICURR = exports.Y_MOTORSTATUS_LOVOLT = exports.Y_MOTORSTATUS_BACKWD = exports.Y_MOTORSTATUS_FORWD = exports.Y_MOTORSTATUS_BRAKE = exports.Y_MOTORSTATUS_IDLE = undefined;
exports.yFindMotor = yFindMotor;
exports.yFirstMotor = yFirstMotor;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YMotor return codes)
//--- (end of YMotor return codes)
//--- (YMotor definitions)
const Y_MOTORSTATUS_IDLE = exports.Y_MOTORSTATUS_IDLE = 0;
const Y_MOTORSTATUS_BRAKE = exports.Y_MOTORSTATUS_BRAKE = 1;
const Y_MOTORSTATUS_FORWD = exports.Y_MOTORSTATUS_FORWD = 2;
const Y_MOTORSTATUS_BACKWD = exports.Y_MOTORSTATUS_BACKWD = 3;
const Y_MOTORSTATUS_LOVOLT = exports.Y_MOTORSTATUS_LOVOLT = 4;
const Y_MOTORSTATUS_HICURR = exports.Y_MOTORSTATUS_HICURR = 5;
const Y_MOTORSTATUS_HIHEAT = exports.Y_MOTORSTATUS_HIHEAT = 6;
const Y_MOTORSTATUS_FAILSF = exports.Y_MOTORSTATUS_FAILSF = 7;
const Y_MOTORSTATUS_INVALID = exports.Y_MOTORSTATUS_INVALID = -1;
const Y_DRIVINGFORCE_INVALID = exports.Y_DRIVINGFORCE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_BRAKINGFORCE_INVALID = exports.Y_BRAKINGFORCE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_CUTOFFVOLTAGE_INVALID = exports.Y_CUTOFFVOLTAGE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_OVERCURRENTLIMIT_INVALID = exports.Y_OVERCURRENTLIMIT_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_FREQUENCY_INVALID = exports.Y_FREQUENCY_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_STARTERTIME_INVALID = exports.Y_STARTERTIME_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_FAILSAFETIMEOUT_INVALID = exports.Y_FAILSAFETIMEOUT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YMotor definitions)

//--- (YMotor class start)
/**
 * YMotor Class: Motor function interface
 *
 * Yoctopuce application programming interface allows you to drive the
 * power sent to the motor to make it turn both ways, but also to drive accelerations
 * and decelerations. The motor will then accelerate automatically: you will not
 * have to monitor it. The API also allows to slow down the motor by shortening
 * its terminals: the motor will then act as an electromagnetic brake.
 */
//--- (end of YMotor class start)

class YMotor extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YMotor constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Motor';
        /** @member {number} **/
        this._motorStatus = Y_MOTORSTATUS_INVALID;
        /** @member {number} **/
        this._drivingForce = Y_DRIVINGFORCE_INVALID;
        /** @member {number} **/
        this._brakingForce = Y_BRAKINGFORCE_INVALID;
        /** @member {number} **/
        this._cutOffVoltage = Y_CUTOFFVOLTAGE_INVALID;
        /** @member {number} **/
        this._overCurrentLimit = Y_OVERCURRENTLIMIT_INVALID;
        /** @member {number} **/
        this._frequency = Y_FREQUENCY_INVALID;
        /** @member {number} **/
        this._starterTime = Y_STARTERTIME_INVALID;
        /** @member {number} **/
        this._failSafeTimeout = Y_FAILSAFETIMEOUT_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            MOTORSTATUS_IDLE: 0,
            MOTORSTATUS_BRAKE: 1,
            MOTORSTATUS_FORWD: 2,
            MOTORSTATUS_BACKWD: 3,
            MOTORSTATUS_LOVOLT: 4,
            MOTORSTATUS_HICURR: 5,
            MOTORSTATUS_HIHEAT: 6,
            MOTORSTATUS_FAILSF: 7,
            MOTORSTATUS_INVALID: -1,
            DRIVINGFORCE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            BRAKINGFORCE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            CUTOFFVOLTAGE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            OVERCURRENTLIMIT_INVALID: _yocto_api.YAPI.INVALID_INT,
            FREQUENCY_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            STARTERTIME_INVALID: _yocto_api.YAPI.INVALID_INT,
            FAILSAFETIMEOUT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YMotor constructor)
    }

    //--- (YMotor implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'motorStatus':
                this._motorStatus = parseInt(val);
                return 1;
            case 'drivingForce':
                this._drivingForce = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'brakingForce':
                this._brakingForce = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'cutOffVoltage':
                this._cutOffVoltage = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'overCurrentLimit':
                this._overCurrentLimit = parseInt(val);
                return 1;
            case 'frequency':
                this._frequency = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'starterTime':
                this._starterTime = parseInt(val);
                return 1;
            case 'failSafeTimeout':
                this._failSafeTimeout = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Return the controller state. Possible states are:
     * IDLE   when the motor is stopped/in free wheel, ready to start;
     * FORWD  when the controller is driving the motor forward;
     * BACKWD when the controller is driving the motor backward;
     * BRAKE  when the controller is braking;
     * LOVOLT when the controller has detected a low voltage condition;
     * HICURR when the controller has detected an overcurrent condition;
     * HIHEAT when the controller has detected an overheat condition;
     * FAILSF when the controller switched on the failsafe security.
     *
     * When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller
     * status must be explicitly reset using the resetStatus function.
     *
     * @return {number} a value among YMotor.MOTORSTATUS_IDLE, YMotor.MOTORSTATUS_BRAKE,
     * YMotor.MOTORSTATUS_FORWD, YMotor.MOTORSTATUS_BACKWD, YMotor.MOTORSTATUS_LOVOLT,
     * YMotor.MOTORSTATUS_HICURR, YMotor.MOTORSTATUS_HIHEAT and YMotor.MOTORSTATUS_FAILSF
     *
     * On failure, throws an exception or returns YMotor.MOTORSTATUS_INVALID.
     */
    get_motorStatus() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MOTORSTATUS_INVALID;
                }
            }
            return _this._motorStatus;
        })();
    }

    set_motorStatus(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('motorStatus', rest_val);
        })();
    }

    /**
     * Changes immediately the power sent to the motor. The value is a percentage between -100%
     * to 100%. If you want go easy on your mechanics and avoid excessive current consumption,
     * try to avoid brutal power changes. For example, immediate transition from forward full power
     * to reverse full power is a very bad idea. Each time the driving power is modified, the
     * braking power is set to zero.
     *
     * @param newval {number} : a floating point number corresponding to immediately the power sent to the motor
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_drivingForce(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this3._setAttr('drivingForce', rest_val);
        })();
    }

    /**
     * Returns the power sent to the motor, as a percentage between -100% and +100%.
     *
     * @return {number} a floating point number corresponding to the power sent to the motor, as a
     * percentage between -100% and +100%
     *
     * On failure, throws an exception or returns YMotor.DRIVINGFORCE_INVALID.
     */
    get_drivingForce() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DRIVINGFORCE_INVALID;
                }
            }
            return _this4._drivingForce;
        })();
    }

    /**
     * Changes immediately the braking force applied to the motor (in percents).
     * The value 0 corresponds to no braking (free wheel). When the braking force
     * is changed, the driving power is set to zero. The value is a percentage.
     *
     * @param newval {number} : a floating point number corresponding to immediately the braking force
     * applied to the motor (in percents)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_brakingForce(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this5._setAttr('brakingForce', rest_val);
        })();
    }

    /**
     * Returns the braking force applied to the motor, as a percentage.
     * The value 0 corresponds to no braking (free wheel).
     *
     * @return {number} a floating point number corresponding to the braking force applied to the motor,
     * as a percentage
     *
     * On failure, throws an exception or returns YMotor.BRAKINGFORCE_INVALID.
     */
    get_brakingForce() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BRAKINGFORCE_INVALID;
                }
            }
            return _this6._brakingForce;
        })();
    }

    /**
     * Changes the threshold voltage under which the controller automatically switches to error state
     * and prevents further current draw. This setting prevent damage to a battery that can
     * occur when drawing current from an "empty" battery.
     * Note that whatever the cutoff threshold, the controller switches to undervoltage
     * error state if the power supply goes under 3V, even for a very brief time.
     *
     * @param newval {number} : a floating point number corresponding to the threshold voltage under which
     * the controller automatically switches to error state
     *         and prevents further current draw
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_cutOffVoltage(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this7._setAttr('cutOffVoltage', rest_val);
        })();
    }

    /**
     * Returns the threshold voltage under which the controller automatically switches to error state
     * and prevents further current draw. This setting prevents damage to a battery that can
     * occur when drawing current from an "empty" battery.
     *
     * @return {number} a floating point number corresponding to the threshold voltage under which the
     * controller automatically switches to error state
     *         and prevents further current draw
     *
     * On failure, throws an exception or returns YMotor.CUTOFFVOLTAGE_INVALID.
     */
    get_cutOffVoltage() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CUTOFFVOLTAGE_INVALID;
                }
            }
            return _this8._cutOffVoltage;
        })();
    }

    /**
     * Returns the current threshold (in mA) above which the controller automatically
     * switches to error state. A zero value means that there is no limit.
     *
     * @return {number} an integer corresponding to the current threshold (in mA) above which the
     * controller automatically
     *         switches to error state
     *
     * On failure, throws an exception or returns YMotor.OVERCURRENTLIMIT_INVALID.
     */
    get_overCurrentLimit() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_OVERCURRENTLIMIT_INVALID;
                }
            }
            return _this9._overCurrentLimit;
        })();
    }

    /**
     * Changes the current threshold (in mA) above which the controller automatically
     * switches to error state. A zero value means that there is no limit. Note that whatever the
     * current limit is, the controller switches to OVERCURRENT status if the current
     * goes above 32A, even for a very brief time.
     *
     * @param newval {number} : an integer corresponding to the current threshold (in mA) above which the
     * controller automatically
     *         switches to error state
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_overCurrentLimit(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('overCurrentLimit', rest_val);
        })();
    }

    /**
     * Changes the PWM frequency used to control the motor. Low frequency is usually
     * more efficient and may help the motor to start, but an audible noise might be
     * generated. A higher frequency reduces the noise, but more energy is converted
     * into heat.
     *
     * @param newval {number} : a floating point number corresponding to the PWM frequency used to control the motor
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_frequency(newval) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this11._setAttr('frequency', rest_val);
        })();
    }

    /**
     * Returns the PWM frequency used to control the motor.
     *
     * @return {number} a floating point number corresponding to the PWM frequency used to control the motor
     *
     * On failure, throws an exception or returns YMotor.FREQUENCY_INVALID.
     */
    get_frequency() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FREQUENCY_INVALID;
                }
            }
            return _this12._frequency;
        })();
    }

    /**
     * Returns the duration (in ms) during which the motor is driven at low frequency to help
     * it start up.
     *
     * @return {number} an integer corresponding to the duration (in ms) during which the motor is driven
     * at low frequency to help
     *         it start up
     *
     * On failure, throws an exception or returns YMotor.STARTERTIME_INVALID.
     */
    get_starterTime() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STARTERTIME_INVALID;
                }
            }
            return _this13._starterTime;
        })();
    }

    /**
     * Changes the duration (in ms) during which the motor is driven at low frequency to help
     * it start up.
     *
     * @param newval {number} : an integer corresponding to the duration (in ms) during which the motor is
     * driven at low frequency to help
     *         it start up
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_starterTime(newval) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this14._setAttr('starterTime', rest_val);
        })();
    }

    /**
     * Returns the delay in milliseconds allowed for the controller to run autonomously without
     * receiving any instruction from the control process. When this delay has elapsed,
     * the controller automatically stops the motor and switches to FAILSAFE error.
     * Failsafe security is disabled when the value is zero.
     *
     * @return {number} an integer corresponding to the delay in milliseconds allowed for the controller
     * to run autonomously without
     *         receiving any instruction from the control process
     *
     * On failure, throws an exception or returns YMotor.FAILSAFETIMEOUT_INVALID.
     */
    get_failSafeTimeout() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FAILSAFETIMEOUT_INVALID;
                }
            }
            return _this15._failSafeTimeout;
        })();
    }

    /**
     * Changes the delay in milliseconds allowed for the controller to run autonomously without
     * receiving any instruction from the control process. When this delay has elapsed,
     * the controller automatically stops the motor and switches to FAILSAFE error.
     * Failsafe security is disabled when the value is zero.
     *
     * @param newval {number} : an integer corresponding to the delay in milliseconds allowed for the
     * controller to run autonomously without
     *         receiving any instruction from the control process
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_failSafeTimeout(newval) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this16._setAttr('failSafeTimeout', rest_val);
        })();
    }

    get_command() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (_this17._cacheExpiration <= _this17._yapi.GetTickCount()) {
                if ((yield _this17.load(_this17._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this17._command;
        })();
    }

    set_command(newval) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this18._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a motor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the motor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YMotor.isOnline() to test if the motor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a motor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the motor
     *
     * @return {YMotor} a YMotor object allowing you to drive the motor.
     */
    static FindMotor(func) {
        /** @type {YMotor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Motor', func);
        if (obj == null) {
            obj = new YMotor(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Motor', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a motor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the motor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YMotor.isOnline() to test if the motor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a motor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the motor
     *
     * @return {YMotor} a YMotor object allowing you to drive the motor.
     */
    static FindMotorInContext(yctx, func) {
        /** @type {YMotor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Motor', func);
        if (obj == null) {
            obj = new YMotor(yctx, func);
            _yocto_api.YFunction._AddToCache('Motor', func, obj);
        }
        return obj;
    }

    /**
     * Rearms the controller failsafe timer. When the motor is running and the failsafe feature
     * is active, this function should be called periodically to prove that the control process
     * is running properly. Otherwise, the motor is automatically stopped after the specified
     * timeout. Calling a motor <i>set</i> function implicitely rearms the failsafe timer.
     */
    keepALive() {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.set_command('K');
        })();
    }

    /**
     * Reset the controller state to IDLE. This function must be invoked explicitely
     * after any error condition is signaled.
     */
    resetStatus() {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            return yield _this20.set_motorStatus(Y_MOTORSTATUS_IDLE);
        })();
    }

    /**
     * Changes progressively the power sent to the moteur for a specific duration.
     *
     * @param targetPower {number} : desired motor power, in percents (between -100% and +100%)
     * @param delay {number} : duration (in ms) of the transition
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    drivingForceMove(targetPower, delay) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            return yield _this21.set_command('P' + String(Math.round(Math.round(targetPower * 10))) + ',' + String(Math.round(delay)));
        })();
    }

    /**
     * Changes progressively the braking force applied to the motor for a specific duration.
     *
     * @param targetPower {number} : desired braking force, in percents
     * @param delay {number} : duration (in ms) of the transition
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    brakingForceMove(targetPower, delay) {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            return yield _this22.set_command('B' + String(Math.round(Math.round(targetPower * 10))) + ',' + String(Math.round(delay)));
        })();
    }

    /**
     * Continues the enumeration of motors started using yFirstMotor().
     *
     * @return {YMotor} a pointer to a YMotor object, corresponding to
     *         a motor currently online, or a null pointer
     *         if there are no more motors to enumerate.
     */
    /* */nextMotor() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YMotor.FindMotorInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of motors currently accessible.
     * Use the method YMotor.nextMotor() to iterate on
     * next motors.
     *
     * @return {YMotor} a pointer to a YMotor object, corresponding to
     *         the first motor currently online, or a null pointer
     *         if there are none.
     */
    static FirstMotor() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Motor');
        if (next_hwid == null) return null;
        return YMotor.FindMotor(next_hwid);
    }

    /**
     * Starts the enumeration of motors currently accessible.
     * Use the method YMotor.nextMotor() to iterate on
     * next motors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YMotor} a pointer to a YMotor object, corresponding to
     *         the first motor currently online, or a null pointer
     *         if there are none.
     */
    static FirstMotorInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Motor');
        if (next_hwid == null) return null;
        return YMotor.FindMotorInContext(yctx, next_hwid);
    }

    //--- (end of YMotor implementation)
}

exports.YMotor = YMotor; //--- (Motor functions)

/**
 * comment from .yc definition
 */

function yFindMotor(func) {
    return YMotor.FindMotor(func);
}

/**
 * comment from .yc definition
 */
function yFirstMotor() {
    return YMotor.FirstMotor();
}

//--- (end of Motor functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Network functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YNetwork = exports.Y_POECURRENT_INVALID = exports.Y_CALLBACKMAXDELAY_INVALID = exports.Y_CALLBACKMINDELAY_INVALID = exports.Y_CALLBACKCREDENTIALS_INVALID = exports.Y_CALLBACKURL_INVALID = exports.Y_WWWWATCHDOGDELAY_INVALID = exports.Y_DEFAULTPAGE_INVALID = exports.Y_HTTPPORT_INVALID = exports.Y_ADMINPASSWORD_INVALID = exports.Y_USERPASSWORD_INVALID = exports.Y_NTPSERVER_INVALID = exports.Y_SECONDARYDNS_INVALID = exports.Y_PRIMARYDNS_INVALID = exports.Y_IPCONFIG_INVALID = exports.Y_ROUTER_INVALID = exports.Y_SUBNETMASK_INVALID = exports.Y_IPADDRESS_INVALID = exports.Y_MACADDRESS_INVALID = exports.Y_CALLBACKENCODING_INVALID = exports.Y_CALLBACKENCODING_INFLUXDB = exports.Y_CALLBACKENCODING_AZURE = exports.Y_CALLBACKENCODING_EMONCMS = exports.Y_CALLBACKENCODING_JSON_NUM = exports.Y_CALLBACKENCODING_YOCTO_API = exports.Y_CALLBACKENCODING_CSV = exports.Y_CALLBACKENCODING_JSON_ARRAY = exports.Y_CALLBACKENCODING_JSON = exports.Y_CALLBACKENCODING_FORM = exports.Y_CALLBACKMETHOD_INVALID = exports.Y_CALLBACKMETHOD_PUT = exports.Y_CALLBACKMETHOD_GET = exports.Y_CALLBACKMETHOD_POST = exports.Y_DISCOVERABLE_INVALID = exports.Y_DISCOVERABLE_TRUE = exports.Y_DISCOVERABLE_FALSE = exports.Y_READINESS_INVALID = exports.Y_READINESS_WWW_OK = exports.Y_READINESS_LAN_OK = exports.Y_READINESS_LINKED = exports.Y_READINESS_EXISTS = exports.Y_READINESS_DOWN = undefined;
exports.yFindNetwork = yFindNetwork;
exports.yFirstNetwork = yFirstNetwork;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YNetwork return codes)
//--- (end of YNetwork return codes)
//--- (YNetwork definitions)
const Y_READINESS_DOWN = exports.Y_READINESS_DOWN = 0;
const Y_READINESS_EXISTS = exports.Y_READINESS_EXISTS = 1;
const Y_READINESS_LINKED = exports.Y_READINESS_LINKED = 2;
const Y_READINESS_LAN_OK = exports.Y_READINESS_LAN_OK = 3;
const Y_READINESS_WWW_OK = exports.Y_READINESS_WWW_OK = 4;
const Y_READINESS_INVALID = exports.Y_READINESS_INVALID = -1;
const Y_DISCOVERABLE_FALSE = exports.Y_DISCOVERABLE_FALSE = 0;
const Y_DISCOVERABLE_TRUE = exports.Y_DISCOVERABLE_TRUE = 1;
const Y_DISCOVERABLE_INVALID = exports.Y_DISCOVERABLE_INVALID = -1;
const Y_CALLBACKMETHOD_POST = exports.Y_CALLBACKMETHOD_POST = 0;
const Y_CALLBACKMETHOD_GET = exports.Y_CALLBACKMETHOD_GET = 1;
const Y_CALLBACKMETHOD_PUT = exports.Y_CALLBACKMETHOD_PUT = 2;
const Y_CALLBACKMETHOD_INVALID = exports.Y_CALLBACKMETHOD_INVALID = -1;
const Y_CALLBACKENCODING_FORM = exports.Y_CALLBACKENCODING_FORM = 0;
const Y_CALLBACKENCODING_JSON = exports.Y_CALLBACKENCODING_JSON = 1;
const Y_CALLBACKENCODING_JSON_ARRAY = exports.Y_CALLBACKENCODING_JSON_ARRAY = 2;
const Y_CALLBACKENCODING_CSV = exports.Y_CALLBACKENCODING_CSV = 3;
const Y_CALLBACKENCODING_YOCTO_API = exports.Y_CALLBACKENCODING_YOCTO_API = 4;
const Y_CALLBACKENCODING_JSON_NUM = exports.Y_CALLBACKENCODING_JSON_NUM = 5;
const Y_CALLBACKENCODING_EMONCMS = exports.Y_CALLBACKENCODING_EMONCMS = 6;
const Y_CALLBACKENCODING_AZURE = exports.Y_CALLBACKENCODING_AZURE = 7;
const Y_CALLBACKENCODING_INFLUXDB = exports.Y_CALLBACKENCODING_INFLUXDB = 8;
const Y_CALLBACKENCODING_INVALID = exports.Y_CALLBACKENCODING_INVALID = -1;
const Y_MACADDRESS_INVALID = exports.Y_MACADDRESS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_IPADDRESS_INVALID = exports.Y_IPADDRESS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SUBNETMASK_INVALID = exports.Y_SUBNETMASK_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_ROUTER_INVALID = exports.Y_ROUTER_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_IPCONFIG_INVALID = exports.Y_IPCONFIG_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_PRIMARYDNS_INVALID = exports.Y_PRIMARYDNS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_SECONDARYDNS_INVALID = exports.Y_SECONDARYDNS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_NTPSERVER_INVALID = exports.Y_NTPSERVER_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_USERPASSWORD_INVALID = exports.Y_USERPASSWORD_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_ADMINPASSWORD_INVALID = exports.Y_ADMINPASSWORD_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_HTTPPORT_INVALID = exports.Y_HTTPPORT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_DEFAULTPAGE_INVALID = exports.Y_DEFAULTPAGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_WWWWATCHDOGDELAY_INVALID = exports.Y_WWWWATCHDOGDELAY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_CALLBACKURL_INVALID = exports.Y_CALLBACKURL_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CALLBACKCREDENTIALS_INVALID = exports.Y_CALLBACKCREDENTIALS_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CALLBACKMINDELAY_INVALID = exports.Y_CALLBACKMINDELAY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_CALLBACKMAXDELAY_INVALID = exports.Y_CALLBACKMAXDELAY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_POECURRENT_INVALID = exports.Y_POECURRENT_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YNetwork definitions)

//--- (YNetwork class start)
/**
 * YNetwork Class: Network function interface
 *
 * YNetwork objects provide access to TCP/IP parameters of Yoctopuce
 * modules that include a built-in network interface.
 */
//--- (end of YNetwork class start)

class YNetwork extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YNetwork constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Network';
        /** @member {number} **/
        this._readiness = Y_READINESS_INVALID;
        /** @member {string} **/
        this._macAddress = Y_MACADDRESS_INVALID;
        /** @member {string} **/
        this._ipAddress = Y_IPADDRESS_INVALID;
        /** @member {string} **/
        this._subnetMask = Y_SUBNETMASK_INVALID;
        /** @member {string} **/
        this._router = Y_ROUTER_INVALID;
        /** @member {string} **/
        this._ipConfig = Y_IPCONFIG_INVALID;
        /** @member {string} **/
        this._primaryDNS = Y_PRIMARYDNS_INVALID;
        /** @member {string} **/
        this._secondaryDNS = Y_SECONDARYDNS_INVALID;
        /** @member {string} **/
        this._ntpServer = Y_NTPSERVER_INVALID;
        /** @member {string} **/
        this._userPassword = Y_USERPASSWORD_INVALID;
        /** @member {string} **/
        this._adminPassword = Y_ADMINPASSWORD_INVALID;
        /** @member {number} **/
        this._httpPort = Y_HTTPPORT_INVALID;
        /** @member {string} **/
        this._defaultPage = Y_DEFAULTPAGE_INVALID;
        /** @member {number} **/
        this._discoverable = Y_DISCOVERABLE_INVALID;
        /** @member {number} **/
        this._wwwWatchdogDelay = Y_WWWWATCHDOGDELAY_INVALID;
        /** @member {string} **/
        this._callbackUrl = Y_CALLBACKURL_INVALID;
        /** @member {number} **/
        this._callbackMethod = Y_CALLBACKMETHOD_INVALID;
        /** @member {number} **/
        this._callbackEncoding = Y_CALLBACKENCODING_INVALID;
        /** @member {string} **/
        this._callbackCredentials = Y_CALLBACKCREDENTIALS_INVALID;
        /** @member {number} **/
        this._callbackMinDelay = Y_CALLBACKMINDELAY_INVALID;
        /** @member {number} **/
        this._callbackMaxDelay = Y_CALLBACKMAXDELAY_INVALID;
        /** @member {number} **/
        this._poeCurrent = Y_POECURRENT_INVALID;
        this.imm_setConst({
            READINESS_DOWN: 0,
            READINESS_EXISTS: 1,
            READINESS_LINKED: 2,
            READINESS_LAN_OK: 3,
            READINESS_WWW_OK: 4,
            READINESS_INVALID: -1,
            MACADDRESS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            IPADDRESS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SUBNETMASK_INVALID: _yocto_api.YAPI.INVALID_STRING,
            ROUTER_INVALID: _yocto_api.YAPI.INVALID_STRING,
            IPCONFIG_INVALID: _yocto_api.YAPI.INVALID_STRING,
            PRIMARYDNS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            SECONDARYDNS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            NTPSERVER_INVALID: _yocto_api.YAPI.INVALID_STRING,
            USERPASSWORD_INVALID: _yocto_api.YAPI.INVALID_STRING,
            ADMINPASSWORD_INVALID: _yocto_api.YAPI.INVALID_STRING,
            HTTPPORT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            DEFAULTPAGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            DISCOVERABLE_FALSE: 0,
            DISCOVERABLE_TRUE: 1,
            DISCOVERABLE_INVALID: -1,
            WWWWATCHDOGDELAY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            CALLBACKURL_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CALLBACKMETHOD_POST: 0,
            CALLBACKMETHOD_GET: 1,
            CALLBACKMETHOD_PUT: 2,
            CALLBACKMETHOD_INVALID: -1,
            CALLBACKENCODING_FORM: 0,
            CALLBACKENCODING_JSON: 1,
            CALLBACKENCODING_JSON_ARRAY: 2,
            CALLBACKENCODING_CSV: 3,
            CALLBACKENCODING_YOCTO_API: 4,
            CALLBACKENCODING_JSON_NUM: 5,
            CALLBACKENCODING_EMONCMS: 6,
            CALLBACKENCODING_AZURE: 7,
            CALLBACKENCODING_INFLUXDB: 8,
            CALLBACKENCODING_INVALID: -1,
            CALLBACKCREDENTIALS_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CALLBACKMINDELAY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            CALLBACKMAXDELAY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            POECURRENT_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of YNetwork constructor)
    }

    //--- (YNetwork implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'readiness':
                this._readiness = parseInt(val);
                return 1;
            case 'macAddress':
                this._macAddress = val;
                return 1;
            case 'ipAddress':
                this._ipAddress = val;
                return 1;
            case 'subnetMask':
                this._subnetMask = val;
                return 1;
            case 'router':
                this._router = val;
                return 1;
            case 'ipConfig':
                this._ipConfig = val;
                return 1;
            case 'primaryDNS':
                this._primaryDNS = val;
                return 1;
            case 'secondaryDNS':
                this._secondaryDNS = val;
                return 1;
            case 'ntpServer':
                this._ntpServer = val;
                return 1;
            case 'userPassword':
                this._userPassword = val;
                return 1;
            case 'adminPassword':
                this._adminPassword = val;
                return 1;
            case 'httpPort':
                this._httpPort = parseInt(val);
                return 1;
            case 'defaultPage':
                this._defaultPage = val;
                return 1;
            case 'discoverable':
                this._discoverable = parseInt(val);
                return 1;
            case 'wwwWatchdogDelay':
                this._wwwWatchdogDelay = parseInt(val);
                return 1;
            case 'callbackUrl':
                this._callbackUrl = val;
                return 1;
            case 'callbackMethod':
                this._callbackMethod = parseInt(val);
                return 1;
            case 'callbackEncoding':
                this._callbackEncoding = parseInt(val);
                return 1;
            case 'callbackCredentials':
                this._callbackCredentials = val;
                return 1;
            case 'callbackMinDelay':
                this._callbackMinDelay = parseInt(val);
                return 1;
            case 'callbackMaxDelay':
                this._callbackMaxDelay = parseInt(val);
                return 1;
            case 'poeCurrent':
                this._poeCurrent = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current established working mode of the network interface.
     * Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal
     * on the network cable, or the selected wireless access point cannot be detected.
     * Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected.
     * For a wireless network, this shows that the requested SSID is present.
     * Level 2 (LINK_2) is reached when the hardware connection is established.
     * For a wired network connection, level 2 means that the cable is attached at both ends.
     * For a connection to a wireless access point, it shows that the security parameters
     * are properly configured. For an ad-hoc wireless connection, it means that there is
     * at least one other device connected on the ad-hoc network.
     * Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP.
     * Level 4 (DNS_4) is reached when the DNS server is reachable on the network.
     * Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the
     * current time from an NTP server.
     *
     * @return {number} a value among YNetwork.READINESS_DOWN, YNetwork.READINESS_EXISTS,
     * YNetwork.READINESS_LINKED, YNetwork.READINESS_LAN_OK and YNetwork.READINESS_WWW_OK corresponding to
     * the current established working mode of the network interface
     *
     * On failure, throws an exception or returns YNetwork.READINESS_INVALID.
     */
    get_readiness() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_READINESS_INVALID;
                }
            }
            return _this._readiness;
        })();
    }

    /**
     * Returns the MAC address of the network interface. The MAC address is also available on a sticker
     * on the module, in both numeric and barcode forms.
     *
     * @return {string} a string corresponding to the MAC address of the network interface
     *
     * On failure, throws an exception or returns YNetwork.MACADDRESS_INVALID.
     */
    get_macAddress() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration == 0) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MACADDRESS_INVALID;
                }
            }
            return _this2._macAddress;
        })();
    }

    /**
     * Returns the IP address currently in use by the device. The address may have been configured
     * statically, or provided by a DHCP server.
     *
     * @return {string} a string corresponding to the IP address currently in use by the device
     *
     * On failure, throws an exception or returns YNetwork.IPADDRESS_INVALID.
     */
    get_ipAddress() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_IPADDRESS_INVALID;
                }
            }
            return _this3._ipAddress;
        })();
    }

    /**
     * Returns the subnet mask currently used by the device.
     *
     * @return {string} a string corresponding to the subnet mask currently used by the device
     *
     * On failure, throws an exception or returns YNetwork.SUBNETMASK_INVALID.
     */
    get_subnetMask() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SUBNETMASK_INVALID;
                }
            }
            return _this4._subnetMask;
        })();
    }

    /**
     * Returns the IP address of the router on the device subnet (default gateway).
     *
     * @return {string} a string corresponding to the IP address of the router on the device subnet (default gateway)
     *
     * On failure, throws an exception or returns YNetwork.ROUTER_INVALID.
     */
    get_router() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ROUTER_INVALID;
                }
            }
            return _this5._router;
        })();
    }

    get_ipConfig() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_IPCONFIG_INVALID;
                }
            }
            return _this6._ipConfig;
        })();
    }

    set_ipConfig(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this7._setAttr('ipConfig', rest_val);
        })();
    }

    /**
     * Returns the IP address of the primary name server to be used by the module.
     *
     * @return {string} a string corresponding to the IP address of the primary name server to be used by the module
     *
     * On failure, throws an exception or returns YNetwork.PRIMARYDNS_INVALID.
     */
    get_primaryDNS() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PRIMARYDNS_INVALID;
                }
            }
            return _this8._primaryDNS;
        })();
    }

    /**
     * Changes the IP address of the primary name server to be used by the module.
     * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param newval {string} : a string corresponding to the IP address of the primary name server to be
     * used by the module
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_primaryDNS(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this9._setAttr('primaryDNS', rest_val);
        })();
    }

    /**
     * Returns the IP address of the secondary name server to be used by the module.
     *
     * @return {string} a string corresponding to the IP address of the secondary name server to be used by the module
     *
     * On failure, throws an exception or returns YNetwork.SECONDARYDNS_INVALID.
     */
    get_secondaryDNS() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SECONDARYDNS_INVALID;
                }
            }
            return _this10._secondaryDNS;
        })();
    }

    /**
     * Changes the IP address of the secondary name server to be used by the module.
     * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param newval {string} : a string corresponding to the IP address of the secondary name server to
     * be used by the module
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_secondaryDNS(newval) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this11._setAttr('secondaryDNS', rest_val);
        })();
    }

    /**
     * Returns the IP address of the NTP server to be used by the device.
     *
     * @return {string} a string corresponding to the IP address of the NTP server to be used by the device
     *
     * On failure, throws an exception or returns YNetwork.NTPSERVER_INVALID.
     */
    get_ntpServer() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NTPSERVER_INVALID;
                }
            }
            return _this12._ntpServer;
        })();
    }

    /**
     * Changes the IP address of the NTP server to be used by the module.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param newval {string} : a string corresponding to the IP address of the NTP server to be used by the module
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_ntpServer(newval) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this13._setAttr('ntpServer', rest_val);
        })();
    }

    /**
     * Returns a hash string if a password has been set for "user" user,
     * or an empty string otherwise.
     *
     * @return {string} a string corresponding to a hash string if a password has been set for "user" user,
     *         or an empty string otherwise
     *
     * On failure, throws an exception or returns YNetwork.USERPASSWORD_INVALID.
     */
    get_userPassword() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_USERPASSWORD_INVALID;
                }
            }
            return _this14._userPassword;
        })();
    }

    /**
     * Changes the password for the "user" user. This password becomes instantly required
     * to perform any use of the module. If the specified value is an
     * empty string, a password is not required anymore.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the password for the "user" user
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_userPassword(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this15._setAttr('userPassword', rest_val);
        })();
    }

    /**
     * Returns a hash string if a password has been set for user "admin",
     * or an empty string otherwise.
     *
     * @return {string} a string corresponding to a hash string if a password has been set for user "admin",
     *         or an empty string otherwise
     *
     * On failure, throws an exception or returns YNetwork.ADMINPASSWORD_INVALID.
     */
    get_adminPassword() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._cacheExpiration <= _this16._yapi.GetTickCount()) {
                if ((yield _this16.load(_this16._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ADMINPASSWORD_INVALID;
                }
            }
            return _this16._adminPassword;
        })();
    }

    /**
     * Changes the password for the "admin" user. This password becomes instantly required
     * to perform any change of the module state. If the specified value is an
     * empty string, a password is not required anymore.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the password for the "admin" user
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_adminPassword(newval) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this17._setAttr('adminPassword', rest_val);
        })();
    }

    /**
     * Returns the HTML page to serve for the URL "/"" of the hub.
     *
     * @return {number} an integer corresponding to the HTML page to serve for the URL "/"" of the hub
     *
     * On failure, throws an exception or returns YNetwork.HTTPPORT_INVALID.
     */
    get_httpPort() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            if (_this18._cacheExpiration <= _this18._yapi.GetTickCount()) {
                if ((yield _this18.load(_this18._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_HTTPPORT_INVALID;
                }
            }
            return _this18._httpPort;
        })();
    }

    /**
     * Changes the default HTML page returned by the hub. If not value are set the hub return
     * "index.html" which is the web interface of the hub. It is possible de change this page
     * for file that has been uploaded on the hub.
     *
     * @param newval {number} : an integer corresponding to the default HTML page returned by the hub
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_httpPort(newval) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this19._setAttr('httpPort', rest_val);
        })();
    }

    /**
     * Returns the HTML page to serve for the URL "/"" of the hub.
     *
     * @return {string} a string corresponding to the HTML page to serve for the URL "/"" of the hub
     *
     * On failure, throws an exception or returns YNetwork.DEFAULTPAGE_INVALID.
     */
    get_defaultPage() {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            if (_this20._cacheExpiration <= _this20._yapi.GetTickCount()) {
                if ((yield _this20.load(_this20._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DEFAULTPAGE_INVALID;
                }
            }
            return _this20._defaultPage;
        })();
    }

    /**
     * Changes the default HTML page returned by the hub. If not value are set the hub return
     * "index.html" which is the web interface of the hub. It is possible de change this page
     * for file that has been uploaded on the hub.
     *
     * @param newval {string} : a string corresponding to the default HTML page returned by the hub
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_defaultPage(newval) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this21._setAttr('defaultPage', rest_val);
        })();
    }

    /**
     * Returns the activation state of the multicast announce protocols to allow easy
     * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
     *
     * @return {number} either YNetwork.DISCOVERABLE_FALSE or YNetwork.DISCOVERABLE_TRUE, according to the
     * activation state of the multicast announce protocols to allow easy
     *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
     *
     * On failure, throws an exception or returns YNetwork.DISCOVERABLE_INVALID.
     */
    get_discoverable() {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            if (_this22._cacheExpiration <= _this22._yapi.GetTickCount()) {
                if ((yield _this22.load(_this22._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISCOVERABLE_INVALID;
                }
            }
            return _this22._discoverable;
        })();
    }

    /**
     * Changes the activation state of the multicast announce protocols to allow easy
     * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
     *
     * @param newval {number} : either YNetwork.DISCOVERABLE_FALSE or YNetwork.DISCOVERABLE_TRUE,
     * according to the activation state of the multicast announce protocols to allow easy
     *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_discoverable(newval) {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this23._setAttr('discoverable', rest_val);
        })();
    }

    /**
     * Returns the allowed downtime of the WWW link (in seconds) before triggering an automated
     * reboot to try to recover Internet connectivity. A zero value disables automated reboot
     * in case of Internet connectivity loss.
     *
     * @return {number} an integer corresponding to the allowed downtime of the WWW link (in seconds)
     * before triggering an automated
     *         reboot to try to recover Internet connectivity
     *
     * On failure, throws an exception or returns YNetwork.WWWWATCHDOGDELAY_INVALID.
     */
    get_wwwWatchdogDelay() {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            if (_this24._cacheExpiration <= _this24._yapi.GetTickCount()) {
                if ((yield _this24.load(_this24._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_WWWWATCHDOGDELAY_INVALID;
                }
            }
            return _this24._wwwWatchdogDelay;
        })();
    }

    /**
     * Changes the allowed downtime of the WWW link (in seconds) before triggering an automated
     * reboot to try to recover Internet connectivity. A zero value disables automated reboot
     * in case of Internet connectivity loss. The smallest valid non-zero timeout is
     * 90 seconds.
     *
     * @param newval {number} : an integer corresponding to the allowed downtime of the WWW link (in
     * seconds) before triggering an automated
     *         reboot to try to recover Internet connectivity
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_wwwWatchdogDelay(newval) {
        var _this25 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this25._setAttr('wwwWatchdogDelay', rest_val);
        })();
    }

    /**
     * Returns the callback URL to notify of significant state changes.
     *
     * @return {string} a string corresponding to the callback URL to notify of significant state changes
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKURL_INVALID.
     */
    get_callbackUrl() {
        var _this26 = this;

        return _asyncToGenerator(function* () {
            if (_this26._cacheExpiration <= _this26._yapi.GetTickCount()) {
                if ((yield _this26.load(_this26._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKURL_INVALID;
                }
            }
            return _this26._callbackUrl;
        })();
    }

    /**
     * Changes the callback URL to notify significant state changes. Remember to call the
     * saveToFlash() method of the module if the modification must be kept.
     *
     * @param newval {string} : a string corresponding to the callback URL to notify significant state changes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackUrl(newval) {
        var _this27 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this27._setAttr('callbackUrl', rest_val);
        })();
    }

    /**
     * Returns the HTTP method used to notify callbacks for significant state changes.
     *
     * @return {number} a value among YNetwork.CALLBACKMETHOD_POST, YNetwork.CALLBACKMETHOD_GET and
     * YNetwork.CALLBACKMETHOD_PUT corresponding to the HTTP method used to notify callbacks for
     * significant state changes
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKMETHOD_INVALID.
     */
    get_callbackMethod() {
        var _this28 = this;

        return _asyncToGenerator(function* () {
            if (_this28._cacheExpiration <= _this28._yapi.GetTickCount()) {
                if ((yield _this28.load(_this28._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKMETHOD_INVALID;
                }
            }
            return _this28._callbackMethod;
        })();
    }

    /**
     * Changes the HTTP method used to notify callbacks for significant state changes.
     *
     * @param newval {number} : a value among YNetwork.CALLBACKMETHOD_POST, YNetwork.CALLBACKMETHOD_GET
     * and YNetwork.CALLBACKMETHOD_PUT corresponding to the HTTP method used to notify callbacks for
     * significant state changes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackMethod(newval) {
        var _this29 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this29._setAttr('callbackMethod', rest_val);
        })();
    }

    /**
     * Returns the encoding standard to use for representing notification values.
     *
     * @return {number} a value among YNetwork.CALLBACKENCODING_FORM, YNetwork.CALLBACKENCODING_JSON,
     * YNetwork.CALLBACKENCODING_JSON_ARRAY, YNetwork.CALLBACKENCODING_CSV,
     * YNetwork.CALLBACKENCODING_YOCTO_API, YNetwork.CALLBACKENCODING_JSON_NUM,
     * YNetwork.CALLBACKENCODING_EMONCMS, YNetwork.CALLBACKENCODING_AZURE and
     * YNetwork.CALLBACKENCODING_INFLUXDB corresponding to the encoding standard to use for representing
     * notification values
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKENCODING_INVALID.
     */
    get_callbackEncoding() {
        var _this30 = this;

        return _asyncToGenerator(function* () {
            if (_this30._cacheExpiration <= _this30._yapi.GetTickCount()) {
                if ((yield _this30.load(_this30._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKENCODING_INVALID;
                }
            }
            return _this30._callbackEncoding;
        })();
    }

    /**
     * Changes the encoding standard to use for representing notification values.
     *
     * @param newval {number} : a value among YNetwork.CALLBACKENCODING_FORM,
     * YNetwork.CALLBACKENCODING_JSON, YNetwork.CALLBACKENCODING_JSON_ARRAY,
     * YNetwork.CALLBACKENCODING_CSV, YNetwork.CALLBACKENCODING_YOCTO_API,
     * YNetwork.CALLBACKENCODING_JSON_NUM, YNetwork.CALLBACKENCODING_EMONCMS,
     * YNetwork.CALLBACKENCODING_AZURE and YNetwork.CALLBACKENCODING_INFLUXDB corresponding to the
     * encoding standard to use for representing notification values
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackEncoding(newval) {
        var _this31 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this31._setAttr('callbackEncoding', rest_val);
        })();
    }

    /**
     * Returns a hashed version of the notification callback credentials if set,
     * or an empty string otherwise.
     *
     * @return {string} a string corresponding to a hashed version of the notification callback credentials if set,
     *         or an empty string otherwise
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKCREDENTIALS_INVALID.
     */
    get_callbackCredentials() {
        var _this32 = this;

        return _asyncToGenerator(function* () {
            if (_this32._cacheExpiration <= _this32._yapi.GetTickCount()) {
                if ((yield _this32.load(_this32._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKCREDENTIALS_INVALID;
                }
            }
            return _this32._callbackCredentials;
        })();
    }

    /**
     * Changes the credentials required to connect to the callback address. The credentials
     * must be provided as returned by function get_callbackCredentials,
     * in the form username:hash. The method used to compute the hash varies according
     * to the the authentication scheme implemented by the callback, For Basic authentication,
     * the hash is the MD5 of the string username:password. For Digest authentication,
     * the hash is the MD5 of the string username:realm:password. For a simpler
     * way to configure callback credentials, use function callbackLogin instead.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the credentials required to connect to the callback address
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackCredentials(newval) {
        var _this33 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this33._setAttr('callbackCredentials', rest_val);
        })();
    }

    /**
     * Connects to the notification callback and saves the credentials required to
     * log into it. The password is not stored into the module, only a hashed
     * copy of the credentials are saved. Remember to call the
     * saveToFlash() method of the module if the modification must be kept.
     *
     * @param username {string} : username required to log to the callback
     * @param password {string} : password required to log to the callback
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    callbackLogin(username, password) {
        var _this34 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = username + ':' + password;
            return yield _this34._setAttr('callbackCredentials', rest_val);
        })();
    }

    /**
     * Returns the minimum waiting time between two callback notifications, in seconds.
     *
     * @return {number} an integer corresponding to the minimum waiting time between two callback
     * notifications, in seconds
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKMINDELAY_INVALID.
     */
    get_callbackMinDelay() {
        var _this35 = this;

        return _asyncToGenerator(function* () {
            if (_this35._cacheExpiration <= _this35._yapi.GetTickCount()) {
                if ((yield _this35.load(_this35._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKMINDELAY_INVALID;
                }
            }
            return _this35._callbackMinDelay;
        })();
    }

    /**
     * Changes the minimum waiting time between two callback notifications, in seconds.
     *
     * @param newval {number} : an integer corresponding to the minimum waiting time between two callback
     * notifications, in seconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackMinDelay(newval) {
        var _this36 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this36._setAttr('callbackMinDelay', rest_val);
        })();
    }

    /**
     * Returns the maximum waiting time between two callback notifications, in seconds.
     *
     * @return {number} an integer corresponding to the maximum waiting time between two callback
     * notifications, in seconds
     *
     * On failure, throws an exception or returns YNetwork.CALLBACKMAXDELAY_INVALID.
     */
    get_callbackMaxDelay() {
        var _this37 = this;

        return _asyncToGenerator(function* () {
            if (_this37._cacheExpiration <= _this37._yapi.GetTickCount()) {
                if ((yield _this37.load(_this37._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALLBACKMAXDELAY_INVALID;
                }
            }
            return _this37._callbackMaxDelay;
        })();
    }

    /**
     * Changes the maximum waiting time between two callback notifications, in seconds.
     *
     * @param newval {number} : an integer corresponding to the maximum waiting time between two callback
     * notifications, in seconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_callbackMaxDelay(newval) {
        var _this38 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this38._setAttr('callbackMaxDelay', rest_val);
        })();
    }

    /**
     * Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.
     * The current consumption is measured after converting PoE source to 5 Volt, and should
     * never exceed 1800 mA.
     *
     * @return {number} an integer corresponding to the current consumed by the module from
     * Power-over-Ethernet (PoE), in milli-amps
     *
     * On failure, throws an exception or returns YNetwork.POECURRENT_INVALID.
     */
    get_poeCurrent() {
        var _this39 = this;

        return _asyncToGenerator(function* () {
            if (_this39._cacheExpiration <= _this39._yapi.GetTickCount()) {
                if ((yield _this39.load(_this39._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POECURRENT_INVALID;
                }
            }
            return _this39._poeCurrent;
        })();
    }

    /**
     * Retrieves a network interface for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the network interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YNetwork.isOnline() to test if the network interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a network interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the network interface
     *
     * @return {YNetwork} a YNetwork object allowing you to drive the network interface.
     */
    static FindNetwork(func) {
        /** @type {YNetwork} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Network', func);
        if (obj == null) {
            obj = new YNetwork(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Network', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a network interface for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the network interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YNetwork.isOnline() to test if the network interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a network interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the network interface
     *
     * @return {YNetwork} a YNetwork object allowing you to drive the network interface.
     */
    static FindNetworkInContext(yctx, func) {
        /** @type {YNetwork} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Network', func);
        if (obj == null) {
            obj = new YNetwork(yctx, func);
            _yocto_api.YFunction._AddToCache('Network', func, obj);
        }
        return obj;
    }

    /**
     * Changes the configuration of the network interface to enable the use of an
     * IP address received from a DHCP server. Until an address is received from a DHCP
     * server, the module uses the IP parameters specified to this function.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param fallbackIpAddr {string} : fallback IP address, to be used when no DHCP reply is received
     * @param fallbackSubnetMaskLen {number} : fallback subnet mask length when no DHCP reply is received, as an
     *         integer (eg. 24 means 255.255.255.0)
     * @param fallbackRouter {string} : fallback router IP address, to be used when no DHCP reply is received
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
        var _this40 = this;

        return _asyncToGenerator(function* () {
            return yield _this40.set_ipConfig('DHCP:' + fallbackIpAddr + '/' + String(Math.round(fallbackSubnetMaskLen)) + '/' + fallbackRouter);
        })();
    }

    /**
     * Changes the configuration of the network interface to use a static IP address.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param ipAddress {string} : device IP address
     * @param subnetMaskLen {number} : subnet mask length, as an integer (eg. 24 means 255.255.255.0)
     * @param router {string} : router IP address (default gateway)
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    useStaticIP(ipAddress, subnetMaskLen, router) {
        var _this41 = this;

        return _asyncToGenerator(function* () {
            return yield _this41.set_ipConfig('STATIC:' + ipAddress + '/' + String(Math.round(subnetMaskLen)) + '/' + router);
        })();
    }

    /**
     * Pings str_host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the
     * module to the target str_host. This method returns a string with the result of the
     * 4 ICMP ECHO_REQUEST requests.
     *
     * @param host {string} : the hostname or the IP address of the target
     *
     * @return {string} a string with the result of the ping.
     */
    ping(host) {
        var _this42 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let content;
            // may throw an exception
            content = yield _this42._download('ping.txt?host=' + host);
            return _this42._yapi.imm_bin2str(content);
        })();
    }

    /**
     * Continues the enumeration of network interfaces started using yFirstNetwork().
     *
     * @return {YNetwork} a pointer to a YNetwork object, corresponding to
     *         a network interface currently online, or a null pointer
     *         if there are no more network interfaces to enumerate.
     */
    /* */nextNetwork() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of network interfaces currently accessible.
     * Use the method YNetwork.nextNetwork() to iterate on
     * next network interfaces.
     *
     * @return {YNetwork} a pointer to a YNetwork object, corresponding to
     *         the first network interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstNetwork() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Network');
        if (next_hwid == null) return null;
        return YNetwork.FindNetwork(next_hwid);
    }

    /**
     * Starts the enumeration of network interfaces currently accessible.
     * Use the method YNetwork.nextNetwork() to iterate on
     * next network interfaces.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YNetwork} a pointer to a YNetwork object, corresponding to
     *         the first network interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstNetworkInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Network');
        if (next_hwid == null) return null;
        return YNetwork.FindNetworkInContext(yctx, next_hwid);
    }

    //--- (end of YNetwork implementation)
}

exports.YNetwork = YNetwork; //--- (Network functions)

/**
 * comment from .yc definition
 */

function yFindNetwork(func) {
    return YNetwork.FindNetwork(func);
}

/**
 * comment from .yc definition
 */
function yFirstNetwork() {
    return YNetwork.FirstNetwork();
}

//--- (end of Network functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for OsControl functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YOsControl = exports.Y_SHUTDOWNCOUNTDOWN_INVALID = undefined;
exports.yFindOsControl = yFindOsControl;
exports.yFirstOsControl = yFirstOsControl;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YOsControl return codes)
//--- (end of YOsControl return codes)
//--- (YOsControl definitions)
const Y_SHUTDOWNCOUNTDOWN_INVALID = exports.Y_SHUTDOWNCOUNTDOWN_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YOsControl definitions)

//--- (YOsControl class start)
/**
 * YOsControl Class: OS control
 *
 * The OScontrol object allows some control over the operating system running a VirtualHub.
 * OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub
 * start up with -o option.
 */
//--- (end of YOsControl class start)

class YOsControl extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YOsControl constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'OsControl';
        /** @member {number} **/
        this._shutdownCountdown = Y_SHUTDOWNCOUNTDOWN_INVALID;
        this.imm_setConst({
            SHUTDOWNCOUNTDOWN_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of YOsControl constructor)
    }

    //--- (YOsControl implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'shutdownCountdown':
                this._shutdownCountdown = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the remaining number of seconds before the OS shutdown, or zero when no
     * shutdown has been scheduled.
     *
     * @return {number} an integer corresponding to the remaining number of seconds before the OS
     * shutdown, or zero when no
     *         shutdown has been scheduled
     *
     * On failure, throws an exception or returns YOsControl.SHUTDOWNCOUNTDOWN_INVALID.
     */
    get_shutdownCountdown() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SHUTDOWNCOUNTDOWN_INVALID;
                }
            }
            return _this._shutdownCountdown;
        })();
    }

    set_shutdownCountdown(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('shutdownCountdown', rest_val);
        })();
    }

    /**
     * Retrieves OS control for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the OS control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YOsControl.isOnline() to test if the OS control is
     * indeed online at a given time. In case of ambiguity when looking for
     * OS control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the OS control
     *
     * @return {YOsControl} a YOsControl object allowing you to drive the OS control.
     */
    static FindOsControl(func) {
        /** @type {YOsControl} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('OsControl', func);
        if (obj == null) {
            obj = new YOsControl(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('OsControl', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves OS control for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the OS control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YOsControl.isOnline() to test if the OS control is
     * indeed online at a given time. In case of ambiguity when looking for
     * OS control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the OS control
     *
     * @return {YOsControl} a YOsControl object allowing you to drive the OS control.
     */
    static FindOsControlInContext(yctx, func) {
        /** @type {YOsControl} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'OsControl', func);
        if (obj == null) {
            obj = new YOsControl(yctx, func);
            _yocto_api.YFunction._AddToCache('OsControl', func, obj);
        }
        return obj;
    }

    /**
     * Schedules an OS shutdown after a given number of seconds.
     *
     * @param secBeforeShutDown {number} : number of seconds before shutdown
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    shutdown(secBeforeShutDown) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            return yield _this3.set_shutdownCountdown(secBeforeShutDown);
        })();
    }

    /**
     * Continues the enumeration of OS control started using yFirstOsControl().
     *
     * @return {YOsControl} a pointer to a YOsControl object, corresponding to
     *         OS control currently online, or a null pointer
     *         if there are no more OS control to enumerate.
     */
    /* */nextOsControl() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YOsControl.FindOsControlInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of OS control currently accessible.
     * Use the method YOsControl.nextOsControl() to iterate on
     * next OS control.
     *
     * @return {YOsControl} a pointer to a YOsControl object, corresponding to
     *         the first OS control currently online, or a null pointer
     *         if there are none.
     */
    static FirstOsControl() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('OsControl');
        if (next_hwid == null) return null;
        return YOsControl.FindOsControl(next_hwid);
    }

    /**
     * Starts the enumeration of OS control currently accessible.
     * Use the method YOsControl.nextOsControl() to iterate on
     * next OS control.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YOsControl} a pointer to a YOsControl object, corresponding to
     *         the first OS control currently online, or a null pointer
     *         if there are none.
     */
    static FirstOsControlInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('OsControl');
        if (next_hwid == null) return null;
        return YOsControl.FindOsControlInContext(yctx, next_hwid);
    }

    //--- (end of YOsControl implementation)
}

exports.YOsControl = YOsControl; //--- (OsControl functions)

/**
 * comment from .yc definition
 */

function yFindOsControl(func) {
    return YOsControl.FindOsControl(func);
}

/**
 * comment from .yc definition
 */
function yFirstOsControl() {
    return YOsControl.FirstOsControl();
}

//--- (end of OsControl functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Power functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPower = exports.Y_METERTIMER_INVALID = exports.Y_METER_INVALID = exports.Y_COSPHI_INVALID = undefined;
exports.yFindPower = yFindPower;
exports.yFirstPower = yFirstPower;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YPower return codes)
//--- (end of YPower return codes)
//--- (YPower definitions)
const Y_COSPHI_INVALID = exports.Y_COSPHI_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_METER_INVALID = exports.Y_METER_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_METERTIMER_INVALID = exports.Y_METERTIMER_INVALID = _yocto_api.YAPI.INVALID_UINT;
//--- (end of YPower definitions)

//--- (YPower class start)
/**
 * YPower Class: Power function interface
 *
 * The Yoctopuce class YPower allows you to read and configure Yoctopuce power
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to access the energy counter and the power factor.
 */
//--- (end of YPower class start)

class YPower extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YPower constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Power';
        /** @member {number} **/
        this._cosPhi = Y_COSPHI_INVALID;
        /** @member {number} **/
        this._meter = Y_METER_INVALID;
        /** @member {number} **/
        this._meterTimer = Y_METERTIMER_INVALID;
        this.imm_setConst({
            COSPHI_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            METER_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            METERTIMER_INVALID: _yocto_api.YAPI.INVALID_UINT
        });
        //--- (end of YPower constructor)
    }

    //--- (YPower implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'cosPhi':
                this._cosPhi = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'meter':
                this._meter = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'meterTimer':
                this._meterTimer = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the power factor (the ratio between the real power consumed,
     * measured in W, and the apparent power provided, measured in VA).
     *
     * @return {number} a floating point number corresponding to the power factor (the ratio between the
     * real power consumed,
     *         measured in W, and the apparent power provided, measured in VA)
     *
     * On failure, throws an exception or returns YPower.COSPHI_INVALID.
     */
    get_cosPhi() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COSPHI_INVALID;
                }
            }
            return _this._cosPhi;
        })();
    }

    set_meter(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this2._setAttr('meter', rest_val);
        })();
    }

    /**
     * Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.
     * Note that this counter is reset at each start of the device.
     *
     * @return {number} a floating point number corresponding to the energy counter, maintained by the
     * wattmeter by integrating the power consumption over time
     *
     * On failure, throws an exception or returns YPower.METER_INVALID.
     */
    get_meter() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_METER_INVALID;
                }
            }
            return _this3._meter;
        })();
    }

    /**
     * Returns the elapsed time since last energy counter reset, in seconds.
     *
     * @return {number} an integer corresponding to the elapsed time since last energy counter reset, in seconds
     *
     * On failure, throws an exception or returns YPower.METERTIMER_INVALID.
     */
    get_meterTimer() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_METERTIMER_INVALID;
                }
            }
            return _this4._meterTimer;
        })();
    }

    /**
     * Retrieves a electrical power sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the electrical power sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPower.isOnline() to test if the electrical power sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a electrical power sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the electrical power sensor
     *
     * @return {YPower} a YPower object allowing you to drive the electrical power sensor.
     */
    static FindPower(func) {
        /** @type {YPower} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Power', func);
        if (obj == null) {
            obj = new YPower(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Power', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a electrical power sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the electrical power sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPower.isOnline() to test if the electrical power sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a electrical power sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the electrical power sensor
     *
     * @return {YPower} a YPower object allowing you to drive the electrical power sensor.
     */
    static FindPowerInContext(yctx, func) {
        /** @type {YPower} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Power', func);
        if (obj == null) {
            obj = new YPower(yctx, func);
            _yocto_api.YFunction._AddToCache('Power', func, obj);
        }
        return obj;
    }

    /**
     * Resets the energy counter.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    reset() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            return yield _this5.set_meter(0);
        })();
    }

    /**
     * Continues the enumeration of electrical power sensors started using yFirstPower().
     *
     * @return {YPower} a pointer to a YPower object, corresponding to
     *         a electrical power sensor currently online, or a null pointer
     *         if there are no more electrical power sensors to enumerate.
     */
    /* */nextPower() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPower.FindPowerInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of electrical power sensors currently accessible.
     * Use the method YPower.nextPower() to iterate on
     * next electrical power sensors.
     *
     * @return {YPower} a pointer to a YPower object, corresponding to
     *         the first electrical power sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstPower() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Power');
        if (next_hwid == null) return null;
        return YPower.FindPower(next_hwid);
    }

    /**
     * Starts the enumeration of electrical power sensors currently accessible.
     * Use the method YPower.nextPower() to iterate on
     * next electrical power sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPower} a pointer to a YPower object, corresponding to
     *         the first electrical power sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstPowerInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Power');
        if (next_hwid == null) return null;
        return YPower.FindPowerInContext(yctx, next_hwid);
    }

    //--- (end of YPower implementation)
}

exports.YPower = YPower; //--- (Power functions)

/**
 * comment from .yc definition
 */

function yFindPower(func) {
    return YPower.FindPower(func);
}

/**
 * comment from .yc definition
 */
function yFirstPower() {
    return YPower.FirstPower();
}

//--- (end of Power functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for PowerOutput functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPowerOutput = exports.Y_VOLTAGE_INVALID = exports.Y_VOLTAGE_OUT5V = exports.Y_VOLTAGE_OUT3V3 = exports.Y_VOLTAGE_OFF = undefined;
exports.yFindPowerOutput = yFindPowerOutput;
exports.yFirstPowerOutput = yFirstPowerOutput;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YPowerOutput return codes)
//--- (end of YPowerOutput return codes)
//--- (YPowerOutput definitions)
const Y_VOLTAGE_OFF = exports.Y_VOLTAGE_OFF = 0;
const Y_VOLTAGE_OUT3V3 = exports.Y_VOLTAGE_OUT3V3 = 1;
const Y_VOLTAGE_OUT5V = exports.Y_VOLTAGE_OUT5V = 2;
const Y_VOLTAGE_INVALID = exports.Y_VOLTAGE_INVALID = -1;
//--- (end of YPowerOutput definitions)

//--- (YPowerOutput class start)
/**
 * YPowerOutput Class: External power supply control interface
 *
 * Yoctopuce application programming interface allows you to control
 * the power ouput featured on some devices such as the Yocto-Serial.
 */
//--- (end of YPowerOutput class start)

class YPowerOutput extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YPowerOutput constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'PowerOutput';
        /** @member {number} **/
        this._voltage = Y_VOLTAGE_INVALID;
        this.imm_setConst({
            VOLTAGE_OFF: 0,
            VOLTAGE_OUT3V3: 1,
            VOLTAGE_OUT5V: 2,
            VOLTAGE_INVALID: -1
        });
        //--- (end of YPowerOutput constructor)
    }

    //--- (YPowerOutput implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'voltage':
                this._voltage = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the voltage on the power ouput featured by
     * the module.
     *
     * @return {number} a value among YPowerOutput.VOLTAGE_OFF, YPowerOutput.VOLTAGE_OUT3V3 and
     * YPowerOutput.VOLTAGE_OUT5V corresponding to the voltage on the power ouput featured by
     *         the module
     *
     * On failure, throws an exception or returns YPowerOutput.VOLTAGE_INVALID.
     */
    get_voltage() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLTAGE_INVALID;
                }
            }
            return _this._voltage;
        })();
    }

    /**
     * Changes the voltage on the power output provided by the
     * module. Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : a value among YPowerOutput.VOLTAGE_OFF, YPowerOutput.VOLTAGE_OUT3V3 and
     * YPowerOutput.VOLTAGE_OUT5V corresponding to the voltage on the power output provided by the
     *         module
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_voltage(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('voltage', rest_val);
        })();
    }

    /**
     * Retrieves a dual power  ouput control for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the power ouput control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPowerOutput.isOnline() to test if the power ouput control is
     * indeed online at a given time. In case of ambiguity when looking for
     * a dual power  ouput control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the power ouput control
     *
     * @return {YPowerOutput} a YPowerOutput object allowing you to drive the power ouput control.
     */
    static FindPowerOutput(func) {
        /** @type {YPowerOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('PowerOutput', func);
        if (obj == null) {
            obj = new YPowerOutput(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('PowerOutput', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a dual power  ouput control for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the power ouput control is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPowerOutput.isOnline() to test if the power ouput control is
     * indeed online at a given time. In case of ambiguity when looking for
     * a dual power  ouput control by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the power ouput control
     *
     * @return {YPowerOutput} a YPowerOutput object allowing you to drive the power ouput control.
     */
    static FindPowerOutputInContext(yctx, func) {
        /** @type {YPowerOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'PowerOutput', func);
        if (obj == null) {
            obj = new YPowerOutput(yctx, func);
            _yocto_api.YFunction._AddToCache('PowerOutput', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of dual power ouput controls started using yFirstPowerOutput().
     *
     * @return {YPowerOutput} a pointer to a YPowerOutput object, corresponding to
     *         a dual power  ouput control currently online, or a null pointer
     *         if there are no more dual power ouput controls to enumerate.
     */
    /* */nextPowerOutput() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPowerOutput.FindPowerOutputInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of dual power ouput controls currently accessible.
     * Use the method YPowerOutput.nextPowerOutput() to iterate on
     * next dual power ouput controls.
     *
     * @return {YPowerOutput} a pointer to a YPowerOutput object, corresponding to
     *         the first dual power ouput control currently online, or a null pointer
     *         if there are none.
     */
    static FirstPowerOutput() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('PowerOutput');
        if (next_hwid == null) return null;
        return YPowerOutput.FindPowerOutput(next_hwid);
    }

    /**
     * Starts the enumeration of dual power ouput controls currently accessible.
     * Use the method YPowerOutput.nextPowerOutput() to iterate on
     * next dual power ouput controls.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPowerOutput} a pointer to a YPowerOutput object, corresponding to
     *         the first dual power ouput control currently online, or a null pointer
     *         if there are none.
     */
    static FirstPowerOutputInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('PowerOutput');
        if (next_hwid == null) return null;
        return YPowerOutput.FindPowerOutputInContext(yctx, next_hwid);
    }

    //--- (end of YPowerOutput implementation)
}

exports.YPowerOutput = YPowerOutput; //--- (PowerOutput functions)

/**
 * comment from .yc definition
 */

function yFindPowerOutput(func) {
    return YPowerOutput.FindPowerOutput(func);
}

/**
 * comment from .yc definition
 */
function yFirstPowerOutput() {
    return YPowerOutput.FirstPowerOutput();
}

//--- (end of PowerOutput functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Pressure functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPressure = undefined;
exports.yFindPressure = yFindPressure;
exports.yFirstPressure = yFirstPressure;

var _yocto_api = require('lib/yocto_api');

//--- (YPressure return codes)
//--- (end of YPressure return codes)
//--- (YPressure definitions)
//--- (end of YPressure definitions)

//--- (YPressure class start)
/**
 * YPressure Class: Pressure function interface
 *
 * The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YPressure class start)

class YPressure extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YPressure constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Pressure';
        //--- (end of YPressure constructor)
    }

    //--- (YPressure implementation)

    /**
     * Retrieves a pressure sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the pressure sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPressure.isOnline() to test if the pressure sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a pressure sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the pressure sensor
     *
     * @return {YPressure} a YPressure object allowing you to drive the pressure sensor.
     */
    static FindPressure(func) {
        /** @type {YPressure} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Pressure', func);
        if (obj == null) {
            obj = new YPressure(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Pressure', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a pressure sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the pressure sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPressure.isOnline() to test if the pressure sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a pressure sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the pressure sensor
     *
     * @return {YPressure} a YPressure object allowing you to drive the pressure sensor.
     */
    static FindPressureInContext(yctx, func) {
        /** @type {YPressure} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Pressure', func);
        if (obj == null) {
            obj = new YPressure(yctx, func);
            _yocto_api.YFunction._AddToCache('Pressure', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of pressure sensors started using yFirstPressure().
     *
     * @return {YPressure} a pointer to a YPressure object, corresponding to
     *         a pressure sensor currently online, or a null pointer
     *         if there are no more pressure sensors to enumerate.
     */
    /* */nextPressure() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPressure.FindPressureInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of pressure sensors currently accessible.
     * Use the method YPressure.nextPressure() to iterate on
     * next pressure sensors.
     *
     * @return {YPressure} a pointer to a YPressure object, corresponding to
     *         the first pressure sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstPressure() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Pressure');
        if (next_hwid == null) return null;
        return YPressure.FindPressure(next_hwid);
    }

    /**
     * Starts the enumeration of pressure sensors currently accessible.
     * Use the method YPressure.nextPressure() to iterate on
     * next pressure sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPressure} a pointer to a YPressure object, corresponding to
     *         the first pressure sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstPressureInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Pressure');
        if (next_hwid == null) return null;
        return YPressure.FindPressureInContext(yctx, next_hwid);
    }

    //--- (end of YPressure implementation)
}

exports.YPressure = YPressure; //--- (Pressure functions)

/**
 * comment from .yc definition
 */

function yFindPressure(func) {
    return YPressure.FindPressure(func);
}

/**
 * comment from .yc definition
 */
function yFirstPressure() {
    return YPressure.FirstPressure();
}

//--- (end of Pressure functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for PwmInput functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPwmInput = exports.Y_PULSETIMER_INVALID = exports.Y_PULSECOUNTER_INVALID = exports.Y_PERIOD_INVALID = exports.Y_FREQUENCY_INVALID = exports.Y_PULSEDURATION_INVALID = exports.Y_DUTYCYCLE_INVALID = exports.Y_PWMREPORTMODE_INVALID = exports.Y_PWMREPORTMODE_PWM_EDGECOUNT = exports.Y_PWMREPORTMODE_PWM_PULSEDURATION = exports.Y_PWMREPORTMODE_PWM_FREQUENCY = exports.Y_PWMREPORTMODE_PWM_DUTYCYCLE = undefined;
exports.yFindPwmInput = yFindPwmInput;
exports.yFirstPwmInput = yFirstPwmInput;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YPwmInput return codes)
//--- (end of YPwmInput return codes)
//--- (YPwmInput definitions)
const Y_PWMREPORTMODE_PWM_DUTYCYCLE = exports.Y_PWMREPORTMODE_PWM_DUTYCYCLE = 0;
const Y_PWMREPORTMODE_PWM_FREQUENCY = exports.Y_PWMREPORTMODE_PWM_FREQUENCY = 1;
const Y_PWMREPORTMODE_PWM_PULSEDURATION = exports.Y_PWMREPORTMODE_PWM_PULSEDURATION = 2;
const Y_PWMREPORTMODE_PWM_EDGECOUNT = exports.Y_PWMREPORTMODE_PWM_EDGECOUNT = 3;
const Y_PWMREPORTMODE_INVALID = exports.Y_PWMREPORTMODE_INVALID = -1;
const Y_DUTYCYCLE_INVALID = exports.Y_DUTYCYCLE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PULSEDURATION_INVALID = exports.Y_PULSEDURATION_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_FREQUENCY_INVALID = exports.Y_FREQUENCY_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PERIOD_INVALID = exports.Y_PERIOD_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PULSECOUNTER_INVALID = exports.Y_PULSECOUNTER_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_PULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YPwmInput definitions)

//--- (YPwmInput class start)
/**
 * YPwmInput Class: PwmInput function interface
 *
 * The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to configure the signal parameter used to transmit
 * information: the duty cycle, the frequency or the pulse width.
 */
//--- (end of YPwmInput class start)

class YPwmInput extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YPwmInput constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'PwmInput';
        /** @member {number} **/
        this._dutyCycle = Y_DUTYCYCLE_INVALID;
        /** @member {number} **/
        this._pulseDuration = Y_PULSEDURATION_INVALID;
        /** @member {number} **/
        this._frequency = Y_FREQUENCY_INVALID;
        /** @member {number} **/
        this._period = Y_PERIOD_INVALID;
        /** @member {number} **/
        this._pulseCounter = Y_PULSECOUNTER_INVALID;
        /** @member {number} **/
        this._pulseTimer = Y_PULSETIMER_INVALID;
        /** @member {number} **/
        this._pwmReportMode = Y_PWMREPORTMODE_INVALID;
        this.imm_setConst({
            DUTYCYCLE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PULSEDURATION_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            FREQUENCY_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PERIOD_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PULSECOUNTER_INVALID: _yocto_api.YAPI.INVALID_LONG,
            PULSETIMER_INVALID: _yocto_api.YAPI.INVALID_LONG,
            PWMREPORTMODE_PWM_DUTYCYCLE: 0,
            PWMREPORTMODE_PWM_FREQUENCY: 1,
            PWMREPORTMODE_PWM_PULSEDURATION: 2,
            PWMREPORTMODE_PWM_EDGECOUNT: 3,
            PWMREPORTMODE_INVALID: -1
        });
        //--- (end of YPwmInput constructor)
    }

    //--- (YPwmInput implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'dutyCycle':
                this._dutyCycle = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'pulseDuration':
                this._pulseDuration = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'frequency':
                this._frequency = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'period':
                this._period = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'pulseCounter':
                this._pulseCounter = parseInt(val);
                return 1;
            case 'pulseTimer':
                this._pulseTimer = parseInt(val);
                return 1;
            case 'pwmReportMode':
                this._pwmReportMode = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the PWM duty cycle, in per cents.
     *
     * @return {number} a floating point number corresponding to the PWM duty cycle, in per cents
     *
     * On failure, throws an exception or returns YPwmInput.DUTYCYCLE_INVALID.
     */
    get_dutyCycle() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DUTYCYCLE_INVALID;
                }
            }
            return _this._dutyCycle;
        })();
    }

    /**
     * Returns the PWM pulse length in milliseconds, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the PWM pulse length in milliseconds, as
     * a floating point number
     *
     * On failure, throws an exception or returns YPwmInput.PULSEDURATION_INVALID.
     */
    get_pulseDuration() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSEDURATION_INVALID;
                }
            }
            return _this2._pulseDuration;
        })();
    }

    /**
     * Returns the PWM frequency in Hz.
     *
     * @return {number} a floating point number corresponding to the PWM frequency in Hz
     *
     * On failure, throws an exception or returns YPwmInput.FREQUENCY_INVALID.
     */
    get_frequency() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FREQUENCY_INVALID;
                }
            }
            return _this3._frequency;
        })();
    }

    /**
     * Returns the PWM period in milliseconds.
     *
     * @return {number} a floating point number corresponding to the PWM period in milliseconds
     *
     * On failure, throws an exception or returns YPwmInput.PERIOD_INVALID.
     */
    get_period() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PERIOD_INVALID;
                }
            }
            return _this4._period;
        })();
    }

    /**
     * Returns the pulse counter value. Actually that
     * counter is incremented twice per period. That counter is
     * limited  to 1 billion
     *
     * @return {number} an integer corresponding to the pulse counter value
     *
     * On failure, throws an exception or returns YPwmInput.PULSECOUNTER_INVALID.
     */
    get_pulseCounter() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSECOUNTER_INVALID;
                }
            }
            return _this5._pulseCounter;
        })();
    }

    set_pulseCounter(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('pulseCounter', rest_val);
        })();
    }

    /**
     * Returns the timer of the pulses counter (ms)
     *
     * @return {number} an integer corresponding to the timer of the pulses counter (ms)
     *
     * On failure, throws an exception or returns YPwmInput.PULSETIMER_INVALID.
     */
    get_pulseTimer() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSETIMER_INVALID;
                }
            }
            return _this7._pulseTimer;
        })();
    }

    /**
     * Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the
     * get_currentValue function and callbacks. Attention
     *
     * @return {number} a value among YPwmInput.PWMREPORTMODE_PWM_DUTYCYCLE,
     * YPwmInput.PWMREPORTMODE_PWM_FREQUENCY, YPwmInput.PWMREPORTMODE_PWM_PULSEDURATION and
     * YPwmInput.PWMREPORTMODE_PWM_EDGECOUNT corresponding to the parameter (frequency/duty cycle, pulse
     * width, edges count) returned by the get_currentValue function and callbacks
     *
     * On failure, throws an exception or returns YPwmInput.PWMREPORTMODE_INVALID.
     */
    get_pwmReportMode() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PWMREPORTMODE_INVALID;
                }
            }
            return _this8._pwmReportMode;
        })();
    }

    /**
     * Modifies the  parameter  type (frequency/duty cycle, pulse width, or edge count) returned by the
     * get_currentValue function and callbacks.
     * The edge count value is limited to the 6 lowest digits. For values greater than one million, use
     * get_pulseCounter().
     *
     * @param newval {number} : a value among YPwmInput.PWMREPORTMODE_PWM_DUTYCYCLE,
     * YPwmInput.PWMREPORTMODE_PWM_FREQUENCY, YPwmInput.PWMREPORTMODE_PWM_PULSEDURATION and
     * YPwmInput.PWMREPORTMODE_PWM_EDGECOUNT
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_pwmReportMode(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this9._setAttr('pwmReportMode', rest_val);
        })();
    }

    /**
     * Retrieves a PWM input for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the PWM input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmInput.isOnline() to test if the PWM input is
     * indeed online at a given time. In case of ambiguity when looking for
     * a PWM input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the PWM input
     *
     * @return {YPwmInput} a YPwmInput object allowing you to drive the PWM input.
     */
    static FindPwmInput(func) {
        /** @type {YPwmInput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('PwmInput', func);
        if (obj == null) {
            obj = new YPwmInput(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('PwmInput', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a PWM input for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the PWM input is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmInput.isOnline() to test if the PWM input is
     * indeed online at a given time. In case of ambiguity when looking for
     * a PWM input by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the PWM input
     *
     * @return {YPwmInput} a YPwmInput object allowing you to drive the PWM input.
     */
    static FindPwmInputInContext(yctx, func) {
        /** @type {YPwmInput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'PwmInput', func);
        if (obj == null) {
            obj = new YPwmInput(yctx, func);
            _yocto_api.YFunction._AddToCache('PwmInput', func, obj);
        }
        return obj;
    }

    /**
     * Returns the pulse counter value as well as its timer.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    resetCounter() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            return yield _this10.set_pulseCounter(0);
        })();
    }

    /**
     * Continues the enumeration of PWM inputs started using yFirstPwmInput().
     *
     * @return {YPwmInput} a pointer to a YPwmInput object, corresponding to
     *         a PWM input currently online, or a null pointer
     *         if there are no more PWM inputs to enumerate.
     */
    /* */nextPwmInput() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPwmInput.FindPwmInputInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of PWM inputs currently accessible.
     * Use the method YPwmInput.nextPwmInput() to iterate on
     * next PWM inputs.
     *
     * @return {YPwmInput} a pointer to a YPwmInput object, corresponding to
     *         the first PWM input currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmInput() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('PwmInput');
        if (next_hwid == null) return null;
        return YPwmInput.FindPwmInput(next_hwid);
    }

    /**
     * Starts the enumeration of PWM inputs currently accessible.
     * Use the method YPwmInput.nextPwmInput() to iterate on
     * next PWM inputs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPwmInput} a pointer to a YPwmInput object, corresponding to
     *         the first PWM input currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmInputInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('PwmInput');
        if (next_hwid == null) return null;
        return YPwmInput.FindPwmInputInContext(yctx, next_hwid);
    }

    //--- (end of YPwmInput implementation)
}

exports.YPwmInput = YPwmInput; //--- (PwmInput functions)

/**
 * comment from .yc definition
 */

function yFindPwmInput(func) {
    return YPwmInput.FindPwmInput(func);
}

/**
 * comment from .yc definition
 */
function yFirstPwmInput() {
    return YPwmInput.FirstPwmInput();
}

//--- (end of PwmInput functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for PwmOutput functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPwmOutput = exports.Y_DUTYCYCLEATPOWERON_INVALID = exports.Y_PWMTRANSITION_INVALID = exports.Y_PULSEDURATION_INVALID = exports.Y_DUTYCYCLE_INVALID = exports.Y_PERIOD_INVALID = exports.Y_FREQUENCY_INVALID = exports.Y_ENABLEDATPOWERON_INVALID = exports.Y_ENABLEDATPOWERON_TRUE = exports.Y_ENABLEDATPOWERON_FALSE = exports.Y_ENABLED_INVALID = exports.Y_ENABLED_TRUE = exports.Y_ENABLED_FALSE = undefined;
exports.yFindPwmOutput = yFindPwmOutput;
exports.yFirstPwmOutput = yFirstPwmOutput;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YPwmOutput return codes)
//--- (end of YPwmOutput return codes)
//--- (YPwmOutput definitions)
const Y_ENABLED_FALSE = exports.Y_ENABLED_FALSE = 0;
const Y_ENABLED_TRUE = exports.Y_ENABLED_TRUE = 1;
const Y_ENABLED_INVALID = exports.Y_ENABLED_INVALID = -1;
const Y_ENABLEDATPOWERON_FALSE = exports.Y_ENABLEDATPOWERON_FALSE = 0;
const Y_ENABLEDATPOWERON_TRUE = exports.Y_ENABLEDATPOWERON_TRUE = 1;
const Y_ENABLEDATPOWERON_INVALID = exports.Y_ENABLEDATPOWERON_INVALID = -1;
const Y_FREQUENCY_INVALID = exports.Y_FREQUENCY_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PERIOD_INVALID = exports.Y_PERIOD_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_DUTYCYCLE_INVALID = exports.Y_DUTYCYCLE_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PULSEDURATION_INVALID = exports.Y_PULSEDURATION_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_PWMTRANSITION_INVALID = exports.Y_PWMTRANSITION_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_DUTYCYCLEATPOWERON_INVALID = exports.Y_DUTYCYCLEATPOWERON_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YPwmOutput definitions)

//--- (YPwmOutput class start)
/**
 * YPwmOutput Class: PwmOutput function interface
 *
 * The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.
 */
//--- (end of YPwmOutput class start)

class YPwmOutput extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YPwmOutput constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'PwmOutput';
        /** @member {number} **/
        this._enabled = Y_ENABLED_INVALID;
        /** @member {number} **/
        this._frequency = Y_FREQUENCY_INVALID;
        /** @member {number} **/
        this._period = Y_PERIOD_INVALID;
        /** @member {number} **/
        this._dutyCycle = Y_DUTYCYCLE_INVALID;
        /** @member {number} **/
        this._pulseDuration = Y_PULSEDURATION_INVALID;
        /** @member {string} **/
        this._pwmTransition = Y_PWMTRANSITION_INVALID;
        /** @member {number} **/
        this._enabledAtPowerOn = Y_ENABLEDATPOWERON_INVALID;
        /** @member {number} **/
        this._dutyCycleAtPowerOn = Y_DUTYCYCLEATPOWERON_INVALID;
        this.imm_setConst({
            ENABLED_FALSE: 0,
            ENABLED_TRUE: 1,
            ENABLED_INVALID: -1,
            FREQUENCY_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PERIOD_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            DUTYCYCLE_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PULSEDURATION_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            PWMTRANSITION_INVALID: _yocto_api.YAPI.INVALID_STRING,
            ENABLEDATPOWERON_FALSE: 0,
            ENABLEDATPOWERON_TRUE: 1,
            ENABLEDATPOWERON_INVALID: -1,
            DUTYCYCLEATPOWERON_INVALID: _yocto_api.YAPI.INVALID_DOUBLE
        });
        //--- (end of YPwmOutput constructor)
    }

    //--- (YPwmOutput implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'enabled':
                this._enabled = parseInt(val);
                return 1;
            case 'frequency':
                this._frequency = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'period':
                this._period = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'dutyCycle':
                this._dutyCycle = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'pulseDuration':
                this._pulseDuration = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'pwmTransition':
                this._pwmTransition = val;
                return 1;
            case 'enabledAtPowerOn':
                this._enabledAtPowerOn = parseInt(val);
                return 1;
            case 'dutyCycleAtPowerOn':
                this._dutyCycleAtPowerOn = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the state of the PWMs.
     *
     * @return {number} either YPwmOutput.ENABLED_FALSE or YPwmOutput.ENABLED_TRUE, according to the state of the PWMs
     *
     * On failure, throws an exception or returns YPwmOutput.ENABLED_INVALID.
     */
    get_enabled() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLED_INVALID;
                }
            }
            return _this._enabled;
        })();
    }

    /**
     * Stops or starts the PWM.
     *
     * @param newval {number} : either YPwmOutput.ENABLED_FALSE or YPwmOutput.ENABLED_TRUE
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabled(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('enabled', rest_val);
        })();
    }

    /**
     * Changes the PWM frequency. The duty cycle is kept unchanged thanks to an
     * automatic pulse width change.
     *
     * @param newval {number} : a floating point number corresponding to the PWM frequency
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_frequency(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this3._setAttr('frequency', rest_val);
        })();
    }

    /**
     * Returns the PWM frequency in Hz.
     *
     * @return {number} a floating point number corresponding to the PWM frequency in Hz
     *
     * On failure, throws an exception or returns YPwmOutput.FREQUENCY_INVALID.
     */
    get_frequency() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_FREQUENCY_INVALID;
                }
            }
            return _this4._frequency;
        })();
    }

    /**
     * Changes the PWM period in milliseconds.
     *
     * @param newval {number} : a floating point number corresponding to the PWM period in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_period(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this5._setAttr('period', rest_val);
        })();
    }

    /**
     * Returns the PWM period in milliseconds.
     *
     * @return {number} a floating point number corresponding to the PWM period in milliseconds
     *
     * On failure, throws an exception or returns YPwmOutput.PERIOD_INVALID.
     */
    get_period() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PERIOD_INVALID;
                }
            }
            return _this6._period;
        })();
    }

    /**
     * Changes the PWM duty cycle, in per cents.
     *
     * @param newval {number} : a floating point number corresponding to the PWM duty cycle, in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_dutyCycle(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this7._setAttr('dutyCycle', rest_val);
        })();
    }

    /**
     * Returns the PWM duty cycle, in per cents.
     *
     * @return {number} a floating point number corresponding to the PWM duty cycle, in per cents
     *
     * On failure, throws an exception or returns YPwmOutput.DUTYCYCLE_INVALID.
     */
    get_dutyCycle() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DUTYCYCLE_INVALID;
                }
            }
            return _this8._dutyCycle;
        })();
    }

    /**
     * Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period,
     * otherwise it is truncated.
     *
     * @param newval {number} : a floating point number corresponding to the PWM pulse length, in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_pulseDuration(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this9._setAttr('pulseDuration', rest_val);
        })();
    }

    /**
     * Returns the PWM pulse length in milliseconds, as a floating point number.
     *
     * @return {number} a floating point number corresponding to the PWM pulse length in milliseconds, as
     * a floating point number
     *
     * On failure, throws an exception or returns YPwmOutput.PULSEDURATION_INVALID.
     */
    get_pulseDuration() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSEDURATION_INVALID;
                }
            }
            return _this10._pulseDuration;
        })();
    }

    get_pwmTransition() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PWMTRANSITION_INVALID;
                }
            }
            return _this11._pwmTransition;
        })();
    }

    set_pwmTransition(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this12._setAttr('pwmTransition', rest_val);
        })();
    }

    /**
     * Returns the state of the PWM at device power on.
     *
     * @return {number} either YPwmOutput.ENABLEDATPOWERON_FALSE or YPwmOutput.ENABLEDATPOWERON_TRUE,
     * according to the state of the PWM at device power on
     *
     * On failure, throws an exception or returns YPwmOutput.ENABLEDATPOWERON_INVALID.
     */
    get_enabledAtPowerOn() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLEDATPOWERON_INVALID;
                }
            }
            return _this13._enabledAtPowerOn;
        })();
    }

    /**
     * Changes the state of the PWM at device power on. Remember to call the matching module saveToFlash()
     * method, otherwise this call will have no effect.
     *
     * @param newval {number} : either YPwmOutput.ENABLEDATPOWERON_FALSE or
     * YPwmOutput.ENABLEDATPOWERON_TRUE, according to the state of the PWM at device power on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabledAtPowerOn(newval) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this14._setAttr('enabledAtPowerOn', rest_val);
        })();
    }

    /**
     * Changes the PWM duty cycle at device power on. Remember to call the matching
     * module saveToFlash() method, otherwise this call will have no effect.
     *
     * @param newval {number} : a floating point number corresponding to the PWM duty cycle at device power on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_dutyCycleAtPowerOn(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this15._setAttr('dutyCycleAtPowerOn', rest_val);
        })();
    }

    /**
     * Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100
     *
     * @return {number} a floating point number corresponding to the PWMs duty cycle at device power on as
     * a floating point number between 0 and 100
     *
     * On failure, throws an exception or returns YPwmOutput.DUTYCYCLEATPOWERON_INVALID.
     */
    get_dutyCycleAtPowerOn() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            if (_this16._cacheExpiration <= _this16._yapi.GetTickCount()) {
                if ((yield _this16.load(_this16._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DUTYCYCLEATPOWERON_INVALID;
                }
            }
            return _this16._dutyCycleAtPowerOn;
        })();
    }

    /**
     * Retrieves a PWM for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the PWM is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmOutput.isOnline() to test if the PWM is
     * indeed online at a given time. In case of ambiguity when looking for
     * a PWM by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the PWM
     *
     * @return {YPwmOutput} a YPwmOutput object allowing you to drive the PWM.
     */
    static FindPwmOutput(func) {
        /** @type {YPwmOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('PwmOutput', func);
        if (obj == null) {
            obj = new YPwmOutput(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('PwmOutput', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a PWM for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the PWM is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmOutput.isOnline() to test if the PWM is
     * indeed online at a given time. In case of ambiguity when looking for
     * a PWM by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the PWM
     *
     * @return {YPwmOutput} a YPwmOutput object allowing you to drive the PWM.
     */
    static FindPwmOutputInContext(yctx, func) {
        /** @type {YPwmOutput} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'PwmOutput', func);
        if (obj == null) {
            obj = new YPwmOutput(yctx, func);
            _yocto_api.YFunction._AddToCache('PwmOutput', func, obj);
        }
        return obj;
    }

    /**
     * Performs a smooth transistion of the pulse duration toward a given value. Any period,
     * frequency, duty cycle or pulse width change will cancel any ongoing transition process.
     *
     * @param ms_target   : new pulse duration at the end of the transition
     *         (floating-point number, representing the pulse duration in milliseconds)
     * @param ms_duration {number} : total duration of the transition, in milliseconds
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pulseDurationMove(ms_target, ms_duration) {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let newval;
            if (ms_target < 0.0) {
                ms_target = 0.0;
            }
            newval = String(Math.round(Math.round(ms_target * 65536))) + 'ms:' + String(Math.round(ms_duration));
            return yield _this17.set_pwmTransition(newval);
        })();
    }

    /**
     * Performs a smooth change of the pulse duration toward a given value.
     *
     * @param target      : new duty cycle at the end of the transition
     *         (floating-point number, between 0 and 1)
     * @param ms_duration {number} : total duration of the transition, in milliseconds
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    dutyCycleMove(target, ms_duration) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let newval;
            if (target < 0.0) {
                target = 0.0;
            }
            if (target > 100.0) {
                target = 100.0;
            }
            newval = String(Math.round(Math.round(target * 65536))) + ':' + String(Math.round(ms_duration));
            return yield _this18.set_pwmTransition(newval);
        })();
    }

    /**
     * Continues the enumeration of PWMs started using yFirstPwmOutput().
     *
     * @return {YPwmOutput} a pointer to a YPwmOutput object, corresponding to
     *         a PWM currently online, or a null pointer
     *         if there are no more PWMs to enumerate.
     */
    /* */nextPwmOutput() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPwmOutput.FindPwmOutputInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of PWMs currently accessible.
     * Use the method YPwmOutput.nextPwmOutput() to iterate on
     * next PWMs.
     *
     * @return {YPwmOutput} a pointer to a YPwmOutput object, corresponding to
     *         the first PWM currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmOutput() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('PwmOutput');
        if (next_hwid == null) return null;
        return YPwmOutput.FindPwmOutput(next_hwid);
    }

    /**
     * Starts the enumeration of PWMs currently accessible.
     * Use the method YPwmOutput.nextPwmOutput() to iterate on
     * next PWMs.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPwmOutput} a pointer to a YPwmOutput object, corresponding to
     *         the first PWM currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmOutputInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('PwmOutput');
        if (next_hwid == null) return null;
        return YPwmOutput.FindPwmOutputInContext(yctx, next_hwid);
    }

    //--- (end of YPwmOutput implementation)
}

exports.YPwmOutput = YPwmOutput; //--- (PwmOutput functions)

/**
 * comment from .yc definition
 */

function yFindPwmOutput(func) {
    return YPwmOutput.FindPwmOutput(func);
}

/**
 * comment from .yc definition
 */
function yFirstPwmOutput() {
    return YPwmOutput.FirstPwmOutput();
}

//--- (end of PwmOutput functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for PwmPowerSource functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YPwmPowerSource = exports.Y_POWERMODE_INVALID = exports.Y_POWERMODE_OPNDRN = exports.Y_POWERMODE_EXT_V = exports.Y_POWERMODE_USB_3V = exports.Y_POWERMODE_USB_5V = undefined;
exports.yFindPwmPowerSource = yFindPwmPowerSource;
exports.yFirstPwmPowerSource = yFirstPwmPowerSource;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YPwmPowerSource return codes)
//--- (end of YPwmPowerSource return codes)
//--- (YPwmPowerSource definitions)
const Y_POWERMODE_USB_5V = exports.Y_POWERMODE_USB_5V = 0;
const Y_POWERMODE_USB_3V = exports.Y_POWERMODE_USB_3V = 1;
const Y_POWERMODE_EXT_V = exports.Y_POWERMODE_EXT_V = 2;
const Y_POWERMODE_OPNDRN = exports.Y_POWERMODE_OPNDRN = 3;
const Y_POWERMODE_INVALID = exports.Y_POWERMODE_INVALID = -1;
//--- (end of YPwmPowerSource definitions)

//--- (YPwmPowerSource class start)
/**
 * YPwmPowerSource Class: PwmPowerSource function interface
 *
 * The Yoctopuce application programming interface allows you to configure
 * the voltage source used by all PWM on the same device.
 */
//--- (end of YPwmPowerSource class start)

class YPwmPowerSource extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YPwmPowerSource constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'PwmPowerSource';
        /** @member {number} **/
        this._powerMode = Y_POWERMODE_INVALID;
        this.imm_setConst({
            POWERMODE_USB_5V: 0,
            POWERMODE_USB_3V: 1,
            POWERMODE_EXT_V: 2,
            POWERMODE_OPNDRN: 3,
            POWERMODE_INVALID: -1
        });
        //--- (end of YPwmPowerSource constructor)
    }

    //--- (YPwmPowerSource implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'powerMode':
                this._powerMode = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the selected power source for the PWM on the same device
     *
     * @return {number} a value among YPwmPowerSource.POWERMODE_USB_5V, YPwmPowerSource.POWERMODE_USB_3V,
     * YPwmPowerSource.POWERMODE_EXT_V and YPwmPowerSource.POWERMODE_OPNDRN corresponding to the selected
     * power source for the PWM on the same device
     *
     * On failure, throws an exception or returns YPwmPowerSource.POWERMODE_INVALID.
     */
    get_powerMode() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POWERMODE_INVALID;
                }
            }
            return _this._powerMode;
        })();
    }

    /**
     * Changes  the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or
     * voltage from an external power source. The PWM can also work in open drain  mode. In that
     * mode, the PWM actively pulls the line down.
     * Warning: this setting is common to all PWM on the same device. If you change that parameter,
     * all PWM located on the same device are  affected.
     * If you want the change to be kept after a device reboot, make sure  to call the matching
     * module saveToFlash().
     *
     * @param newval {number} : a value among YPwmPowerSource.POWERMODE_USB_5V,
     * YPwmPowerSource.POWERMODE_USB_3V, YPwmPowerSource.POWERMODE_EXT_V and
     * YPwmPowerSource.POWERMODE_OPNDRN corresponding to  the PWM power source
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_powerMode(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('powerMode', rest_val);
        })();
    }

    /**
     * Retrieves a voltage source for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the voltage source is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmPowerSource.isOnline() to test if the voltage source is
     * indeed online at a given time. In case of ambiguity when looking for
     * a voltage source by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the voltage source
     *
     * @return {YPwmPowerSource} a YPwmPowerSource object allowing you to drive the voltage source.
     */
    static FindPwmPowerSource(func) {
        /** @type {YPwmPowerSource} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('PwmPowerSource', func);
        if (obj == null) {
            obj = new YPwmPowerSource(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('PwmPowerSource', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a voltage source for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the voltage source is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YPwmPowerSource.isOnline() to test if the voltage source is
     * indeed online at a given time. In case of ambiguity when looking for
     * a voltage source by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the voltage source
     *
     * @return {YPwmPowerSource} a YPwmPowerSource object allowing you to drive the voltage source.
     */
    static FindPwmPowerSourceInContext(yctx, func) {
        /** @type {YPwmPowerSource} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'PwmPowerSource', func);
        if (obj == null) {
            obj = new YPwmPowerSource(yctx, func);
            _yocto_api.YFunction._AddToCache('PwmPowerSource', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of Voltage sources started using yFirstPwmPowerSource().
     *
     * @return {YPwmPowerSource} a pointer to a YPwmPowerSource object, corresponding to
     *         a voltage source currently online, or a null pointer
     *         if there are no more Voltage sources to enumerate.
     */
    /* */nextPwmPowerSource() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YPwmPowerSource.FindPwmPowerSourceInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of Voltage sources currently accessible.
     * Use the method YPwmPowerSource.nextPwmPowerSource() to iterate on
     * next Voltage sources.
     *
     * @return {YPwmPowerSource} a pointer to a YPwmPowerSource object, corresponding to
     *         the first source currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmPowerSource() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('PwmPowerSource');
        if (next_hwid == null) return null;
        return YPwmPowerSource.FindPwmPowerSource(next_hwid);
    }

    /**
     * Starts the enumeration of Voltage sources currently accessible.
     * Use the method YPwmPowerSource.nextPwmPowerSource() to iterate on
     * next Voltage sources.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YPwmPowerSource} a pointer to a YPwmPowerSource object, corresponding to
     *         the first source currently online, or a null pointer
     *         if there are none.
     */
    static FirstPwmPowerSourceInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('PwmPowerSource');
        if (next_hwid == null) return null;
        return YPwmPowerSource.FindPwmPowerSourceInContext(yctx, next_hwid);
    }

    //--- (end of YPwmPowerSource implementation)
}

exports.YPwmPowerSource = YPwmPowerSource; //--- (PwmPowerSource functions)

/**
 * comment from .yc definition
 */

function yFindPwmPowerSource(func) {
    return YPwmPowerSource.FindPwmPowerSource(func);
}

/**
 * comment from .yc definition
 */
function yFirstPwmPowerSource() {
    return YPwmPowerSource.FirstPwmPowerSource();
}

//--- (end of PwmPowerSource functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for QuadratureDecoder functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YQuadratureDecoder = exports.Y_SPEED_INVALID = exports.Y_DECODING_INVALID = exports.Y_DECODING_ON = exports.Y_DECODING_OFF = undefined;
exports.yFindQuadratureDecoder = yFindQuadratureDecoder;
exports.yFirstQuadratureDecoder = yFirstQuadratureDecoder;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YQuadratureDecoder return codes)
//--- (end of YQuadratureDecoder return codes)
//--- (YQuadratureDecoder definitions)
const Y_DECODING_OFF = exports.Y_DECODING_OFF = 0;
const Y_DECODING_ON = exports.Y_DECODING_ON = 1;
const Y_DECODING_INVALID = exports.Y_DECODING_INVALID = -1;
const Y_SPEED_INVALID = exports.Y_SPEED_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
//--- (end of YQuadratureDecoder definitions)

//--- (YQuadratureDecoder class start)
/**
 * YQuadratureDecoder Class: QuadratureDecoder function interface
 *
 * The class YQuadratureDecoder allows you to decode a two-wire signal produced by a
 * quadrature encoder. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YQuadratureDecoder class start)

class YQuadratureDecoder extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YQuadratureDecoder constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'QuadratureDecoder';
        /** @member {number} **/
        this._speed = Y_SPEED_INVALID;
        /** @member {number} **/
        this._decoding = Y_DECODING_INVALID;
        this.imm_setConst({
            SPEED_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            DECODING_OFF: 0,
            DECODING_ON: 1,
            DECODING_INVALID: -1
        });
        //--- (end of YQuadratureDecoder constructor)
    }

    //--- (YQuadratureDecoder implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'speed':
                this._speed = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'decoding':
                this._decoding = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the current expected position of the quadrature decoder.
     * Invoking this function implicitely activates the quadrature decoder.
     *
     * @param newval {number} : a floating point number corresponding to the current expected position of
     * the quadrature decoder
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_currentValue(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this._setAttr('currentValue', rest_val);
        })();
    }

    /**
     * Returns the PWM frequency in Hz.
     *
     * @return {number} a floating point number corresponding to the PWM frequency in Hz
     *
     * On failure, throws an exception or returns YQuadratureDecoder.SPEED_INVALID.
     */
    get_speed() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SPEED_INVALID;
                }
            }
            return _this2._speed;
        })();
    }

    /**
     * Returns the current activation state of the quadrature decoder.
     *
     * @return {number} either YQuadratureDecoder.DECODING_OFF or YQuadratureDecoder.DECODING_ON,
     * according to the current activation state of the quadrature decoder
     *
     * On failure, throws an exception or returns YQuadratureDecoder.DECODING_INVALID.
     */
    get_decoding() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DECODING_INVALID;
                }
            }
            return _this3._decoding;
        })();
    }

    /**
     * Changes the activation state of the quadrature decoder.
     *
     * @param newval {number} : either YQuadratureDecoder.DECODING_OFF or YQuadratureDecoder.DECODING_ON,
     * according to the activation state of the quadrature decoder
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_decoding(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('decoding', rest_val);
        })();
    }

    /**
     * Retrieves a quadrature decoder for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the quadrature decoder is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YQuadratureDecoder.isOnline() to test if the quadrature decoder is
     * indeed online at a given time. In case of ambiguity when looking for
     * a quadrature decoder by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the quadrature decoder
     *
     * @return {YQuadratureDecoder} a YQuadratureDecoder object allowing you to drive the quadrature decoder.
     */
    static FindQuadratureDecoder(func) {
        /** @type {YQuadratureDecoder} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('QuadratureDecoder', func);
        if (obj == null) {
            obj = new YQuadratureDecoder(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('QuadratureDecoder', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a quadrature decoder for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the quadrature decoder is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YQuadratureDecoder.isOnline() to test if the quadrature decoder is
     * indeed online at a given time. In case of ambiguity when looking for
     * a quadrature decoder by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the quadrature decoder
     *
     * @return {YQuadratureDecoder} a YQuadratureDecoder object allowing you to drive the quadrature decoder.
     */
    static FindQuadratureDecoderInContext(yctx, func) {
        /** @type {YQuadratureDecoder} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'QuadratureDecoder', func);
        if (obj == null) {
            obj = new YQuadratureDecoder(yctx, func);
            _yocto_api.YFunction._AddToCache('QuadratureDecoder', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of quadrature decoders started using yFirstQuadratureDecoder().
     *
     * @return {YQuadratureDecoder} a pointer to a YQuadratureDecoder object, corresponding to
     *         a quadrature decoder currently online, or a null pointer
     *         if there are no more quadrature decoders to enumerate.
     */
    /* */nextQuadratureDecoder() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YQuadratureDecoder.FindQuadratureDecoderInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of quadrature decoders currently accessible.
     * Use the method YQuadratureDecoder.nextQuadratureDecoder() to iterate on
     * next quadrature decoders.
     *
     * @return {YQuadratureDecoder} a pointer to a YQuadratureDecoder object, corresponding to
     *         the first quadrature decoder currently online, or a null pointer
     *         if there are none.
     */
    static FirstQuadratureDecoder() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('QuadratureDecoder');
        if (next_hwid == null) return null;
        return YQuadratureDecoder.FindQuadratureDecoder(next_hwid);
    }

    /**
     * Starts the enumeration of quadrature decoders currently accessible.
     * Use the method YQuadratureDecoder.nextQuadratureDecoder() to iterate on
     * next quadrature decoders.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YQuadratureDecoder} a pointer to a YQuadratureDecoder object, corresponding to
     *         the first quadrature decoder currently online, or a null pointer
     *         if there are none.
     */
    static FirstQuadratureDecoderInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('QuadratureDecoder');
        if (next_hwid == null) return null;
        return YQuadratureDecoder.FindQuadratureDecoderInContext(yctx, next_hwid);
    }

    //--- (end of YQuadratureDecoder implementation)
}

exports.YQuadratureDecoder = YQuadratureDecoder; //--- (QuadratureDecoder functions)

/**
 * comment from .yc definition
 */

function yFindQuadratureDecoder(func) {
    return YQuadratureDecoder.FindQuadratureDecoder(func);
}

/**
 * comment from .yc definition
 */
function yFirstQuadratureDecoder() {
    return YQuadratureDecoder.FirstQuadratureDecoder();
}

//--- (end of QuadratureDecoder functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for RealTimeClock functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YRealTimeClock = exports.Y_UTCOFFSET_INVALID = exports.Y_DATETIME_INVALID = exports.Y_UNIXTIME_INVALID = exports.Y_TIMESET_INVALID = exports.Y_TIMESET_TRUE = exports.Y_TIMESET_FALSE = undefined;
exports.yFindRealTimeClock = yFindRealTimeClock;
exports.yFirstRealTimeClock = yFirstRealTimeClock;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YRealTimeClock return codes)
//--- (end of YRealTimeClock return codes)
//--- (YRealTimeClock definitions)
const Y_TIMESET_FALSE = exports.Y_TIMESET_FALSE = 0;
const Y_TIMESET_TRUE = exports.Y_TIMESET_TRUE = 1;
const Y_TIMESET_INVALID = exports.Y_TIMESET_INVALID = -1;
const Y_UNIXTIME_INVALID = exports.Y_UNIXTIME_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_DATETIME_INVALID = exports.Y_DATETIME_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_UTCOFFSET_INVALID = exports.Y_UTCOFFSET_INVALID = _yocto_api.YAPI.INVALID_INT;
//--- (end of YRealTimeClock definitions)

//--- (YRealTimeClock class start)
/**
 * YRealTimeClock Class: Real Time Clock function interface
 *
 * The RealTimeClock function maintains and provides current date and time, even accross power cut
 * lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler.
 * The current time may represent a local time as well as an UTC time, but no automatic time change
 * will occur to account for daylight saving time.
 */
//--- (end of YRealTimeClock class start)

class YRealTimeClock extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YRealTimeClock constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'RealTimeClock';
        /** @member {number} **/
        this._unixTime = Y_UNIXTIME_INVALID;
        /** @member {string} **/
        this._dateTime = Y_DATETIME_INVALID;
        /** @member {number} **/
        this._utcOffset = Y_UTCOFFSET_INVALID;
        /** @member {number} **/
        this._timeSet = Y_TIMESET_INVALID;
        this.imm_setConst({
            UNIXTIME_INVALID: _yocto_api.YAPI.INVALID_LONG,
            DATETIME_INVALID: _yocto_api.YAPI.INVALID_STRING,
            UTCOFFSET_INVALID: _yocto_api.YAPI.INVALID_INT,
            TIMESET_FALSE: 0,
            TIMESET_TRUE: 1,
            TIMESET_INVALID: -1
        });
        //--- (end of YRealTimeClock constructor)
    }

    //--- (YRealTimeClock implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'unixTime':
                this._unixTime = parseInt(val);
                return 1;
            case 'dateTime':
                this._dateTime = val;
                return 1;
            case 'utcOffset':
                this._utcOffset = parseInt(val);
                return 1;
            case 'timeSet':
                this._timeSet = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).
     *
     * @return {number} an integer corresponding to the current time in Unix format (number of elapsed
     * seconds since Jan 1st, 1970)
     *
     * On failure, throws an exception or returns YRealTimeClock.UNIXTIME_INVALID.
     */
    get_unixTime() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_UNIXTIME_INVALID;
                }
            }
            return _this._unixTime;
        })();
    }

    /**
     * Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).
     *
     * @param newval {number} : an integer corresponding to the current time
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_unixTime(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('unixTime', rest_val);
        })();
    }

    /**
     * Returns the current time in the form "YYYY/MM/DD hh:mm:ss"
     *
     * @return {string} a string corresponding to the current time in the form "YYYY/MM/DD hh:mm:ss"
     *
     * On failure, throws an exception or returns YRealTimeClock.DATETIME_INVALID.
     */
    get_dateTime() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DATETIME_INVALID;
                }
            }
            return _this3._dateTime;
        })();
    }

    /**
     * Returns the number of seconds between current time and UTC time (time zone).
     *
     * @return {number} an integer corresponding to the number of seconds between current time and UTC time (time zone)
     *
     * On failure, throws an exception or returns YRealTimeClock.UTCOFFSET_INVALID.
     */
    get_utcOffset() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_UTCOFFSET_INVALID;
                }
            }
            return _this4._utcOffset;
        })();
    }

    /**
     * Changes the number of seconds between current time and UTC time (time zone).
     * The timezone is automatically rounded to the nearest multiple of 15 minutes.
     *
     * @param newval {number} : an integer corresponding to the number of seconds between current time and
     * UTC time (time zone)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_utcOffset(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this5._setAttr('utcOffset', rest_val);
        })();
    }

    /**
     * Returns true if the clock has been set, and false otherwise.
     *
     * @return {number} either YRealTimeClock.TIMESET_FALSE or YRealTimeClock.TIMESET_TRUE, according to
     * true if the clock has been set, and false otherwise
     *
     * On failure, throws an exception or returns YRealTimeClock.TIMESET_INVALID.
     */
    get_timeSet() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TIMESET_INVALID;
                }
            }
            return _this6._timeSet;
        })();
    }

    /**
     * Retrieves a clock for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the clock is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRealTimeClock.isOnline() to test if the clock is
     * indeed online at a given time. In case of ambiguity when looking for
     * a clock by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the clock
     *
     * @return {YRealTimeClock} a YRealTimeClock object allowing you to drive the clock.
     */
    static FindRealTimeClock(func) {
        /** @type {YRealTimeClock} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('RealTimeClock', func);
        if (obj == null) {
            obj = new YRealTimeClock(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('RealTimeClock', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a clock for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the clock is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRealTimeClock.isOnline() to test if the clock is
     * indeed online at a given time. In case of ambiguity when looking for
     * a clock by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the clock
     *
     * @return {YRealTimeClock} a YRealTimeClock object allowing you to drive the clock.
     */
    static FindRealTimeClockInContext(yctx, func) {
        /** @type {YRealTimeClock} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'RealTimeClock', func);
        if (obj == null) {
            obj = new YRealTimeClock(yctx, func);
            _yocto_api.YFunction._AddToCache('RealTimeClock', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of clocks started using yFirstRealTimeClock().
     *
     * @return {YRealTimeClock} a pointer to a YRealTimeClock object, corresponding to
     *         a clock currently online, or a null pointer
     *         if there are no more clocks to enumerate.
     */
    /* */nextRealTimeClock() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YRealTimeClock.FindRealTimeClockInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of clocks currently accessible.
     * Use the method YRealTimeClock.nextRealTimeClock() to iterate on
     * next clocks.
     *
     * @return {YRealTimeClock} a pointer to a YRealTimeClock object, corresponding to
     *         the first clock currently online, or a null pointer
     *         if there are none.
     */
    static FirstRealTimeClock() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('RealTimeClock');
        if (next_hwid == null) return null;
        return YRealTimeClock.FindRealTimeClock(next_hwid);
    }

    /**
     * Starts the enumeration of clocks currently accessible.
     * Use the method YRealTimeClock.nextRealTimeClock() to iterate on
     * next clocks.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YRealTimeClock} a pointer to a YRealTimeClock object, corresponding to
     *         the first clock currently online, or a null pointer
     *         if there are none.
     */
    static FirstRealTimeClockInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('RealTimeClock');
        if (next_hwid == null) return null;
        return YRealTimeClock.FindRealTimeClockInContext(yctx, next_hwid);
    }

    //--- (end of YRealTimeClock implementation)
}

exports.YRealTimeClock = YRealTimeClock; //--- (RealTimeClock functions)

/**
 * comment from .yc definition
 */

function yFindRealTimeClock(func) {
    return YRealTimeClock.FindRealTimeClock(func);
}

/**
 * comment from .yc definition
 */
function yFirstRealTimeClock() {
    return YRealTimeClock.FirstRealTimeClock();
}

//--- (end of RealTimeClock functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for RefFrame functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YRefFrame = exports.Y_CALIBRATIONPARAM_INVALID = exports.Y_BEARING_INVALID = exports.Y_MOUNTPOS_INVALID = exports.Y_MOUNTORIENTATION_NINE = exports.Y_MOUNTORIENTATION_SIX = exports.Y_MOUNTORIENTATION_THREE = exports.Y_MOUNTORIENTATION_TWELVE = exports.Y_MOUNTPOSITION_LEFT = exports.Y_MOUNTPOSITION_RIGHT = exports.Y_MOUNTPOSITION_REAR = exports.Y_MOUNTPOSITION_FRONT = exports.Y_MOUNTPOSITION_TOP = exports.Y_MOUNTPOSITION_BOTTOM = undefined;
exports.yFindRefFrame = yFindRefFrame;
exports.yFirstRefFrame = yFirstRefFrame;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YRefFrame return codes)
//--- (end of YRefFrame return codes)
//--- (YRefFrame definitions)
const Y_MOUNTPOSITION_BOTTOM = exports.Y_MOUNTPOSITION_BOTTOM = 0;
const Y_MOUNTPOSITION_TOP = exports.Y_MOUNTPOSITION_TOP = 1;
const Y_MOUNTPOSITION_FRONT = exports.Y_MOUNTPOSITION_FRONT = 2;
const Y_MOUNTPOSITION_REAR = exports.Y_MOUNTPOSITION_REAR = 3;
const Y_MOUNTPOSITION_RIGHT = exports.Y_MOUNTPOSITION_RIGHT = 4;
const Y_MOUNTPOSITION_LEFT = exports.Y_MOUNTPOSITION_LEFT = 5;
const Y_MOUNTORIENTATION_TWELVE = exports.Y_MOUNTORIENTATION_TWELVE = 0;
const Y_MOUNTORIENTATION_THREE = exports.Y_MOUNTORIENTATION_THREE = 1;
const Y_MOUNTORIENTATION_SIX = exports.Y_MOUNTORIENTATION_SIX = 2;
const Y_MOUNTORIENTATION_NINE = exports.Y_MOUNTORIENTATION_NINE = 3;
const Y_MOUNTPOS_INVALID = exports.Y_MOUNTPOS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_BEARING_INVALID = exports.Y_BEARING_INVALID = _yocto_api.YAPI.INVALID_DOUBLE;
const Y_CALIBRATIONPARAM_INVALID = exports.Y_CALIBRATIONPARAM_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YRefFrame definitions)

//--- (YRefFrame class start)
/**
 * YRefFrame Class: Reference frame configuration
 *
 * This class is used to setup the base orientation of the Yocto-3D, so that
 * the orientation functions, relative to the earth surface plane, use
 * the proper reference frame. The class also implements a tridimensional
 * sensor calibration process, which can compensate for local variations
 * of standard gravity and improve the precision of the tilt sensors.
 */
//--- (end of YRefFrame class start)

class YRefFrame extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YRefFrame constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'RefFrame';
        /** @member {number} **/
        this._mountPos = Y_MOUNTPOS_INVALID;
        /** @member {number} **/
        this._bearing = Y_BEARING_INVALID;
        /** @member {string} **/
        this._calibrationParam = Y_CALIBRATIONPARAM_INVALID;
        /** @member {number} **/
        this._calibStage = 0;
        /** @member {string} **/
        this._calibStageHint = '';
        /** @member {number} **/
        this._calibStageProgress = 0;
        /** @member {number} **/
        this._calibProgress = 0;
        /** @member {string} **/
        this._calibLogMsg = '';
        /** @member {string} **/
        this._calibSavedParams = '';
        /** @member {number} **/
        this._calibCount = 0;
        /** @member {number} **/
        this._calibInternalPos = 0;
        /** @member {number} **/
        this._calibPrevTick = 0;
        /** @member {number[]} **/
        this._calibOrient = [];
        /** @member {number[]} **/
        this._calibDataAccX = [];
        /** @member {number[]} **/
        this._calibDataAccY = [];
        /** @member {number[]} **/
        this._calibDataAccZ = [];
        /** @member {number[]} **/
        this._calibDataAcc = [];
        /** @member {number} **/
        this._calibAccXOfs = 0;
        /** @member {number} **/
        this._calibAccYOfs = 0;
        /** @member {number} **/
        this._calibAccZOfs = 0;
        /** @member {number} **/
        this._calibAccXScale = 0;
        /** @member {number} **/
        this._calibAccYScale = 0;
        /** @member {number} **/
        this._calibAccZScale = 0;
        this.imm_setConst({
            MOUNTPOS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            BEARING_INVALID: _yocto_api.YAPI.INVALID_DOUBLE,
            CALIBRATIONPARAM_INVALID: _yocto_api.YAPI.INVALID_STRING,
            MOUNTPOSITION_BOTTOM: 0,
            MOUNTPOSITION_TOP: 1,
            MOUNTPOSITION_FRONT: 2,
            MOUNTPOSITION_REAR: 3,
            MOUNTPOSITION_RIGHT: 4,
            MOUNTPOSITION_LEFT: 5,
            MOUNTORIENTATION_TWELVE: 0,
            MOUNTORIENTATION_THREE: 1,
            MOUNTORIENTATION_SIX: 2,
            MOUNTORIENTATION_NINE: 3
        });
        //--- (end of YRefFrame constructor)
    }

    //--- (YRefFrame implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'mountPos':
                this._mountPos = parseInt(val);
                return 1;
            case 'bearing':
                this._bearing = Math.round(val * 1000.0 / 65536.0) / 1000.0;
                return 1;
            case 'calibrationParam':
                this._calibrationParam = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    get_mountPos() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MOUNTPOS_INVALID;
                }
            }
            return _this._mountPos;
        })();
    }

    set_mountPos(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('mountPos', rest_val);
        })();
    }

    /**
     * Changes the reference bearing used by the compass. The relative bearing
     * indicated by the compass is the difference between the measured magnetic
     * heading and the reference bearing indicated here.
     *
     * For instance, if you setup as reference bearing the value of the earth
     * magnetic declination, the compass will provide the orientation relative
     * to the geographic North.
     *
     * Similarly, when the sensor is not mounted along the standard directions
     * because it has an additional yaw angle, you can set this angle in the reference
     * bearing so that the compass provides the expected natural direction.
     *
     * Remember to call the saveToFlash()
     * method of the module if the modification must be kept.
     *
     * @param newval {number} : a floating point number corresponding to the reference bearing used by the compass
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_bearing(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(Math.round(newval * 65536.0));
            return yield _this3._setAttr('bearing', rest_val);
        })();
    }

    /**
     * Returns the reference bearing used by the compass. The relative bearing
     * indicated by the compass is the difference between the measured magnetic
     * heading and the reference bearing indicated here.
     *
     * @return {number} a floating point number corresponding to the reference bearing used by the compass
     *
     * On failure, throws an exception or returns YRefFrame.BEARING_INVALID.
     */
    get_bearing() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_BEARING_INVALID;
                }
            }
            return _this4._bearing;
        })();
    }

    get_calibrationParam() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CALIBRATIONPARAM_INVALID;
                }
            }
            return _this5._calibrationParam;
        })();
    }

    set_calibrationParam(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this6._setAttr('calibrationParam', rest_val);
        })();
    }

    /**
     * Retrieves a reference frame for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the reference frame is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRefFrame.isOnline() to test if the reference frame is
     * indeed online at a given time. In case of ambiguity when looking for
     * a reference frame by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the reference frame
     *
     * @return {YRefFrame} a YRefFrame object allowing you to drive the reference frame.
     */
    static FindRefFrame(func) {
        /** @type {YRefFrame} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('RefFrame', func);
        if (obj == null) {
            obj = new YRefFrame(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('RefFrame', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a reference frame for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the reference frame is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRefFrame.isOnline() to test if the reference frame is
     * indeed online at a given time. In case of ambiguity when looking for
     * a reference frame by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the reference frame
     *
     * @return {YRefFrame} a YRefFrame object allowing you to drive the reference frame.
     */
    static FindRefFrameInContext(yctx, func) {
        /** @type {YRefFrame} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'RefFrame', func);
        if (obj == null) {
            obj = new YRefFrame(yctx, func);
            _yocto_api.YFunction._AddToCache('RefFrame', func, obj);
        }
        return obj;
    }

    /**
     * Returns the installation position of the device, as configured
     * in order to define the reference frame for the compass and the
     * pitch/roll tilt sensors.
     *
     * @return {MOUNTPOSITION} a value among the YRefFrame.MOUNTPOSITION enumeration
     *         (YRefFrame.MOUNTPOSITION_BOTTOM,   YRefFrame.MOUNTPOSITION_TOP,
     *         YRefFrame.MOUNTPOSITION_FRONT,    YRefFrame.MOUNTPOSITION_RIGHT,
     *         YRefFrame.MOUNTPOSITION_REAR,     YRefFrame.MOUNTPOSITION_LEFT),
     *         corresponding to the installation in a box, on one of the six faces.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_mountPosition() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let position;
            position = yield _this7.get_mountPos();
            return position >> 2;
        })();
    }

    /**
     * Returns the installation orientation of the device, as configured
     * in order to define the reference frame for the compass and the
     * pitch/roll tilt sensors.
     *
     * @return {MOUNTORIENTATION} a value among the enumeration YRefFrame.MOUNTORIENTATION
     *         (YRefFrame.MOUNTORIENTATION_TWELVE, YRefFrame.MOUNTORIENTATION_THREE,
     *         YRefFrame.MOUNTORIENTATION_SIX,     YRefFrame.MOUNTORIENTATION_NINE)
     *         corresponding to the orientation of the "X" arrow on the device,
     *         as on a clock dial seen from an observer in the center of the box.
     *         On the bottom face, the 12H orientation points to the front, while
     *         on the top face, the 12H orientation points to the rear.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_mountOrientation() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let position;
            position = yield _this8.get_mountPos();
            return position & 3;
        })();
    }

    /**
     * Changes the compass and tilt sensor frame of reference. The magnetic compass
     * and the tilt sensors (pitch and roll) naturally work in the plane
     * parallel to the earth surface. In case the device is not installed upright
     * and horizontally, you must select its reference orientation (parallel to
     * the earth surface) so that the measures are made relative to this position.
     *
     * @param position {MOUNTPOSITION} : a value among the YRefFrame.MOUNTPOSITION enumeration
     *         (YRefFrame.MOUNTPOSITION_BOTTOM,   YRefFrame.MOUNTPOSITION_TOP,
     *         YRefFrame.MOUNTPOSITION_FRONT,    YRefFrame.MOUNTPOSITION_RIGHT,
     *         YRefFrame.MOUNTPOSITION_REAR,     YRefFrame.MOUNTPOSITION_LEFT),
     *         corresponding to the installation in a box, on one of the six faces.
     * @param orientation {MOUNTORIENTATION} : a value among the enumeration YRefFrame.MOUNTORIENTATION
     *         (YRefFrame.MOUNTORIENTATION_TWELVE, YRefFrame.MOUNTORIENTATION_THREE,
     *         YRefFrame.MOUNTORIENTATION_SIX,     YRefFrame.MOUNTORIENTATION_NINE)
     *         corresponding to the orientation of the "X" arrow on the device,
     *         as on a clock dial seen from an observer in the center of the box.
     *         On the bottom face, the 12H orientation points to the front, while
     *         on the top face, the 12H orientation points to the rear.
     *
     * Remember to call the saveToFlash()
     * method of the module if the modification must be kept.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_mountPosition(position, orientation) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let mixedPos;
            mixedPos = (position << 2) + orientation;
            return yield _this9.set_mountPos(mixedPos);
        })();
    }

    _calibSort(start, stopidx) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let changed;
            /** @type {number} **/
            let a;
            /** @type {number} **/
            let b;
            /** @type {number} **/
            let xa;
            /** @type {number} **/
            let xb;
            // bubble sort is good since we will re-sort again after offset adjustment
            changed = 1;
            while (changed > 0) {
                changed = 0;
                a = _this10._calibDataAcc[start];
                idx = start + 1;
                while (idx < stopidx) {
                    b = _this10._calibDataAcc[idx];
                    if (a > b) {
                        _this10._calibDataAcc[idx - 1] = b;
                        _this10._calibDataAcc[idx] = a;
                        xa = _this10._calibDataAccX[idx - 1];
                        xb = _this10._calibDataAccX[idx];
                        _this10._calibDataAccX[idx - 1] = xb;
                        _this10._calibDataAccX[idx] = xa;
                        xa = _this10._calibDataAccY[idx - 1];
                        xb = _this10._calibDataAccY[idx];
                        _this10._calibDataAccY[idx - 1] = xb;
                        _this10._calibDataAccY[idx] = xa;
                        xa = _this10._calibDataAccZ[idx - 1];
                        xb = _this10._calibDataAccZ[idx];
                        _this10._calibDataAccZ[idx - 1] = xb;
                        _this10._calibDataAccZ[idx] = xa;
                        changed = changed + 1;
                    } else {
                        a = b;
                    }
                    idx = idx + 1;
                }
            }
            return 0;
        })();
    }

    /**
     * Initiates the sensors tridimensional calibration process.
     * This calibration is used at low level for inertial position estimation
     * and to enhance the precision of the tilt sensors.
     *
     * After calling this method, the device should be moved according to the
     * instructions provided by method get_3DCalibrationHint,
     * and more3DCalibration should be invoked about 5 times per second.
     * The calibration procedure is completed when the method
     * get_3DCalibrationProgress returns 100. At this point,
     * the computed calibration parameters can be applied using method
     * save3DCalibration. The calibration process can be canceled
     * at any time using method cancel3DCalibration.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    start3DCalibration() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (!(yield _this11.isOnline())) {
                return YAPI_DEVICE_NOT_FOUND;
            }
            if (_this11._calibStage != 0) {
                yield _this11.cancel3DCalibration();
            }
            _this11._calibSavedParams = yield _this11.get_calibrationParam();
            yield _this11.set_calibrationParam('0');
            _this11._calibCount = 50;
            _this11._calibStage = 1;
            _this11._calibStageHint = 'Set down the device on a steady horizontal surface';
            _this11._calibStageProgress = 0;
            _this11._calibProgress = 1;
            _this11._calibInternalPos = 0;
            _this11._calibPrevTick = _this11._yapi.GetTickCount() & 0x7FFFFFFF;
            _this11._calibOrient.length = 0;
            _this11._calibDataAccX.length = 0;
            _this11._calibDataAccY.length = 0;
            _this11._calibDataAccZ.length = 0;
            _this11._calibDataAcc.length = 0;
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Continues the sensors tridimensional calibration process previously
     * initiated using method start3DCalibration.
     * This method should be called approximately 5 times per second, while
     * positioning the device according to the instructions provided by method
     * get_3DCalibrationHint. Note that the instructions change during
     * the calibration process.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    more3DCalibration() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let currTick;
            /** @type {Uint8Array} **/
            let jsonData;
            /** @type {number} **/
            let xVal;
            /** @type {number} **/
            let yVal;
            /** @type {number} **/
            let zVal;
            /** @type {number} **/
            let xSq;
            /** @type {number} **/
            let ySq;
            /** @type {number} **/
            let zSq;
            /** @type {number} **/
            let norm;
            /** @type {number} **/
            let orient;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let intpos;
            /** @type {number} **/
            let err;
            // make sure calibration has been started
            if (_this12._calibStage == 0) {
                return YAPI_INVALID_ARGUMENT;
            }
            if (_this12._calibProgress == 100) {
                return _yocto_api.YAPI_SUCCESS;
            }
            // make sure we leave at least 160ms between samples
            currTick = _this12._yapi.GetTickCount() & 0x7FFFFFFF;
            if ((currTick - _this12._calibPrevTick & 0x7FFFFFFF) < 160) {
                return _yocto_api.YAPI_SUCCESS;
            }
            // load current accelerometer values, make sure we are on a straight angle
            // (default timeout to 0,5 sec without reading measure when out of range)
            _this12._calibStageHint = 'Set down the device on a steady horizontal surface';
            _this12._calibPrevTick = currTick + 500 & 0x7FFFFFFF;
            jsonData = yield _this12._download('api/accelerometer.json');
            xVal = _this12._yapi.imm_atoi(_this12.imm_json_get_key(jsonData, 'xValue')) / 65536.0;
            yVal = _this12._yapi.imm_atoi(_this12.imm_json_get_key(jsonData, 'yValue')) / 65536.0;
            zVal = _this12._yapi.imm_atoi(_this12.imm_json_get_key(jsonData, 'zValue')) / 65536.0;
            xSq = xVal * xVal;
            if (xSq >= 0.04 && xSq < 0.64) {
                return _yocto_api.YAPI_SUCCESS;
            }
            if (xSq >= 1.44) {
                return _yocto_api.YAPI_SUCCESS;
            }
            ySq = yVal * yVal;
            if (ySq >= 0.04 && ySq < 0.64) {
                return _yocto_api.YAPI_SUCCESS;
            }
            if (ySq >= 1.44) {
                return _yocto_api.YAPI_SUCCESS;
            }
            zSq = zVal * zVal;
            if (zSq >= 0.04 && zSq < 0.64) {
                return _yocto_api.YAPI_SUCCESS;
            }
            if (zSq >= 1.44) {
                return _yocto_api.YAPI_SUCCESS;
            }
            norm = Math.sqrt(xSq + ySq + zSq);
            if (norm < 0.8 || norm > 1.2) {
                return _yocto_api.YAPI_SUCCESS;
            }
            _this12._calibPrevTick = currTick;
            // Determine the device orientation index
            orient = 0;
            if (zSq > 0.5) {
                if (zVal > 0) {
                    orient = 0;
                } else {
                    orient = 1;
                }
            }
            if (xSq > 0.5) {
                if (xVal > 0) {
                    orient = 2;
                } else {
                    orient = 3;
                }
            }
            if (ySq > 0.5) {
                if (yVal > 0) {
                    orient = 4;
                } else {
                    orient = 5;
                }
            }
            // Discard measures that are not in the proper orientation
            if (_this12._calibStageProgress == 0) {
                idx = 0;
                err = 0;
                while (idx + 1 < _this12._calibStage) {
                    if (_this12._calibOrient[idx] == orient) {
                        err = 1;
                    }
                    idx = idx + 1;
                }
                if (err != 0) {
                    _this12._calibStageHint = 'Turn the device on another face';
                    return _yocto_api.YAPI_SUCCESS;
                }
                _this12._calibOrient.push(orient);
            } else {
                if (orient != _this12._calibOrient[_this12._calibStage - 1]) {
                    _this12._calibStageHint = 'Not yet done, please move back to the previous face';
                    return _yocto_api.YAPI_SUCCESS;
                }
            }
            // Save measure
            _this12._calibStageHint = 'calibrating..';
            _this12._calibDataAccX.push(xVal);
            _this12._calibDataAccY.push(yVal);
            _this12._calibDataAccZ.push(zVal);
            _this12._calibDataAcc.push(norm);
            _this12._calibInternalPos = _this12._calibInternalPos + 1;
            _this12._calibProgress = 1 + 16 * (_this12._calibStage - 1) + parseInt(16 * _this12._calibInternalPos / _this12._calibCount, 10);
            if (_this12._calibInternalPos < _this12._calibCount) {
                _this12._calibStageProgress = 1 + parseInt(99 * _this12._calibInternalPos / _this12._calibCount, 10);
                return _yocto_api.YAPI_SUCCESS;
            }
            // Stage done, compute preliminary result
            intpos = (_this12._calibStage - 1) * _this12._calibCount;
            yield _this12._calibSort(intpos, intpos + _this12._calibCount);
            intpos = intpos + parseInt(_this12._calibCount / 2, 10);
            _this12._calibLogMsg = 'Stage ' + String(Math.round(_this12._calibStage)) + ': median is ' + String(Math.round(Math.round(1000 * _this12._calibDataAccX[intpos]))) + ',' + String(Math.round(Math.round(1000 * _this12._calibDataAccY[intpos]))) + ',' + String(Math.round(Math.round(1000 * _this12._calibDataAccZ[intpos])));
            // move to next stage
            _this12._calibStage = _this12._calibStage + 1;
            if (_this12._calibStage < 7) {
                _this12._calibStageHint = 'Turn the device on another face';
                _this12._calibPrevTick = currTick + 500 & 0x7FFFFFFF;
                _this12._calibStageProgress = 0;
                _this12._calibInternalPos = 0;
                return _yocto_api.YAPI_SUCCESS;
            }
            // Data collection completed, compute accelerometer shift
            xVal = 0;
            yVal = 0;
            zVal = 0;
            idx = 0;
            while (idx < 6) {
                intpos = idx * _this12._calibCount + parseInt(_this12._calibCount / 2, 10);
                orient = _this12._calibOrient[idx];
                if (orient == 0 || orient == 1) {
                    zVal = zVal + _this12._calibDataAccZ[intpos];
                }
                if (orient == 2 || orient == 3) {
                    xVal = xVal + _this12._calibDataAccX[intpos];
                }
                if (orient == 4 || orient == 5) {
                    yVal = yVal + _this12._calibDataAccY[intpos];
                }
                idx = idx + 1;
            }
            _this12._calibAccXOfs = xVal / 2.0;
            _this12._calibAccYOfs = yVal / 2.0;
            _this12._calibAccZOfs = zVal / 2.0;
            // Recompute all norms, taking into account the computed shift, and re-sort
            intpos = 0;
            while (intpos < _this12._calibDataAcc.length) {
                xVal = _this12._calibDataAccX[intpos] - _this12._calibAccXOfs;
                yVal = _this12._calibDataAccY[intpos] - _this12._calibAccYOfs;
                zVal = _this12._calibDataAccZ[intpos] - _this12._calibAccZOfs;
                norm = Math.sqrt(xVal * xVal + yVal * yVal + zVal * zVal);
                _this12._calibDataAcc[intpos] = norm;
                intpos = intpos + 1;
            }
            idx = 0;
            while (idx < 6) {
                intpos = idx * _this12._calibCount;
                yield _this12._calibSort(intpos, intpos + _this12._calibCount);
                idx = idx + 1;
            }
            // Compute the scaling factor for each axis
            xVal = 0;
            yVal = 0;
            zVal = 0;
            idx = 0;
            while (idx < 6) {
                intpos = idx * _this12._calibCount + parseInt(_this12._calibCount / 2, 10);
                orient = _this12._calibOrient[idx];
                if (orient == 0 || orient == 1) {
                    zVal = zVal + _this12._calibDataAcc[intpos];
                }
                if (orient == 2 || orient == 3) {
                    xVal = xVal + _this12._calibDataAcc[intpos];
                }
                if (orient == 4 || orient == 5) {
                    yVal = yVal + _this12._calibDataAcc[intpos];
                }
                idx = idx + 1;
            }
            _this12._calibAccXScale = xVal / 2.0;
            _this12._calibAccYScale = yVal / 2.0;
            _this12._calibAccZScale = zVal / 2.0;
            // Report completion
            _this12._calibProgress = 100;
            _this12._calibStageHint = 'Calibration data ready for saving';
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Returns instructions to proceed to the tridimensional calibration initiated with
     * method start3DCalibration.
     *
     * @return {string} a character string.
     */
    get_3DCalibrationHint() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            return _this13._calibStageHint;
        })();
    }

    /**
     * Returns the global process indicator for the tridimensional calibration
     * initiated with method start3DCalibration.
     *
     * @return {number} an integer between 0 (not started) and 100 (stage completed).
     */
    get_3DCalibrationProgress() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            return _this14._calibProgress;
        })();
    }

    /**
     * Returns index of the current stage of the calibration
     * initiated with method start3DCalibration.
     *
     * @return {number} an integer, growing each time a calibration stage is completed.
     */
    get_3DCalibrationStage() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            return _this15._calibStage;
        })();
    }

    /**
     * Returns the process indicator for the current stage of the calibration
     * initiated with method start3DCalibration.
     *
     * @return {number} an integer between 0 (not started) and 100 (stage completed).
     */
    get_3DCalibrationStageProgress() {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            return _this16._calibStageProgress;
        })();
    }

    /**
     * Returns the latest log message from the calibration process.
     * When no new message is available, returns an empty string.
     *
     * @return {string} a character string.
     */
    get_3DCalibrationLogMsg() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let msg;
            msg = _this17._calibLogMsg;
            _this17._calibLogMsg = '';
            return msg;
        })();
    }

    /**
     * Applies the sensors tridimensional calibration parameters that have just been computed.
     * Remember to call the saveToFlash()  method of the module if the changes
     * must be kept when the device is restarted.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    save3DCalibration() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let shiftX;
            /** @type {number} **/
            let shiftY;
            /** @type {number} **/
            let shiftZ;
            /** @type {number} **/
            let scaleExp;
            /** @type {number} **/
            let scaleX;
            /** @type {number} **/
            let scaleY;
            /** @type {number} **/
            let scaleZ;
            /** @type {number} **/
            let scaleLo;
            /** @type {number} **/
            let scaleHi;
            /** @type {string} **/
            let newcalib;
            if (_this18._calibProgress != 100) {
                return YAPI_INVALID_ARGUMENT;
            }
            // Compute integer values (correction unit is 732ug/count)
            shiftX = -Math.round(_this18._calibAccXOfs / 0.000732);
            if (shiftX < 0) {
                shiftX = shiftX + 65536;
            }
            shiftY = -Math.round(_this18._calibAccYOfs / 0.000732);
            if (shiftY < 0) {
                shiftY = shiftY + 65536;
            }
            shiftZ = -Math.round(_this18._calibAccZOfs / 0.000732);
            if (shiftZ < 0) {
                shiftZ = shiftZ + 65536;
            }
            scaleX = Math.round(2048.0 / _this18._calibAccXScale) - 2048;
            scaleY = Math.round(2048.0 / _this18._calibAccYScale) - 2048;
            scaleZ = Math.round(2048.0 / _this18._calibAccZScale) - 2048;
            if (scaleX < -2048 || scaleX >= 2048 || scaleY < -2048 || scaleY >= 2048 || scaleZ < -2048 || scaleZ >= 2048) {
                scaleExp = 3;
            } else {
                if (scaleX < -1024 || scaleX >= 1024 || scaleY < -1024 || scaleY >= 1024 || scaleZ < -1024 || scaleZ >= 1024) {
                    scaleExp = 2;
                } else {
                    if (scaleX < -512 || scaleX >= 512 || scaleY < -512 || scaleY >= 512 || scaleZ < -512 || scaleZ >= 512) {
                        scaleExp = 1;
                    } else {
                        scaleExp = 0;
                    }
                }
            }
            if (scaleExp > 0) {
                scaleX = scaleX >> scaleExp;
                scaleY = scaleY >> scaleExp;
                scaleZ = scaleZ >> scaleExp;
            }
            if (scaleX < 0) {
                scaleX = scaleX + 1024;
            }
            if (scaleY < 0) {
                scaleY = scaleY + 1024;
            }
            if (scaleZ < 0) {
                scaleZ = scaleZ + 1024;
            }
            scaleLo = ((scaleY & 15) << 12) + (scaleX << 2) + scaleExp;
            scaleHi = (scaleZ << 6) + (scaleY >> 4);
            // Save calibration parameters
            newcalib = '5,' + String(Math.round(shiftX)) + ',' + String(Math.round(shiftY)) + ',' + String(Math.round(shiftZ)) + ',' + String(Math.round(scaleLo)) + ',' + String(Math.round(scaleHi));
            _this18._calibStage = 0;
            return yield _this18.set_calibrationParam(newcalib);
        })();
    }

    /**
     * Aborts the sensors tridimensional calibration process et restores normal settings.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    cancel3DCalibration() {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            if (_this19._calibStage == 0) {
                return _yocto_api.YAPI_SUCCESS;
            }
            // may throw an exception
            _this19._calibStage = 0;
            return yield _this19.set_calibrationParam(_this19._calibSavedParams);
        })();
    }

    /**
     * Continues the enumeration of reference frames started using yFirstRefFrame().
     *
     * @return {YRefFrame} a pointer to a YRefFrame object, corresponding to
     *         a reference frame currently online, or a null pointer
     *         if there are no more reference frames to enumerate.
     */
    /* */nextRefFrame() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YRefFrame.FindRefFrameInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of reference frames currently accessible.
     * Use the method YRefFrame.nextRefFrame() to iterate on
     * next reference frames.
     *
     * @return {YRefFrame} a pointer to a YRefFrame object, corresponding to
     *         the first reference frame currently online, or a null pointer
     *         if there are none.
     */
    static FirstRefFrame() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('RefFrame');
        if (next_hwid == null) return null;
        return YRefFrame.FindRefFrame(next_hwid);
    }

    /**
     * Starts the enumeration of reference frames currently accessible.
     * Use the method YRefFrame.nextRefFrame() to iterate on
     * next reference frames.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YRefFrame} a pointer to a YRefFrame object, corresponding to
     *         the first reference frame currently online, or a null pointer
     *         if there are none.
     */
    static FirstRefFrameInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('RefFrame');
        if (next_hwid == null) return null;
        return YRefFrame.FindRefFrameInContext(yctx, next_hwid);
    }

    //--- (end of YRefFrame implementation)
}

exports.YRefFrame = YRefFrame; //--- (RefFrame functions)

/**
 * comment from .yc definition
 */

function yFindRefFrame(func) {
    return YRefFrame.FindRefFrame(func);
}

/**
 * comment from .yc definition
 */
function yFirstRefFrame() {
    return YRefFrame.FirstRefFrame();
}

//--- (end of RefFrame functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Relay functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YRelay = exports.Y_COUNTDOWN_INVALID = exports.Y_DELAYEDPULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = exports.Y_MAXTIMEONSTATEB_INVALID = exports.Y_MAXTIMEONSTATEA_INVALID = exports.Y_OUTPUT_INVALID = exports.Y_OUTPUT_ON = exports.Y_OUTPUT_OFF = exports.Y_STATEATPOWERON_INVALID = exports.Y_STATEATPOWERON_B = exports.Y_STATEATPOWERON_A = exports.Y_STATEATPOWERON_UNCHANGED = exports.Y_STATE_INVALID = exports.Y_STATE_B = exports.Y_STATE_A = undefined;
exports.yFindRelay = yFindRelay;
exports.yFirstRelay = yFirstRelay;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YRelay return codes)
//--- (end of YRelay return codes)
//--- (YRelay definitions)
const Y_STATE_A = exports.Y_STATE_A = 0;
const Y_STATE_B = exports.Y_STATE_B = 1;
const Y_STATE_INVALID = exports.Y_STATE_INVALID = -1;
const Y_STATEATPOWERON_UNCHANGED = exports.Y_STATEATPOWERON_UNCHANGED = 0;
const Y_STATEATPOWERON_A = exports.Y_STATEATPOWERON_A = 1;
const Y_STATEATPOWERON_B = exports.Y_STATEATPOWERON_B = 2;
const Y_STATEATPOWERON_INVALID = exports.Y_STATEATPOWERON_INVALID = -1;
const Y_OUTPUT_OFF = exports.Y_OUTPUT_OFF = 0;
const Y_OUTPUT_ON = exports.Y_OUTPUT_ON = 1;
const Y_OUTPUT_INVALID = exports.Y_OUTPUT_INVALID = -1;
const Y_MAXTIMEONSTATEA_INVALID = exports.Y_MAXTIMEONSTATEA_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_MAXTIMEONSTATEB_INVALID = exports.Y_MAXTIMEONSTATEB_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_PULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_DELAYEDPULSETIMER_INVALID = exports.Y_DELAYEDPULSETIMER_INVALID = null;
const Y_COUNTDOWN_INVALID = exports.Y_COUNTDOWN_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YRelay definitions)

//--- (YRelay class start)
/**
 * YRelay Class: Relay function interface
 *
 * The Yoctopuce application programming interface allows you to switch the relay state.
 * This change is not persistent: the relay will automatically return to its idle position
 * whenever power is lost or if the module is restarted.
 * The library can also generate automatically short pulses of determined duration.
 * On devices with two output for each relay (double throw), the two outputs are named A and B,
 * with output A corresponding to the idle position (at power off) and the output B corresponding to the
 * active state. If you prefer the alternate default state, simply switch your cables on the board.
 */
//--- (end of YRelay class start)

class YRelay extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YRelay constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Relay';
        /** @member {number} **/
        this._state = Y_STATE_INVALID;
        /** @member {number} **/
        this._stateAtPowerOn = Y_STATEATPOWERON_INVALID;
        /** @member {number} **/
        this._maxTimeOnStateA = Y_MAXTIMEONSTATEA_INVALID;
        /** @member {number} **/
        this._maxTimeOnStateB = Y_MAXTIMEONSTATEB_INVALID;
        /** @member {number} **/
        this._output = Y_OUTPUT_INVALID;
        /** @member {number} **/
        this._pulseTimer = Y_PULSETIMER_INVALID;
        /** @member {YDelayedPulse} **/
        this._delayedPulseTimer = Y_DELAYEDPULSETIMER_INVALID;
        /** @member {number} **/
        this._countdown = Y_COUNTDOWN_INVALID;
        this.imm_setConst({
            STATE_A: 0,
            STATE_B: 1,
            STATE_INVALID: -1,
            STATEATPOWERON_UNCHANGED: 0,
            STATEATPOWERON_A: 1,
            STATEATPOWERON_B: 2,
            STATEATPOWERON_INVALID: -1,
            MAXTIMEONSTATEA_INVALID: _yocto_api.YAPI.INVALID_LONG,
            MAXTIMEONSTATEB_INVALID: _yocto_api.YAPI.INVALID_LONG,
            OUTPUT_OFF: 0,
            OUTPUT_ON: 1,
            OUTPUT_INVALID: -1,
            PULSETIMER_INVALID: _yocto_api.YAPI.INVALID_LONG,
            COUNTDOWN_INVALID: _yocto_api.YAPI.INVALID_LONG
        });
        //--- (end of YRelay constructor)
    }

    //--- (YRelay implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'state':
                this._state = parseInt(val);
                return 1;
            case 'stateAtPowerOn':
                this._stateAtPowerOn = parseInt(val);
                return 1;
            case 'maxTimeOnStateA':
                this._maxTimeOnStateA = parseInt(val);
                return 1;
            case 'maxTimeOnStateB':
                this._maxTimeOnStateB = parseInt(val);
                return 1;
            case 'output':
                this._output = parseInt(val);
                return 1;
            case 'pulseTimer':
                this._pulseTimer = parseInt(val);
                return 1;
            case 'delayedPulseTimer':
                this._delayedPulseTimer = val;
                return 1;
            case 'countdown':
                this._countdown = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the state of the relays (A for the idle position, B for the active position).
     *
     * @return {number} either YRelay.STATE_A or YRelay.STATE_B, according to the state of the relays (A
     * for the idle position, B for the active position)
     *
     * On failure, throws an exception or returns YRelay.STATE_INVALID.
     */
    get_state() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STATE_INVALID;
                }
            }
            return _this._state;
        })();
    }

    /**
     * Changes the state of the relays (A for the idle position, B for the active position).
     *
     * @param newval {number} : either YRelay.STATE_A or YRelay.STATE_B, according to the state of the
     * relays (A for the idle position, B for the active position)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_state(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('state', rest_val);
        })();
    }

    /**
     * Returns the state of the relays at device startup (A for the idle position, B for the active
     * position, UNCHANGED for no change).
     *
     * @return {number} a value among YRelay.STATEATPOWERON_UNCHANGED, YRelay.STATEATPOWERON_A and
     * YRelay.STATEATPOWERON_B corresponding to the state of the relays at device startup (A for the idle
     * position, B for the active position, UNCHANGED for no change)
     *
     * On failure, throws an exception or returns YRelay.STATEATPOWERON_INVALID.
     */
    get_stateAtPowerOn() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STATEATPOWERON_INVALID;
                }
            }
            return _this3._stateAtPowerOn;
        })();
    }

    /**
     * Preset the state of the relays at device startup (A for the idle position,
     * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
     * method, otherwise this call will have no effect.
     *
     * @param newval {number} : a value among YRelay.STATEATPOWERON_UNCHANGED, YRelay.STATEATPOWERON_A and
     * YRelay.STATEATPOWERON_B
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_stateAtPowerOn(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('stateAtPowerOn', rest_val);
        })();
    }

    /**
     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
     * switching back in to B state. Zero means no maximum time.
     *
     * @return {number} an integer
     *
     * On failure, throws an exception or returns YRelay.MAXTIMEONSTATEA_INVALID.
     */
    get_maxTimeOnStateA() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MAXTIMEONSTATEA_INVALID;
                }
            }
            return _this5._maxTimeOnStateA;
        })();
    }

    /**
     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
     * switching back in to B state. Use zero for no maximum time.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_maxTimeOnStateA(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('maxTimeOnStateA', rest_val);
        })();
    }

    /**
     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
     * switching back in to A state. Zero means no maximum time.
     *
     * @return {number} an integer
     *
     * On failure, throws an exception or returns YRelay.MAXTIMEONSTATEB_INVALID.
     */
    get_maxTimeOnStateB() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MAXTIMEONSTATEB_INVALID;
                }
            }
            return _this7._maxTimeOnStateB;
        })();
    }

    /**
     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
     * switching back in to A state. Use zero for no maximum time.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_maxTimeOnStateB(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('maxTimeOnStateB', rest_val);
        })();
    }

    /**
     * Returns the output state of the relays, when used as a simple switch (single throw).
     *
     * @return {number} either YRelay.OUTPUT_OFF or YRelay.OUTPUT_ON, according to the output state of the
     * relays, when used as a simple switch (single throw)
     *
     * On failure, throws an exception or returns YRelay.OUTPUT_INVALID.
     */
    get_output() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_OUTPUT_INVALID;
                }
            }
            return _this9._output;
        })();
    }

    /**
     * Changes the output state of the relays, when used as a simple switch (single throw).
     *
     * @param newval {number} : either YRelay.OUTPUT_OFF or YRelay.OUTPUT_ON, according to the output
     * state of the relays, when used as a simple switch (single throw)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_output(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('output', rest_val);
        })();
    }

    /**
     * Returns the number of milliseconds remaining before the relays is returned to idle position
     * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
     *
     * @return {number} an integer corresponding to the number of milliseconds remaining before the relays
     * is returned to idle position
     *         (state A), during a measured pulse generation
     *
     * On failure, throws an exception or returns YRelay.PULSETIMER_INVALID.
     */
    get_pulseTimer() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSETIMER_INVALID;
                }
            }
            return _this11._pulseTimer;
        })();
    }

    set_pulseTimer(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this12._setAttr('pulseTimer', rest_val);
        })();
    }

    /**
     * Sets the relay to output B (active) for a specified duration, then brings it
     * automatically back to output A (idle state).
     *
     * @param ms_duration {number} : pulse duration, in millisecondes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pulse(ms_duration) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(ms_duration);
            return yield _this13._setAttr('pulseTimer', rest_val);
        })();
    }

    get_delayedPulseTimer() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DELAYEDPULSETIMER_INVALID;
                }
            }
            return _this14._delayedPulseTimer;
        })();
    }

    set_delayedPulseTimer(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval.target) + ':' + String(newval.ms);
            return yield _this15._setAttr('delayedPulseTimer', rest_val);
        })();
    }

    /**
     * Schedules a pulse.
     *
     * @param ms_delay {number} : waiting time before the pulse, in millisecondes
     * @param ms_duration {number} : pulse duration, in millisecondes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    delayedPulse(ms_delay, ms_duration) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(ms_delay) + ':' + String(ms_duration);
            return yield _this16._setAttr('delayedPulseTimer', rest_val);
        })();
    }

    /**
     * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
     * When there is no scheduled pulse, returns zero.
     *
     * @return {number} an integer corresponding to the number of milliseconds remaining before a pulse
     * (delayedPulse() call)
     *         When there is no scheduled pulse, returns zero
     *
     * On failure, throws an exception or returns YRelay.COUNTDOWN_INVALID.
     */
    get_countdown() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (_this17._cacheExpiration <= _this17._yapi.GetTickCount()) {
                if ((yield _this17.load(_this17._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COUNTDOWN_INVALID;
                }
            }
            return _this17._countdown;
        })();
    }

    /**
     * Retrieves a relay for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the relay is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRelay.isOnline() to test if the relay is
     * indeed online at a given time. In case of ambiguity when looking for
     * a relay by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the relay
     *
     * @return {YRelay} a YRelay object allowing you to drive the relay.
     */
    static FindRelay(func) {
        /** @type {YRelay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Relay', func);
        if (obj == null) {
            obj = new YRelay(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Relay', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a relay for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the relay is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YRelay.isOnline() to test if the relay is
     * indeed online at a given time. In case of ambiguity when looking for
     * a relay by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the relay
     *
     * @return {YRelay} a YRelay object allowing you to drive the relay.
     */
    static FindRelayInContext(yctx, func) {
        /** @type {YRelay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Relay', func);
        if (obj == null) {
            obj = new YRelay(yctx, func);
            _yocto_api.YFunction._AddToCache('Relay', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of relays started using yFirstRelay().
     *
     * @return {YRelay} a pointer to a YRelay object, corresponding to
     *         a relay currently online, or a null pointer
     *         if there are no more relays to enumerate.
     */
    /* */nextRelay() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YRelay.FindRelayInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of relays currently accessible.
     * Use the method YRelay.nextRelay() to iterate on
     * next relays.
     *
     * @return {YRelay} a pointer to a YRelay object, corresponding to
     *         the first relay currently online, or a null pointer
     *         if there are none.
     */
    static FirstRelay() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Relay');
        if (next_hwid == null) return null;
        return YRelay.FindRelay(next_hwid);
    }

    /**
     * Starts the enumeration of relays currently accessible.
     * Use the method YRelay.nextRelay() to iterate on
     * next relays.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YRelay} a pointer to a YRelay object, corresponding to
     *         the first relay currently online, or a null pointer
     *         if there are none.
     */
    static FirstRelayInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Relay');
        if (next_hwid == null) return null;
        return YRelay.FindRelayInContext(yctx, next_hwid);
    }

    //--- (end of YRelay implementation)
}

exports.YRelay = YRelay; //--- (Relay functions)

/**
 * comment from .yc definition
 */

function yFindRelay(func) {
    return YRelay.FindRelay(func);
}

/**
 * comment from .yc definition
 */
function yFirstRelay() {
    return YRelay.FirstRelay();
}

//--- (end of Relay functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for SegmentedDisplay functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YSegmentedDisplay = exports.Y_DISPLAYEDTEXT_INVALID = exports.Y_DISPLAYMODE_INVALID = exports.Y_DISPLAYMODE_AUTO60 = exports.Y_DISPLAYMODE_AUTO1 = exports.Y_DISPLAYMODE_MANUAL = exports.Y_DISPLAYMODE_DISCONNECTED = undefined;
exports.yFindSegmentedDisplay = yFindSegmentedDisplay;
exports.yFirstSegmentedDisplay = yFirstSegmentedDisplay;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YSegmentedDisplay return codes)
//--- (end of YSegmentedDisplay return codes)
//--- (YSegmentedDisplay definitions)
const Y_DISPLAYMODE_DISCONNECTED = exports.Y_DISPLAYMODE_DISCONNECTED = 0;
const Y_DISPLAYMODE_MANUAL = exports.Y_DISPLAYMODE_MANUAL = 1;
const Y_DISPLAYMODE_AUTO1 = exports.Y_DISPLAYMODE_AUTO1 = 2;
const Y_DISPLAYMODE_AUTO60 = exports.Y_DISPLAYMODE_AUTO60 = 3;
const Y_DISPLAYMODE_INVALID = exports.Y_DISPLAYMODE_INVALID = -1;
const Y_DISPLAYEDTEXT_INVALID = exports.Y_DISPLAYEDTEXT_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YSegmentedDisplay definitions)

//--- (YSegmentedDisplay class start)
/**
 * YSegmentedDisplay Class: SegmentedDisplay function interface
 *
 * The SegmentedDisplay class allows you to drive segmented displays.
 */
//--- (end of YSegmentedDisplay class start)

class YSegmentedDisplay extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YSegmentedDisplay constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'SegmentedDisplay';
        /** @member {string} **/
        this._displayedText = Y_DISPLAYEDTEXT_INVALID;
        /** @member {number} **/
        this._displayMode = Y_DISPLAYMODE_INVALID;
        this.imm_setConst({
            DISPLAYEDTEXT_INVALID: _yocto_api.YAPI.INVALID_STRING,
            DISPLAYMODE_DISCONNECTED: 0,
            DISPLAYMODE_MANUAL: 1,
            DISPLAYMODE_AUTO1: 2,
            DISPLAYMODE_AUTO60: 3,
            DISPLAYMODE_INVALID: -1
        });
        //--- (end of YSegmentedDisplay constructor)
    }

    //--- (YSegmentedDisplay implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'displayedText':
                this._displayedText = val;
                return 1;
            case 'displayMode':
                this._displayMode = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the text currently displayed on the screen.
     *
     * @return {string} a string corresponding to the text currently displayed on the screen
     *
     * On failure, throws an exception or returns YSegmentedDisplay.DISPLAYEDTEXT_INVALID.
     */
    get_displayedText() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISPLAYEDTEXT_INVALID;
                }
            }
            return _this._displayedText;
        })();
    }

    /**
     * Changes the text currently displayed on the screen.
     *
     * @param newval {string} : a string corresponding to the text currently displayed on the screen
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_displayedText(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this2._setAttr('displayedText', rest_val);
        })();
    }

    get_displayMode() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DISPLAYMODE_INVALID;
                }
            }
            return _this3._displayMode;
        })();
    }

    set_displayMode(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('displayMode', rest_val);
        })();
    }

    /**
     * Retrieves a segmented display for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the segmented displays is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSegmentedDisplay.isOnline() to test if the segmented displays is
     * indeed online at a given time. In case of ambiguity when looking for
     * a segmented display by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the segmented displays
     *
     * @return {YSegmentedDisplay} a YSegmentedDisplay object allowing you to drive the segmented displays.
     */
    static FindSegmentedDisplay(func) {
        /** @type {YSegmentedDisplay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('SegmentedDisplay', func);
        if (obj == null) {
            obj = new YSegmentedDisplay(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('SegmentedDisplay', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a segmented display for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the segmented displays is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSegmentedDisplay.isOnline() to test if the segmented displays is
     * indeed online at a given time. In case of ambiguity when looking for
     * a segmented display by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the segmented displays
     *
     * @return {YSegmentedDisplay} a YSegmentedDisplay object allowing you to drive the segmented displays.
     */
    static FindSegmentedDisplayInContext(yctx, func) {
        /** @type {YSegmentedDisplay} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'SegmentedDisplay', func);
        if (obj == null) {
            obj = new YSegmentedDisplay(yctx, func);
            _yocto_api.YFunction._AddToCache('SegmentedDisplay', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of segmented displays started using yFirstSegmentedDisplay().
     *
     * @return {YSegmentedDisplay} a pointer to a YSegmentedDisplay object, corresponding to
     *         a segmented display currently online, or a null pointer
     *         if there are no more segmented displays to enumerate.
     */
    /* */nextSegmentedDisplay() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YSegmentedDisplay.FindSegmentedDisplayInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of segmented displays currently accessible.
     * Use the method YSegmentedDisplay.nextSegmentedDisplay() to iterate on
     * next segmented displays.
     *
     * @return {YSegmentedDisplay} a pointer to a YSegmentedDisplay object, corresponding to
     *         the first segmented displays currently online, or a null pointer
     *         if there are none.
     */
    static FirstSegmentedDisplay() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('SegmentedDisplay');
        if (next_hwid == null) return null;
        return YSegmentedDisplay.FindSegmentedDisplay(next_hwid);
    }

    /**
     * Starts the enumeration of segmented displays currently accessible.
     * Use the method YSegmentedDisplay.nextSegmentedDisplay() to iterate on
     * next segmented displays.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YSegmentedDisplay} a pointer to a YSegmentedDisplay object, corresponding to
     *         the first segmented displays currently online, or a null pointer
     *         if there are none.
     */
    static FirstSegmentedDisplayInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('SegmentedDisplay');
        if (next_hwid == null) return null;
        return YSegmentedDisplay.FindSegmentedDisplayInContext(yctx, next_hwid);
    }

    //--- (end of YSegmentedDisplay implementation)
}

exports.YSegmentedDisplay = YSegmentedDisplay; //--- (SegmentedDisplay functions)

/**
 * comment from .yc definition
 */

function yFindSegmentedDisplay(func) {
    return YSegmentedDisplay.FindSegmentedDisplay(func);
}

/**
 * comment from .yc definition
 */
function yFirstSegmentedDisplay() {
    return YSegmentedDisplay.FirstSegmentedDisplay();
}

//--- (end of SegmentedDisplay functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for SerialPort functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YSerialPort = exports.Y_COMMAND_INVALID = exports.Y_STARTUPJOB_INVALID = exports.Y_CURRENTJOB_INVALID = exports.Y_LASTMSG_INVALID = exports.Y_TXMSGCOUNT_INVALID = exports.Y_RXMSGCOUNT_INVALID = exports.Y_ERRCOUNT_INVALID = exports.Y_TXCOUNT_INVALID = exports.Y_RXCOUNT_INVALID = exports.Y_PROTOCOL_INVALID = exports.Y_SERIALMODE_INVALID = exports.Y_VOLTAGELEVEL_INVALID = exports.Y_VOLTAGELEVEL_RS485 = exports.Y_VOLTAGELEVEL_RS232 = exports.Y_VOLTAGELEVEL_TTL5VR = exports.Y_VOLTAGELEVEL_TTL5V = exports.Y_VOLTAGELEVEL_TTL3VR = exports.Y_VOLTAGELEVEL_TTL3V = exports.Y_VOLTAGELEVEL_OFF = undefined;
exports.yFindSerialPort = yFindSerialPort;
exports.yFirstSerialPort = yFirstSerialPort;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YSerialPort return codes)
//--- (end of YSerialPort return codes)
//--- (YSerialPort definitions)
const Y_VOLTAGELEVEL_OFF = exports.Y_VOLTAGELEVEL_OFF = 0;
const Y_VOLTAGELEVEL_TTL3V = exports.Y_VOLTAGELEVEL_TTL3V = 1;
const Y_VOLTAGELEVEL_TTL3VR = exports.Y_VOLTAGELEVEL_TTL3VR = 2;
const Y_VOLTAGELEVEL_TTL5V = exports.Y_VOLTAGELEVEL_TTL5V = 3;
const Y_VOLTAGELEVEL_TTL5VR = exports.Y_VOLTAGELEVEL_TTL5VR = 4;
const Y_VOLTAGELEVEL_RS232 = exports.Y_VOLTAGELEVEL_RS232 = 5;
const Y_VOLTAGELEVEL_RS485 = exports.Y_VOLTAGELEVEL_RS485 = 6;
const Y_VOLTAGELEVEL_INVALID = exports.Y_VOLTAGELEVEL_INVALID = -1;
const Y_SERIALMODE_INVALID = exports.Y_SERIALMODE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_PROTOCOL_INVALID = exports.Y_PROTOCOL_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_RXCOUNT_INVALID = exports.Y_RXCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_TXCOUNT_INVALID = exports.Y_TXCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_ERRCOUNT_INVALID = exports.Y_ERRCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_RXMSGCOUNT_INVALID = exports.Y_RXMSGCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_TXMSGCOUNT_INVALID = exports.Y_TXMSGCOUNT_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_LASTMSG_INVALID = exports.Y_LASTMSG_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CURRENTJOB_INVALID = exports.Y_CURRENTJOB_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_STARTUPJOB_INVALID = exports.Y_STARTUPJOB_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YSerialPort definitions)

//--- (YSerialPort class start)
/**
 * YSerialPort Class: SerialPort function interface
 *
 * The SerialPort function interface allows you to fully drive a Yoctopuce
 * serial port, to send and receive data, and to configure communication
 * parameters (baud rate, bit count, parity, flow control and protocol).
 * Note that Yoctopuce serial ports are not exposed as virtual COM ports.
 * They are meant to be used in the same way as all Yoctopuce devices.
 */
//--- (end of YSerialPort class start)

class YSerialPort extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YSerialPort constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'SerialPort';
        /** @member {string} **/
        this._serialMode = Y_SERIALMODE_INVALID;
        /** @member {string} **/
        this._protocol = Y_PROTOCOL_INVALID;
        /** @member {number} **/
        this._voltageLevel = Y_VOLTAGELEVEL_INVALID;
        /** @member {number} **/
        this._rxCount = Y_RXCOUNT_INVALID;
        /** @member {number} **/
        this._txCount = Y_TXCOUNT_INVALID;
        /** @member {number} **/
        this._errCount = Y_ERRCOUNT_INVALID;
        /** @member {number} **/
        this._rxMsgCount = Y_RXMSGCOUNT_INVALID;
        /** @member {number} **/
        this._txMsgCount = Y_TXMSGCOUNT_INVALID;
        /** @member {string} **/
        this._lastMsg = Y_LASTMSG_INVALID;
        /** @member {string} **/
        this._currentJob = Y_CURRENTJOB_INVALID;
        /** @member {string} **/
        this._startupJob = Y_STARTUPJOB_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        /** @member {number} **/
        this._rxptr = 0;
        this.imm_setConst({
            SERIALMODE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            PROTOCOL_INVALID: _yocto_api.YAPI.INVALID_STRING,
            VOLTAGELEVEL_OFF: 0,
            VOLTAGELEVEL_TTL3V: 1,
            VOLTAGELEVEL_TTL3VR: 2,
            VOLTAGELEVEL_TTL5V: 3,
            VOLTAGELEVEL_TTL5VR: 4,
            VOLTAGELEVEL_RS232: 5,
            VOLTAGELEVEL_RS485: 6,
            VOLTAGELEVEL_INVALID: -1,
            RXCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            TXCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            ERRCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            RXMSGCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            TXMSGCOUNT_INVALID: _yocto_api.YAPI.INVALID_UINT,
            LASTMSG_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CURRENTJOB_INVALID: _yocto_api.YAPI.INVALID_STRING,
            STARTUPJOB_INVALID: _yocto_api.YAPI.INVALID_STRING,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YSerialPort constructor)
    }

    //--- (YSerialPort implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'serialMode':
                this._serialMode = val;
                return 1;
            case 'protocol':
                this._protocol = val;
                return 1;
            case 'voltageLevel':
                this._voltageLevel = parseInt(val);
                return 1;
            case 'rxCount':
                this._rxCount = parseInt(val);
                return 1;
            case 'txCount':
                this._txCount = parseInt(val);
                return 1;
            case 'errCount':
                this._errCount = parseInt(val);
                return 1;
            case 'rxMsgCount':
                this._rxMsgCount = parseInt(val);
                return 1;
            case 'txMsgCount':
                this._txMsgCount = parseInt(val);
                return 1;
            case 'lastMsg':
                this._lastMsg = val;
                return 1;
            case 'currentJob':
                this._currentJob = val;
                return 1;
            case 'startupJob':
                this._startupJob = val;
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the serial port communication parameters, as a string such as
     * "9600,8N1". The string includes the baud rate, the number of data bits,
     * the parity, and the number of stop bits. An optional suffix is included
     * if flow control is active: "CtsRts" for hardware handshake, "XOnXOff"
     * for logical flow control and "Simplex" for acquiring a shared bus using
     * the RTS line (as used by some RS485 adapters for instance).
     *
     * @return {string} a string corresponding to the serial port communication parameters, as a string such as
     *         "9600,8N1"
     *
     * On failure, throws an exception or returns YSerialPort.SERIALMODE_INVALID.
     */
    get_serialMode() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SERIALMODE_INVALID;
                }
            }
            return _this._serialMode;
        })();
    }

    /**
     * Changes the serial port communication parameters, with a string such as
     * "9600,8N1". The string includes the baud rate, the number of data bits,
     * the parity, and the number of stop bits. An optional suffix can be added
     * to enable flow control: "CtsRts" for hardware handshake, "XOnXOff"
     * for logical flow control and "Simplex" for acquiring a shared bus using
     * the RTS line (as used by some RS485 adapters for instance).
     *
     * @param newval {string} : a string corresponding to the serial port communication parameters, with a
     * string such as
     *         "9600,8N1"
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_serialMode(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this2._setAttr('serialMode', rest_val);
        })();
    }

    /**
     * Returns the type of protocol used over the serial line, as a string.
     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
     * "Frame:[timeout]ms" for binary messages separated by a delay time,
     * "Modbus-ASCII" for MODBUS messages in ASCII mode,
     * "Modbus-RTU" for MODBUS messages in RTU mode,
     * "Char" for a continuous ASCII stream or
     * "Byte" for a continuous binary stream.
     *
     * @return {string} a string corresponding to the type of protocol used over the serial line, as a string
     *
     * On failure, throws an exception or returns YSerialPort.PROTOCOL_INVALID.
     */
    get_protocol() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PROTOCOL_INVALID;
                }
            }
            return _this3._protocol;
        })();
    }

    /**
     * Changes the type of protocol used over the serial line.
     * Possible values are "Line" for ASCII messages separated by CR and/or LF,
     * "Frame:[timeout]ms" for binary messages separated by a delay time,
     * "Modbus-ASCII" for MODBUS messages in ASCII mode,
     * "Modbus-RTU" for MODBUS messages in RTU mode,
     * "Char" for a continuous ASCII stream or
     * "Byte" for a continuous binary stream.
     * The suffix "/[wait]ms" can be added to reduce the transmit rate so that there
     * is always at lest the specified number of milliseconds between each bytes sent.
     *
     * @param newval {string} : a string corresponding to the type of protocol used over the serial line
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_protocol(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this4._setAttr('protocol', rest_val);
        })();
    }

    /**
     * Returns the voltage level used on the serial line.
     *
     * @return {number} a value among YSerialPort.VOLTAGELEVEL_OFF, YSerialPort.VOLTAGELEVEL_TTL3V,
     * YSerialPort.VOLTAGELEVEL_TTL3VR, YSerialPort.VOLTAGELEVEL_TTL5V, YSerialPort.VOLTAGELEVEL_TTL5VR,
     * YSerialPort.VOLTAGELEVEL_RS232 and YSerialPort.VOLTAGELEVEL_RS485 corresponding to the voltage
     * level used on the serial line
     *
     * On failure, throws an exception or returns YSerialPort.VOLTAGELEVEL_INVALID.
     */
    get_voltageLevel() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_VOLTAGELEVEL_INVALID;
                }
            }
            return _this5._voltageLevel;
        })();
    }

    /**
     * Changes the voltage type used on the serial line. Valid
     * values  will depend on the Yoctopuce device model featuring
     * the serial port feature.  Check your device documentation
     * to find out which values are valid for that specific model.
     * Trying to set an invalid value will have no effect.
     *
     * @param newval {number} : a value among YSerialPort.VOLTAGELEVEL_OFF,
     * YSerialPort.VOLTAGELEVEL_TTL3V, YSerialPort.VOLTAGELEVEL_TTL3VR, YSerialPort.VOLTAGELEVEL_TTL5V,
     * YSerialPort.VOLTAGELEVEL_TTL5VR, YSerialPort.VOLTAGELEVEL_RS232 and YSerialPort.VOLTAGELEVEL_RS485
     * corresponding to the voltage type used on the serial line
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_voltageLevel(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('voltageLevel', rest_val);
        })();
    }

    /**
     * Returns the total number of bytes received since last reset.
     *
     * @return {number} an integer corresponding to the total number of bytes received since last reset
     *
     * On failure, throws an exception or returns YSerialPort.RXCOUNT_INVALID.
     */
    get_rxCount() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RXCOUNT_INVALID;
                }
            }
            return _this7._rxCount;
        })();
    }

    /**
     * Returns the total number of bytes transmitted since last reset.
     *
     * @return {number} an integer corresponding to the total number of bytes transmitted since last reset
     *
     * On failure, throws an exception or returns YSerialPort.TXCOUNT_INVALID.
     */
    get_txCount() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TXCOUNT_INVALID;
                }
            }
            return _this8._txCount;
        })();
    }

    /**
     * Returns the total number of communication errors detected since last reset.
     *
     * @return {number} an integer corresponding to the total number of communication errors detected since last reset
     *
     * On failure, throws an exception or returns YSerialPort.ERRCOUNT_INVALID.
     */
    get_errCount() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ERRCOUNT_INVALID;
                }
            }
            return _this9._errCount;
        })();
    }

    /**
     * Returns the total number of messages received since last reset.
     *
     * @return {number} an integer corresponding to the total number of messages received since last reset
     *
     * On failure, throws an exception or returns YSerialPort.RXMSGCOUNT_INVALID.
     */
    get_rxMsgCount() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RXMSGCOUNT_INVALID;
                }
            }
            return _this10._rxMsgCount;
        })();
    }

    /**
     * Returns the total number of messages send since last reset.
     *
     * @return {number} an integer corresponding to the total number of messages send since last reset
     *
     * On failure, throws an exception or returns YSerialPort.TXMSGCOUNT_INVALID.
     */
    get_txMsgCount() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TXMSGCOUNT_INVALID;
                }
            }
            return _this11._txMsgCount;
        })();
    }

    /**
     * Returns the latest message fully received (for Line, Frame and Modbus protocols).
     *
     * @return {string} a string corresponding to the latest message fully received (for Line, Frame and
     * Modbus protocols)
     *
     * On failure, throws an exception or returns YSerialPort.LASTMSG_INVALID.
     */
    get_lastMsg() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LASTMSG_INVALID;
                }
            }
            return _this12._lastMsg;
        })();
    }

    /**
     * Returns the name of the job file currently in use.
     *
     * @return {string} a string corresponding to the name of the job file currently in use
     *
     * On failure, throws an exception or returns YSerialPort.CURRENTJOB_INVALID.
     */
    get_currentJob() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CURRENTJOB_INVALID;
                }
            }
            return _this13._currentJob;
        })();
    }

    /**
     * Changes the job to use when the device is powered on.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the job to use when the device is powered on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_currentJob(newval) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this14._setAttr('currentJob', rest_val);
        })();
    }

    /**
     * Returns the job file to use when the device is powered on.
     *
     * @return {string} a string corresponding to the job file to use when the device is powered on
     *
     * On failure, throws an exception or returns YSerialPort.STARTUPJOB_INVALID.
     */
    get_startupJob() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            if (_this15._cacheExpiration <= _this15._yapi.GetTickCount()) {
                if ((yield _this15.load(_this15._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STARTUPJOB_INVALID;
                }
            }
            return _this15._startupJob;
        })();
    }

    /**
     * Changes the job to use when the device is powered on.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {string} : a string corresponding to the job to use when the device is powered on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_startupJob(newval) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this16._setAttr('startupJob', rest_val);
        })();
    }

    get_command() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (_this17._cacheExpiration <= _this17._yapi.GetTickCount()) {
                if ((yield _this17.load(_this17._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this17._command;
        })();
    }

    set_command(newval) {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this18._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a serial port for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the serial port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSerialPort.isOnline() to test if the serial port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a serial port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the serial port
     *
     * @return {YSerialPort} a YSerialPort object allowing you to drive the serial port.
     */
    static FindSerialPort(func) {
        /** @type {YSerialPort} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('SerialPort', func);
        if (obj == null) {
            obj = new YSerialPort(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('SerialPort', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a serial port for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the serial port is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YSerialPort.isOnline() to test if the serial port is
     * indeed online at a given time. In case of ambiguity when looking for
     * a serial port by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the serial port
     *
     * @return {YSerialPort} a YSerialPort object allowing you to drive the serial port.
     */
    static FindSerialPortInContext(yctx, func) {
        /** @type {YSerialPort} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'SerialPort', func);
        if (obj == null) {
            obj = new YSerialPort(yctx, func);
            _yocto_api.YFunction._AddToCache('SerialPort', func, obj);
        }
        return obj;
    }

    sendCommand(text) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            return yield _this19.set_command(text);
        })();
    }

    /**
     * Clears the serial port buffer and resets counters to zero.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    reset() {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            _this20._rxptr = 0;
            // may throw an exception
            return yield _this20.sendCommand('Z');
        })();
    }

    /**
     * Manually sets the state of the RTS line. This function has no effect when
     * hardware handshake is enabled, as the RTS line is driven automatically.
     *
     * @param val {number} : 1 to turn RTS on, 0 to turn RTS off
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_RTS(val) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            return yield _this21.sendCommand('R' + String(Math.round(val)));
        })();
    }

    /**
     * Reads the level of the CTS line. The CTS line is usually driven by
     * the RTS signal of the connected serial device.
     *
     * @return {number} 1 if the CTS line is high, 0 if the CTS line is low.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    get_CTS() {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let res;
            // may throw an exception
            buff = yield _this22._download('cts.txt');
            if (!(buff.length == 1)) {
                return _this22._throw(YAPI_IO_ERROR, 'invalid CTS reply', YAPI_IO_ERROR);
            }
            res = buff[0] - 48;
            return res;
        })();
    }

    /**
     * Sends a single byte to the serial port.
     *
     * @param code {number} : the byte to send
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeByte(code) {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            return yield _this23.sendCommand('$' + ('00' + code.toString(16)).slice(-2));
        })();
    }

    /**
     * Sends an ASCII string to the serial port, as is.
     *
     * @param text {string} : the text string to send
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeStr(text) {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let ch;
            buff = _this24._yapi.imm_str2bin(text);
            bufflen = buff.length;
            if (bufflen < 100) {
                ch = 0x20;
                idx = 0;
                while (idx < bufflen && ch != 0) {
                    ch = buff[idx];
                    if (ch >= 0x20 && ch < 0x7f) {
                        idx = idx + 1;
                    } else {
                        ch = 0;
                    }
                }
                if (idx >= bufflen) {
                    return yield _this24.sendCommand('+' + text);
                }
            }
            // send string using file upload
            return yield _this24._upload('txdata', buff);
        })();
    }

    /**
     * Sends a binary buffer to the serial port, as is.
     *
     * @param buff {Uint8Array} : the binary buffer to send
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeBin(buff) {
        var _this25 = this;

        return _asyncToGenerator(function* () {
            return yield _this25._upload('txdata', buff);
        })();
    }

    /**
     * Sends a byte sequence (provided as a list of bytes) to the serial port.
     *
     * @param byteList {Integer[]} : a list of byte codes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeArray(byteList) {
        var _this26 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let hexb;
            /** @type {number} **/
            let res;
            bufflen = byteList.length;
            buff = new Uint8Array(bufflen);
            idx = 0;
            while (idx < bufflen) {
                hexb = byteList[idx];
                buff.set([hexb], idx);
                idx = idx + 1;
            }
            // may throw an exception
            res = yield _this26._upload('txdata', buff);
            return res;
        })();
    }

    /**
     * Sends a byte sequence (provided as a hexadecimal string) to the serial port.
     *
     * @param hexString {string} : a string of hexadecimal byte codes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeHex(hexString) {
        var _this27 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let hexb;
            /** @type {number} **/
            let res;
            bufflen = hexString.length;
            if (bufflen < 100) {
                return yield _this27.sendCommand('$' + hexString);
            }
            bufflen = bufflen >> 1;
            buff = new Uint8Array(bufflen);
            idx = 0;
            while (idx < bufflen) {
                hexb = parseInt(hexString.substr(2 * idx, 2), 16);
                buff.set([hexb], idx);
                idx = idx + 1;
            }
            // may throw an exception
            res = yield _this27._upload('txdata', buff);
            return res;
        })();
    }

    /**
     * Sends an ASCII string to the serial port, followed by a line break (CR LF).
     *
     * @param text {string} : the text string to send
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeLine(text) {
        var _this28 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let ch;
            buff = _this28._yapi.imm_str2bin(text + '\r\n');
            bufflen = buff.length - 2;
            if (bufflen < 100) {
                ch = 0x20;
                idx = 0;
                while (idx < bufflen && ch != 0) {
                    ch = buff[idx];
                    if (ch >= 0x20 && ch < 0x7f) {
                        idx = idx + 1;
                    } else {
                        ch = 0;
                    }
                }
                if (idx >= bufflen) {
                    return yield _this28.sendCommand('!' + text);
                }
            }
            // send string using file upload
            return yield _this28._upload('txdata', buff);
        })();
    }

    /**
     * Sends a MODBUS message (provided as a hexadecimal string) to the serial port.
     * The message must start with the slave address. The MODBUS CRC/LRC is
     * automatically added by the function. This function does not wait for a reply.
     *
     * @param hexString {string} : a hexadecimal message string, including device address but no CRC/LRC
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    writeMODBUS(hexString) {
        var _this29 = this;

        return _asyncToGenerator(function* () {
            return yield _this29.sendCommand(':' + hexString);
        })();
    }

    /**
     * Reads one byte from the receive buffer, starting at current stream position.
     * If data at current stream position is not available anymore in the receive buffer,
     * or if there is no data available yet, the function returns YAPI.NO_MORE_DATA.
     *
     * @return {number} the next byte
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readByte() {
        var _this30 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let mult;
            /** @type {number} **/
            let endpos;
            /** @type {number} **/
            let res;
            // may throw an exception
            buff = yield _this30._download('rxdata.bin?pos=' + String(Math.round(_this30._rxptr)) + '&len=1');
            bufflen = buff.length - 1;
            endpos = 0;
            mult = 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                endpos = endpos + mult * (buff[bufflen] - 48);
                mult = mult * 10;
                bufflen = bufflen - 1;
            }
            _this30._rxptr = endpos;
            if (bufflen == 0) {
                return YAPI_NO_MORE_DATA;
            }
            res = buff[0];
            return res;
        })();
    }

    /**
     * Reads data from the receive buffer as a string, starting at current stream position.
     * If data at current stream position is not available anymore in the receive buffer, the
     * function performs a short read.
     *
     * @param nChars {number} : the maximum number of characters to read
     *
     * @return {string} a string with receive buffer contents
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readStr(nChars) {
        var _this31 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let mult;
            /** @type {number} **/
            let endpos;
            /** @type {string} **/
            let res;
            if (nChars > 65535) {
                nChars = 65535;
            }
            // may throw an exception
            buff = yield _this31._download('rxdata.bin?pos=' + String(Math.round(_this31._rxptr)) + '&len=' + String(Math.round(nChars)));
            bufflen = buff.length - 1;
            endpos = 0;
            mult = 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                endpos = endpos + mult * (buff[bufflen] - 48);
                mult = mult * 10;
                bufflen = bufflen - 1;
            }
            _this31._rxptr = endpos;
            res = _this31._yapi.imm_bin2str(buff).substr(0, bufflen);
            return res;
        })();
    }

    /**
     * Reads data from the receive buffer as a binary buffer, starting at current stream position.
     * If data at current stream position is not available anymore in the receive buffer, the
     * function performs a short read.
     *
     * @param nChars {number} : the maximum number of bytes to read
     *
     * @return {Uint8Array} a binary object with receive buffer contents
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readBin(nChars) {
        var _this32 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let mult;
            /** @type {number} **/
            let endpos;
            /** @type {number} **/
            let idx;
            /** @type {Uint8Array} **/
            let res;
            if (nChars > 65535) {
                nChars = 65535;
            }
            // may throw an exception
            buff = yield _this32._download('rxdata.bin?pos=' + String(Math.round(_this32._rxptr)) + '&len=' + String(Math.round(nChars)));
            bufflen = buff.length - 1;
            endpos = 0;
            mult = 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                endpos = endpos + mult * (buff[bufflen] - 48);
                mult = mult * 10;
                bufflen = bufflen - 1;
            }
            _this32._rxptr = endpos;
            res = new Uint8Array(bufflen);
            idx = 0;
            while (idx < bufflen) {
                res.set([buff[idx]], idx);
                idx = idx + 1;
            }
            return res;
        })();
    }

    /**
     * Reads data from the receive buffer as a list of bytes, starting at current stream position.
     * If data at current stream position is not available anymore in the receive buffer, the
     * function performs a short read.
     *
     * @param nChars {number} : the maximum number of bytes to read
     *
     * @return {Integer[]} a sequence of bytes with receive buffer contents
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readArray(nChars) {
        var _this33 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let mult;
            /** @type {number} **/
            let endpos;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let b;
            /** @type {number[]} **/
            let res = [];
            if (nChars > 65535) {
                nChars = 65535;
            }
            // may throw an exception
            buff = yield _this33._download('rxdata.bin?pos=' + String(Math.round(_this33._rxptr)) + '&len=' + String(Math.round(nChars)));
            bufflen = buff.length - 1;
            endpos = 0;
            mult = 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                endpos = endpos + mult * (buff[bufflen] - 48);
                mult = mult * 10;
                bufflen = bufflen - 1;
            }
            _this33._rxptr = endpos;
            res.length = 0;
            idx = 0;
            while (idx < bufflen) {
                b = buff[idx];
                res.push(b);
                idx = idx + 1;
            }
            return res;
        })();
    }

    /**
     * Reads data from the receive buffer as a hexadecimal string, starting at current stream position.
     * If data at current stream position is not available anymore in the receive buffer, the
     * function performs a short read.
     *
     * @param nBytes {number} : the maximum number of bytes to read
     *
     * @return {string} a string with receive buffer contents, encoded in hexadecimal
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readHex(nBytes) {
        var _this34 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let mult;
            /** @type {number} **/
            let endpos;
            /** @type {number} **/
            let ofs;
            /** @type {string} **/
            let res;
            if (nBytes > 65535) {
                nBytes = 65535;
            }
            // may throw an exception
            buff = yield _this34._download('rxdata.bin?pos=' + String(Math.round(_this34._rxptr)) + '&len=' + String(Math.round(nBytes)));
            bufflen = buff.length - 1;
            endpos = 0;
            mult = 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                endpos = endpos + mult * (buff[bufflen] - 48);
                mult = mult * 10;
                bufflen = bufflen - 1;
            }
            _this34._rxptr = endpos;
            res = '';
            ofs = 0;
            while (ofs + 3 < bufflen) {
                res = res + '' + ('00' + buff[ofs].toString(16)).slice(-2) + '' + ('00' + buff[ofs + 1].toString(16)).slice(-2) + '' + ('00' + buff[ofs + 2].toString(16)).slice(-2) + '' + ('00' + buff[ofs + 3].toString(16)).slice(-2);
                ofs = ofs + 4;
            }
            while (ofs < bufflen) {
                res = res + '' + ('00' + buff[ofs].toString(16)).slice(-2);
                ofs = ofs + 1;
            }
            return res;
        })();
    }

    /**
     * Reads a single line (or message) from the receive buffer, starting at current stream position.
     * This function is intended to be used when the serial port is configured for a message protocol,
     * such as 'Line' mode or MODBUS protocols.
     *
     * If data at current stream position is not available anymore in the receive buffer,
     * the function returns the oldest available line and moves the stream position just after.
     * If no new full line is received, the function returns an empty line.
     *
     * @return {string} a string with a single line of text
     *
     * On failure, throws an exception or returns a negative error code.
     */
    readLine() {
        var _this35 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let url;
            /** @type {Uint8Array} **/
            let msgbin;
            /** @type {string[]} **/
            let msgarr = [];
            /** @type {number} **/
            let msglen;
            /** @type {string} **/
            let res;
            // may throw an exception
            url = 'rxmsg.json?pos=' + String(Math.round(_this35._rxptr)) + '&len=1&maxw=1';
            msgbin = yield _this35._download(url);
            msgarr = _this35.imm_json_get_array(msgbin);
            msglen = msgarr.length;
            if (msglen == 0) {
                return '';
            }
            // last element of array is the new position
            msglen = msglen - 1;
            _this35._rxptr = _this35._yapi.imm_atoi(msgarr[msglen]);
            if (msglen == 0) {
                return '';
            }
            res = _this35.imm_json_get_string(_this35._yapi.imm_str2bin(msgarr[0]));
            return res;
        })();
    }

    /**
     * Searches for incoming messages in the serial port receive buffer matching a given pattern,
     * starting at current position. This function will only compare and return printable characters
     * in the message strings. Binary protocols are handled as hexadecimal strings.
     *
     * The search returns all messages matching the expression provided as argument in the buffer.
     * If no matching message is found, the search waits for one up to the specified maximum timeout
     * (in milliseconds).
     *
     * @param pattern {string} : a limited regular expression describing the expected message format,
     *         or an empty string if all messages should be returned (no filtering).
     *         When using binary protocols, the format applies to the hexadecimal
     *         representation of the message.
     * @param maxWait {number} : the maximum number of milliseconds to wait for a message if none is found
     *         in the receive buffer.
     *
     * @return {string[]} an array of strings containing the messages found, if any.
     *         Binary messages are converted to hexadecimal representation.
     *
     * On failure, throws an exception or returns an empty array.
     */
    readMessages(pattern, maxWait) {
        var _this36 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let url;
            /** @type {Uint8Array} **/
            let msgbin;
            /** @type {string[]} **/
            let msgarr = [];
            /** @type {number} **/
            let msglen;
            /** @type {string[]} **/
            let res = [];
            /** @type {number} **/
            let idx;
            // may throw an exception
            url = 'rxmsg.json?pos=' + String(Math.round(_this36._rxptr)) + '&maxw=' + String(Math.round(maxWait)) + '&pat=' + pattern;
            msgbin = yield _this36._download(url);
            msgarr = _this36.imm_json_get_array(msgbin);
            msglen = msgarr.length;
            if (msglen == 0) {
                return res;
            }
            // last element of array is the new position
            msglen = msglen - 1;
            _this36._rxptr = _this36._yapi.imm_atoi(msgarr[msglen]);
            idx = 0;
            while (idx < msglen) {
                res.push(_this36.imm_json_get_string(_this36._yapi.imm_str2bin(msgarr[idx])));
                idx = idx + 1;
            }
            return res;
        })();
    }

    /**
     * Changes the current internal stream position to the specified value. This function
     * does not affect the device, it only changes the value stored in the YSerialPort object
     * for the next read operations.
     *
     * @param absPos {number} : the absolute position index for next read operations.
     *
     * @return {number} nothing.
     */
    read_seek(absPos) {
        var _this37 = this;

        return _asyncToGenerator(function* () {
            _this37._rxptr = absPos;
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Returns the current absolute stream position pointer of the YSerialPort object.
     *
     * @return {number} the absolute position index for next read operations.
     */
    read_tell() {
        var _this38 = this;

        return _asyncToGenerator(function* () {
            return _this38._rxptr;
        })();
    }

    /**
     * Returns the number of bytes available to read in the input buffer starting from the
     * current absolute stream position pointer of the YSerialPort object.
     *
     * @return {number} the number of bytes available to read
     */
    read_avail() {
        var _this39 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let buff;
            /** @type {number} **/
            let bufflen;
            /** @type {number} **/
            let res;
            // may throw an exception
            buff = yield _this39._download('rxcnt.bin?pos=' + String(Math.round(_this39._rxptr)));
            bufflen = buff.length - 1;
            while (bufflen > 0 && buff[bufflen] != 64) {
                bufflen = bufflen - 1;
            }
            res = _this39._yapi.imm_atoi(_this39._yapi.imm_bin2str(buff).substr(0, bufflen));
            return res;
        })();
    }

    /**
     * Sends a text line query to the serial port, and reads the reply, if any.
     * This function is intended to be used when the serial port is configured for 'Line' protocol.
     *
     * @param query {string} : the line query to send (without CR/LF)
     * @param maxWait {number} : the maximum number of milliseconds to wait for a reply.
     *
     * @return {string} the next text line received after sending the text query, as a string.
     *         Additional lines can be obtained by calling readLine or readMessages.
     *
     * On failure, throws an exception or returns an empty array.
     */
    queryLine(query, maxWait) {
        var _this40 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let url;
            /** @type {Uint8Array} **/
            let msgbin;
            /** @type {string[]} **/
            let msgarr = [];
            /** @type {number} **/
            let msglen;
            /** @type {string} **/
            let res;
            // may throw an exception
            url = 'rxmsg.json?len=1&maxw=' + String(Math.round(maxWait)) + '&cmd=!' + query;
            msgbin = yield _this40._download(url);
            msgarr = _this40.imm_json_get_array(msgbin);
            msglen = msgarr.length;
            if (msglen == 0) {
                return '';
            }
            // last element of array is the new position
            msglen = msglen - 1;
            _this40._rxptr = _this40._yapi.imm_atoi(msgarr[msglen]);
            if (msglen == 0) {
                return '';
            }
            res = _this40.imm_json_get_string(_this40._yapi.imm_str2bin(msgarr[0]));
            return res;
        })();
    }

    /**
     * Sends a message to a specified MODBUS slave connected to the serial port, and reads the
     * reply, if any. The message is the PDU, provided as a vector of bytes.
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to query
     * @param pduBytes {Integer[]} : the message to send (PDU), as a vector of bytes. The first byte of the
     *         PDU is the MODBUS function code.
     *
     * @return {Integer[]} the received reply, as a vector of bytes.
     *
     * On failure, throws an exception or returns an empty array (or a MODBUS error reply).
     */
    queryMODBUS(slaveNo, pduBytes) {
        var _this41 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let funCode;
            /** @type {number} **/
            let nib;
            /** @type {number} **/
            let i;
            /** @type {string} **/
            let cmd;
            /** @type {string} **/
            let url;
            /** @type {string} **/
            let pat;
            /** @type {Uint8Array} **/
            let msgs;
            /** @type {string[]} **/
            let reps = [];
            /** @type {string} **/
            let rep;
            /** @type {number[]} **/
            let res = [];
            /** @type {number} **/
            let replen;
            /** @type {number} **/
            let hexb;
            funCode = pduBytes[0];
            nib = funCode >> 4;
            pat = ('00' + slaveNo.toString(16)).slice(-2) + '[' + nib.toString(16) + '' + (nib + 8).toString(16) + ']' + (funCode & 15).toString(16) + '.*';
            cmd = ('00' + slaveNo.toString(16)).slice(-2) + '' + ('00' + funCode.toString(16)).slice(-2);
            i = 1;
            while (i < pduBytes.length) {
                cmd = cmd + '' + ('00' + (pduBytes[i] & 0xff).toString(16)).slice(-2);
                i = i + 1;
            }
            // may throw an exception
            url = 'rxmsg.json?cmd=:' + cmd + '&pat=:' + pat;
            msgs = yield _this41._download(url);
            reps = _this41.imm_json_get_array(msgs);
            if (!(reps.length > 1)) {
                return _this41._throw(YAPI_IO_ERROR, 'no reply from slave', res);
            }
            if (reps.length > 1) {
                rep = _this41.imm_json_get_string(_this41._yapi.imm_str2bin(reps[0]));
                replen = rep.length - 3 >> 1;
                i = 0;
                while (i < replen) {
                    hexb = parseInt(rep.substr(2 * i + 3, 2), 16);
                    res.push(hexb);
                    i = i + 1;
                }
                if (res[0] != funCode) {
                    i = res[1];
                    if (!(i > 1)) {
                        return _this41._throw(YAPI_NOT_SUPPORTED, 'MODBUS error: unsupported function code', res);
                    }
                    if (!(i > 2)) {
                        return _this41._throw(YAPI_INVALID_ARGUMENT, 'MODBUS error: illegal data address', res);
                    }
                    if (!(i > 3)) {
                        return _this41._throw(YAPI_INVALID_ARGUMENT, 'MODBUS error: illegal data value', res);
                    }
                    if (!(i > 4)) {
                        return _this41._throw(YAPI_INVALID_ARGUMENT, 'MODBUS error: failed to execute function', res);
                    }
                }
            }
            return res;
        })();
    }

    /**
     * Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.
     * This method uses the MODBUS function code 0x01 (Read Coils).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to query
     * @param pduAddr {number} : the relative address of the first bit/coil to read (zero-based)
     * @param nBits {number} : the number of bits/coils to read
     *
     * @return {Integer[]} a vector of integers, each corresponding to one bit.
     *
     * On failure, throws an exception or returns an empty array.
     */
    modbusReadBits(slaveNo, pduAddr, nBits) {
        var _this42 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number[]} **/
            let res = [];
            /** @type {number} **/
            let bitpos;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let val;
            /** @type {number} **/
            let mask;
            pdu.push(0x01);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nBits >> 8);
            pdu.push(nBits & 0xff);
            // may throw an exception
            reply = yield _this42.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            bitpos = 0;
            idx = 2;
            val = reply[idx];
            mask = 1;
            while (bitpos < nBits) {
                if ((val & mask) == 0) {
                    res.push(0);
                } else {
                    res.push(1);
                }
                bitpos = bitpos + 1;
                if (mask == 0x80) {
                    idx = idx + 1;
                    val = reply[idx];
                    mask = 1;
                } else {
                    mask = mask << 1;
                }
            }
            return res;
        })();
    }

    /**
     * Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.
     * This method uses the MODBUS function code 0x02 (Read Discrete Inputs).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to query
     * @param pduAddr {number} : the relative address of the first bit/input to read (zero-based)
     * @param nBits {number} : the number of bits/inputs to read
     *
     * @return {Integer[]} a vector of integers, each corresponding to one bit.
     *
     * On failure, throws an exception or returns an empty array.
     */
    modbusReadInputBits(slaveNo, pduAddr, nBits) {
        var _this43 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number[]} **/
            let res = [];
            /** @type {number} **/
            let bitpos;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let val;
            /** @type {number} **/
            let mask;
            pdu.push(0x02);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nBits >> 8);
            pdu.push(nBits & 0xff);
            // may throw an exception
            reply = yield _this43.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            bitpos = 0;
            idx = 2;
            val = reply[idx];
            mask = 1;
            while (bitpos < nBits) {
                if ((val & mask) == 0) {
                    res.push(0);
                } else {
                    res.push(1);
                }
                bitpos = bitpos + 1;
                if (mask == 0x80) {
                    idx = idx + 1;
                    val = reply[idx];
                    mask = 1;
                } else {
                    mask = mask << 1;
                }
            }
            return res;
        })();
    }

    /**
     * Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.
     * This method uses the MODBUS function code 0x03 (Read Holding Registers).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to query
     * @param pduAddr {number} : the relative address of the first holding register to read (zero-based)
     * @param nWords {number} : the number of holding registers to read
     *
     * @return {Integer[]} a vector of integers, each corresponding to one 16-bit register value.
     *
     * On failure, throws an exception or returns an empty array.
     */
    modbusReadRegisters(slaveNo, pduAddr, nWords) {
        var _this44 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number[]} **/
            let res = [];
            /** @type {number} **/
            let regpos;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let val;
            pdu.push(0x03);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nWords >> 8);
            pdu.push(nWords & 0xff);
            // may throw an exception
            reply = yield _this44.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            regpos = 0;
            idx = 2;
            while (regpos < nWords) {
                val = reply[idx] << 8;
                idx = idx + 1;
                val = val + reply[idx];
                idx = idx + 1;
                res.push(val);
                regpos = regpos + 1;
            }
            return res;
        })();
    }

    /**
     * Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.
     * This method uses the MODBUS function code 0x04 (Read Input Registers).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to query
     * @param pduAddr {number} : the relative address of the first input register to read (zero-based)
     * @param nWords {number} : the number of input registers to read
     *
     * @return {Integer[]} a vector of integers, each corresponding to one 16-bit input value.
     *
     * On failure, throws an exception or returns an empty array.
     */
    modbusReadInputRegisters(slaveNo, pduAddr, nWords) {
        var _this45 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number[]} **/
            let res = [];
            /** @type {number} **/
            let regpos;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let val;
            pdu.push(0x04);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nWords >> 8);
            pdu.push(nWords & 0xff);
            // may throw an exception
            reply = yield _this45.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            regpos = 0;
            idx = 2;
            while (regpos < nWords) {
                val = reply[idx] << 8;
                idx = idx + 1;
                val = val + reply[idx];
                idx = idx + 1;
                res.push(val);
                regpos = regpos + 1;
            }
            return res;
        })();
    }

    /**
     * Sets a single internal bit (or coil) on a MODBUS serial device.
     * This method uses the MODBUS function code 0x05 (Write Single Coil).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to drive
     * @param pduAddr {number} : the relative address of the bit/coil to set (zero-based)
     * @param value {number} : the value to set (0 for OFF state, non-zero for ON state)
     *
     * @return {number} the number of bits/coils affected on the device (1)
     *
     * On failure, throws an exception or returns zero.
     */
    modbusWriteBit(slaveNo, pduAddr, value) {
        var _this46 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number} **/
            let res;
            res = 0;
            if (value != 0) {
                value = 0xff;
            }
            pdu.push(0x05);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(value);
            pdu.push(0x00);
            // may throw an exception
            reply = yield _this46.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            res = 1;
            return res;
        })();
    }

    /**
     * Sets several contiguous internal bits (or coils) on a MODBUS serial device.
     * This method uses the MODBUS function code 0x0f (Write Multiple Coils).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to drive
     * @param pduAddr {number} : the relative address of the first bit/coil to set (zero-based)
     * @param bits {Integer[]} : the vector of bits to be set (one integer per bit)
     *
     * @return {number} the number of bits/coils affected on the device
     *
     * On failure, throws an exception or returns zero.
     */
    modbusWriteBits(slaveNo, pduAddr, bits) {
        var _this47 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let nBits;
            /** @type {number} **/
            let nBytes;
            /** @type {number} **/
            let bitpos;
            /** @type {number} **/
            let val;
            /** @type {number} **/
            let mask;
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number} **/
            let res;
            res = 0;
            nBits = bits.length;
            nBytes = nBits + 7 >> 3;
            pdu.push(0x0f);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nBits >> 8);
            pdu.push(nBits & 0xff);
            pdu.push(nBytes);
            bitpos = 0;
            val = 0;
            mask = 1;
            while (bitpos < nBits) {
                if (bits[bitpos] != 0) {
                    val = val | mask;
                }
                bitpos = bitpos + 1;
                if (mask == 0x80) {
                    pdu.push(val);
                    val = 0;
                    mask = 1;
                } else {
                    mask = mask << 1;
                }
            }
            if (mask != 1) {
                pdu.push(val);
            }
            // may throw an exception
            reply = yield _this47.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            res = reply[3] << 8;
            res = res + reply[4];
            return res;
        })();
    }

    /**
     * Sets a single internal register (or holding register) on a MODBUS serial device.
     * This method uses the MODBUS function code 0x06 (Write Single Register).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to drive
     * @param pduAddr {number} : the relative address of the register to set (zero-based)
     * @param value {number} : the 16 bit value to set
     *
     * @return {number} the number of registers affected on the device (1)
     *
     * On failure, throws an exception or returns zero.
     */
    modbusWriteRegister(slaveNo, pduAddr, value) {
        var _this48 = this;

        return _asyncToGenerator(function* () {
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number} **/
            let res;
            res = 0;
            if (value != 0) {
                value = 0xff;
            }
            pdu.push(0x06);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(value >> 8);
            pdu.push(value & 0xff);
            // may throw an exception
            reply = yield _this48.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            res = 1;
            return res;
        })();
    }

    /**
     * Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.
     * This method uses the MODBUS function code 0x10 (Write Multiple Registers).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to drive
     * @param pduAddr {number} : the relative address of the first internal register to set (zero-based)
     * @param values {Integer[]} : the vector of 16 bit values to set
     *
     * @return {number} the number of registers affected on the device
     *
     * On failure, throws an exception or returns zero.
     */
    modbusWriteRegisters(slaveNo, pduAddr, values) {
        var _this49 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let nWords;
            /** @type {number} **/
            let nBytes;
            /** @type {number} **/
            let regpos;
            /** @type {number} **/
            let val;
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number} **/
            let res;
            res = 0;
            nWords = values.length;
            nBytes = 2 * nWords;
            pdu.push(0x10);
            pdu.push(pduAddr >> 8);
            pdu.push(pduAddr & 0xff);
            pdu.push(nWords >> 8);
            pdu.push(nWords & 0xff);
            pdu.push(nBytes);
            regpos = 0;
            while (regpos < nWords) {
                val = values[regpos];
                pdu.push(val >> 8);
                pdu.push(val & 0xff);
                regpos = regpos + 1;
            }
            // may throw an exception
            reply = yield _this49.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            res = reply[3] << 8;
            res = res + reply[4];
            return res;
        })();
    }

    /**
     * Sets several contiguous internal registers (holding registers) on a MODBUS serial device,
     * then performs a contiguous read of a set of (possibly different) internal registers.
     * This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).
     *
     * @param slaveNo {number} : the address of the slave MODBUS device to drive
     * @param pduWriteAddr {number} : the relative address of the first internal register to set (zero-based)
     * @param values {Integer[]} : the vector of 16 bit values to set
     * @param pduReadAddr {number} : the relative address of the first internal register to read (zero-based)
     * @param nReadWords {number} : the number of 16 bit values to read
     *
     * @return {Integer[]} a vector of integers, each corresponding to one 16-bit register value read.
     *
     * On failure, throws an exception or returns an empty array.
     */
    modbusWriteAndReadRegisters(slaveNo, pduWriteAddr, values, pduReadAddr, nReadWords) {
        var _this50 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let nWriteWords;
            /** @type {number} **/
            let nBytes;
            /** @type {number} **/
            let regpos;
            /** @type {number} **/
            let val;
            /** @type {number} **/
            let idx;
            /** @type {number[]} **/
            let pdu = [];
            /** @type {number[]} **/
            let reply = [];
            /** @type {number[]} **/
            let res = [];
            nWriteWords = values.length;
            nBytes = 2 * nWriteWords;
            pdu.push(0x17);
            pdu.push(pduReadAddr >> 8);
            pdu.push(pduReadAddr & 0xff);
            pdu.push(nReadWords >> 8);
            pdu.push(nReadWords & 0xff);
            pdu.push(pduWriteAddr >> 8);
            pdu.push(pduWriteAddr & 0xff);
            pdu.push(nWriteWords >> 8);
            pdu.push(nWriteWords & 0xff);
            pdu.push(nBytes);
            regpos = 0;
            while (regpos < nWriteWords) {
                val = values[regpos];
                pdu.push(val >> 8);
                pdu.push(val & 0xff);
                regpos = regpos + 1;
            }
            // may throw an exception
            reply = yield _this50.queryMODBUS(slaveNo, pdu);
            if (reply.length == 0) {
                return res;
            }
            if (reply[0] != pdu[0]) {
                return res;
            }
            regpos = 0;
            idx = 2;
            while (regpos < nReadWords) {
                val = reply[idx] << 8;
                idx = idx + 1;
                val = val + reply[idx];
                idx = idx + 1;
                res.push(val);
                regpos = regpos + 1;
            }
            return res;
        })();
    }

    /**
     * Saves the job definition string (JSON data) into a job file.
     * The job file can be later enabled using selectJob().
     *
     * @param jobfile {string} : name of the job file to save on the device filesystem
     * @param jsonDef {string} : a string containing a JSON definition of the job
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    uploadJob(jobfile, jsonDef) {
        var _this51 = this;

        return _asyncToGenerator(function* () {
            yield _this51._upload(jobfile, _this51._yapi.imm_str2bin(jsonDef));
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Load and start processing the specified job file. The file must have
     * been previously created using the user interface or uploaded on the
     * device filesystem using the uploadJob() function.
     *
     * @param jobfile {string} : name of the job file (on the device filesystem)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    selectJob(jobfile) {
        var _this52 = this;

        return _asyncToGenerator(function* () {
            return yield _this52.set_currentJob(jobfile);
        })();
    }

    /**
     * Continues the enumeration of serial ports started using yFirstSerialPort().
     *
     * @return {YSerialPort} a pointer to a YSerialPort object, corresponding to
     *         a serial port currently online, or a null pointer
     *         if there are no more serial ports to enumerate.
     */
    /* */nextSerialPort() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YSerialPort.FindSerialPortInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of serial ports currently accessible.
     * Use the method YSerialPort.nextSerialPort() to iterate on
     * next serial ports.
     *
     * @return {YSerialPort} a pointer to a YSerialPort object, corresponding to
     *         the first serial port currently online, or a null pointer
     *         if there are none.
     */
    static FirstSerialPort() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('SerialPort');
        if (next_hwid == null) return null;
        return YSerialPort.FindSerialPort(next_hwid);
    }

    /**
     * Starts the enumeration of serial ports currently accessible.
     * Use the method YSerialPort.nextSerialPort() to iterate on
     * next serial ports.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YSerialPort} a pointer to a YSerialPort object, corresponding to
     *         the first serial port currently online, or a null pointer
     *         if there are none.
     */
    static FirstSerialPortInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('SerialPort');
        if (next_hwid == null) return null;
        return YSerialPort.FindSerialPortInContext(yctx, next_hwid);
    }

    //--- (end of YSerialPort implementation)
}

exports.YSerialPort = YSerialPort; //--- (SerialPort functions)

/**
 * comment from .yc definition
 */

function yFindSerialPort(func) {
    return YSerialPort.FindSerialPort(func);
}

/**
 * comment from .yc definition
 */
function yFirstSerialPort() {
    return YSerialPort.FirstSerialPort();
}

//--- (end of SerialPort functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Servo functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YServo = exports.Y_POSITIONATPOWERON_INVALID = exports.Y_MOVE_INVALID = exports.Y_NEUTRAL_INVALID = exports.Y_RANGE_INVALID = exports.Y_POSITION_INVALID = exports.Y_ENABLEDATPOWERON_INVALID = exports.Y_ENABLEDATPOWERON_TRUE = exports.Y_ENABLEDATPOWERON_FALSE = exports.Y_ENABLED_INVALID = exports.Y_ENABLED_TRUE = exports.Y_ENABLED_FALSE = undefined;
exports.yFindServo = yFindServo;
exports.yFirstServo = yFirstServo;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YServo return codes)
//--- (end of YServo return codes)
//--- (YServo definitions)
const Y_ENABLED_FALSE = exports.Y_ENABLED_FALSE = 0;
const Y_ENABLED_TRUE = exports.Y_ENABLED_TRUE = 1;
const Y_ENABLED_INVALID = exports.Y_ENABLED_INVALID = -1;
const Y_ENABLEDATPOWERON_FALSE = exports.Y_ENABLEDATPOWERON_FALSE = 0;
const Y_ENABLEDATPOWERON_TRUE = exports.Y_ENABLEDATPOWERON_TRUE = 1;
const Y_ENABLEDATPOWERON_INVALID = exports.Y_ENABLEDATPOWERON_INVALID = -1;
const Y_POSITION_INVALID = exports.Y_POSITION_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_RANGE_INVALID = exports.Y_RANGE_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_NEUTRAL_INVALID = exports.Y_NEUTRAL_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_MOVE_INVALID = exports.Y_MOVE_INVALID = null;
const Y_POSITIONATPOWERON_INVALID = exports.Y_POSITIONATPOWERON_INVALID = _yocto_api.YAPI.INVALID_INT;
//--- (end of YServo definitions)

//--- (YServo class start)
/**
 * YServo Class: Servo function interface
 *
 * Yoctopuce application programming interface allows you not only to move
 * a servo to a given position, but also to specify the time interval
 * in which the move should be performed. This makes it possible to
 * synchronize two servos involved in a same move.
 */
//--- (end of YServo class start)

class YServo extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YServo constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Servo';
        /** @member {number} **/
        this._position = Y_POSITION_INVALID;
        /** @member {number} **/
        this._enabled = Y_ENABLED_INVALID;
        /** @member {number} **/
        this._range = Y_RANGE_INVALID;
        /** @member {number} **/
        this._neutral = Y_NEUTRAL_INVALID;
        /** @member {YMove} **/
        this._move = Y_MOVE_INVALID;
        /** @member {number} **/
        this._positionAtPowerOn = Y_POSITIONATPOWERON_INVALID;
        /** @member {number} **/
        this._enabledAtPowerOn = Y_ENABLEDATPOWERON_INVALID;
        this.imm_setConst({
            POSITION_INVALID: _yocto_api.YAPI.INVALID_INT,
            ENABLED_FALSE: 0,
            ENABLED_TRUE: 1,
            ENABLED_INVALID: -1,
            RANGE_INVALID: _yocto_api.YAPI.INVALID_UINT,
            NEUTRAL_INVALID: _yocto_api.YAPI.INVALID_UINT,
            POSITIONATPOWERON_INVALID: _yocto_api.YAPI.INVALID_INT,
            ENABLEDATPOWERON_FALSE: 0,
            ENABLEDATPOWERON_TRUE: 1,
            ENABLEDATPOWERON_INVALID: -1
        });
        //--- (end of YServo constructor)
    }

    //--- (YServo implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'position':
                this._position = parseInt(val);
                return 1;
            case 'enabled':
                this._enabled = parseInt(val);
                return 1;
            case 'range':
                this._range = parseInt(val);
                return 1;
            case 'neutral':
                this._neutral = parseInt(val);
                return 1;
            case 'move':
                this._move = val;
                return 1;
            case 'positionAtPowerOn':
                this._positionAtPowerOn = parseInt(val);
                return 1;
            case 'enabledAtPowerOn':
                this._enabledAtPowerOn = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the current servo position.
     *
     * @return {number} an integer corresponding to the current servo position
     *
     * On failure, throws an exception or returns YServo.POSITION_INVALID.
     */
    get_position() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POSITION_INVALID;
                }
            }
            return _this._position;
        })();
    }

    /**
     * Changes immediately the servo driving position.
     *
     * @param newval {number} : an integer corresponding to immediately the servo driving position
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_position(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('position', rest_val);
        })();
    }

    /**
     * Returns the state of the servos.
     *
     * @return {number} either YServo.ENABLED_FALSE or YServo.ENABLED_TRUE, according to the state of the servos
     *
     * On failure, throws an exception or returns YServo.ENABLED_INVALID.
     */
    get_enabled() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLED_INVALID;
                }
            }
            return _this3._enabled;
        })();
    }

    /**
     * Stops or starts the servo.
     *
     * @param newval {number} : either YServo.ENABLED_FALSE or YServo.ENABLED_TRUE
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabled(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('enabled', rest_val);
        })();
    }

    /**
     * Returns the current range of use of the servo.
     *
     * @return {number} an integer corresponding to the current range of use of the servo
     *
     * On failure, throws an exception or returns YServo.RANGE_INVALID.
     */
    get_range() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RANGE_INVALID;
                }
            }
            return _this5._range;
        })();
    }

    /**
     * Changes the range of use of the servo, specified in per cents.
     * A range of 100% corresponds to a standard control signal, that varies
     * from 1 [ms] to 2 [ms], When using a servo that supports a double range,
     * from 0.5 [ms] to 2.5 [ms], you can select a range of 200%.
     * Be aware that using a range higher than what is supported by the servo
     * is likely to damage the servo. Remember to call the matching module
     * saveToFlash() method, otherwise this call will have no effect.
     *
     * @param newval {number} : an integer corresponding to the range of use of the servo, specified in per cents
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_range(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('range', rest_val);
        })();
    }

    /**
     * Returns the duration in microseconds of a neutral pulse for the servo.
     *
     * @return {number} an integer corresponding to the duration in microseconds of a neutral pulse for the servo
     *
     * On failure, throws an exception or returns YServo.NEUTRAL_INVALID.
     */
    get_neutral() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NEUTRAL_INVALID;
                }
            }
            return _this7._neutral;
        })();
    }

    /**
     * Changes the duration of the pulse corresponding to the neutral position of the servo.
     * The duration is specified in microseconds, and the standard value is 1500 [us].
     * This setting makes it possible to shift the range of use of the servo.
     * Be aware that using a range higher than what is supported by the servo is
     * likely to damage the servo. Remember to call the matching module
     * saveToFlash() method, otherwise this call will have no effect.
     *
     * @param newval {number} : an integer corresponding to the duration of the pulse corresponding to the
     * neutral position of the servo
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_neutral(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('neutral', rest_val);
        })();
    }

    get_move() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MOVE_INVALID;
                }
            }
            return _this9._move;
        })();
    }

    set_move(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval.target) + ':' + String(newval.ms);
            return yield _this10._setAttr('move', rest_val);
        })();
    }

    /**
     * Performs a smooth move at constant speed toward a given position.
     *
     * @param target      : new position at the end of the move
     * @param ms_duration {number} : total duration of the move, in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    move(target, ms_duration) {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(target) + ':' + String(ms_duration);
            return yield _this11._setAttr('move', rest_val);
        })();
    }

    /**
     * Returns the servo position at device power up.
     *
     * @return {number} an integer corresponding to the servo position at device power up
     *
     * On failure, throws an exception or returns YServo.POSITIONATPOWERON_INVALID.
     */
    get_positionAtPowerOn() {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            if (_this12._cacheExpiration <= _this12._yapi.GetTickCount()) {
                if ((yield _this12.load(_this12._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POSITIONATPOWERON_INVALID;
                }
            }
            return _this12._positionAtPowerOn;
        })();
    }

    /**
     * Configure the servo position at device power up. Remember to call the matching
     * module saveToFlash() method, otherwise this call will have no effect.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_positionAtPowerOn(newval) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this13._setAttr('positionAtPowerOn', rest_val);
        })();
    }

    /**
     * Returns the servo signal generator state at power up.
     *
     * @return {number} either YServo.ENABLEDATPOWERON_FALSE or YServo.ENABLEDATPOWERON_TRUE, according to
     * the servo signal generator state at power up
     *
     * On failure, throws an exception or returns YServo.ENABLEDATPOWERON_INVALID.
     */
    get_enabledAtPowerOn() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_ENABLEDATPOWERON_INVALID;
                }
            }
            return _this14._enabledAtPowerOn;
        })();
    }

    /**
     * Configure the servo signal generator state at power up. Remember to call the matching module saveToFlash()
     * method, otherwise this call will have no effect.
     *
     * @param newval {number} : either YServo.ENABLEDATPOWERON_FALSE or YServo.ENABLEDATPOWERON_TRUE
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_enabledAtPowerOn(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this15._setAttr('enabledAtPowerOn', rest_val);
        })();
    }

    /**
     * Retrieves a servo for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the servo is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YServo.isOnline() to test if the servo is
     * indeed online at a given time. In case of ambiguity when looking for
     * a servo by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the servo
     *
     * @return {YServo} a YServo object allowing you to drive the servo.
     */
    static FindServo(func) {
        /** @type {YServo} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Servo', func);
        if (obj == null) {
            obj = new YServo(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Servo', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a servo for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the servo is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YServo.isOnline() to test if the servo is
     * indeed online at a given time. In case of ambiguity when looking for
     * a servo by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the servo
     *
     * @return {YServo} a YServo object allowing you to drive the servo.
     */
    static FindServoInContext(yctx, func) {
        /** @type {YServo} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Servo', func);
        if (obj == null) {
            obj = new YServo(yctx, func);
            _yocto_api.YFunction._AddToCache('Servo', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of servos started using yFirstServo().
     *
     * @return {YServo} a pointer to a YServo object, corresponding to
     *         a servo currently online, or a null pointer
     *         if there are no more servos to enumerate.
     */
    /* */nextServo() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YServo.FindServoInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of servos currently accessible.
     * Use the method YServo.nextServo() to iterate on
     * next servos.
     *
     * @return {YServo} a pointer to a YServo object, corresponding to
     *         the first servo currently online, or a null pointer
     *         if there are none.
     */
    static FirstServo() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Servo');
        if (next_hwid == null) return null;
        return YServo.FindServo(next_hwid);
    }

    /**
     * Starts the enumeration of servos currently accessible.
     * Use the method YServo.nextServo() to iterate on
     * next servos.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YServo} a pointer to a YServo object, corresponding to
     *         the first servo currently online, or a null pointer
     *         if there are none.
     */
    static FirstServoInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Servo');
        if (next_hwid == null) return null;
        return YServo.FindServoInContext(yctx, next_hwid);
    }

    //--- (end of YServo implementation)
}

exports.YServo = YServo; //--- (Servo functions)

/**
 * comment from .yc definition
 */

function yFindServo(func) {
    return YServo.FindServo(func);
}

/**
 * comment from .yc definition
 */
function yFirstServo() {
    return YServo.FirstServo();
}

//--- (end of Servo functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Temperature functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YTemperature = exports.Y_COMMAND_INVALID = exports.Y_SENSORTYPE_INVALID = exports.Y_SENSORTYPE_RES_LINEAR = exports.Y_SENSORTYPE_RES_NTC = exports.Y_SENSORTYPE_RES_OHM = exports.Y_SENSORTYPE_PT100_2WIRES = exports.Y_SENSORTYPE_PT100_3WIRES = exports.Y_SENSORTYPE_PT100_4WIRES = exports.Y_SENSORTYPE_TYPE_T = exports.Y_SENSORTYPE_TYPE_S = exports.Y_SENSORTYPE_TYPE_R = exports.Y_SENSORTYPE_TYPE_N = exports.Y_SENSORTYPE_TYPE_J = exports.Y_SENSORTYPE_TYPE_E = exports.Y_SENSORTYPE_TYPE_K = exports.Y_SENSORTYPE_DIGITAL = undefined;
exports.yFindTemperature = yFindTemperature;
exports.yFirstTemperature = yFirstTemperature;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YTemperature return codes)
//--- (end of YTemperature return codes)
//--- (YTemperature definitions)
const Y_SENSORTYPE_DIGITAL = exports.Y_SENSORTYPE_DIGITAL = 0;
const Y_SENSORTYPE_TYPE_K = exports.Y_SENSORTYPE_TYPE_K = 1;
const Y_SENSORTYPE_TYPE_E = exports.Y_SENSORTYPE_TYPE_E = 2;
const Y_SENSORTYPE_TYPE_J = exports.Y_SENSORTYPE_TYPE_J = 3;
const Y_SENSORTYPE_TYPE_N = exports.Y_SENSORTYPE_TYPE_N = 4;
const Y_SENSORTYPE_TYPE_R = exports.Y_SENSORTYPE_TYPE_R = 5;
const Y_SENSORTYPE_TYPE_S = exports.Y_SENSORTYPE_TYPE_S = 6;
const Y_SENSORTYPE_TYPE_T = exports.Y_SENSORTYPE_TYPE_T = 7;
const Y_SENSORTYPE_PT100_4WIRES = exports.Y_SENSORTYPE_PT100_4WIRES = 8;
const Y_SENSORTYPE_PT100_3WIRES = exports.Y_SENSORTYPE_PT100_3WIRES = 9;
const Y_SENSORTYPE_PT100_2WIRES = exports.Y_SENSORTYPE_PT100_2WIRES = 10;
const Y_SENSORTYPE_RES_OHM = exports.Y_SENSORTYPE_RES_OHM = 11;
const Y_SENSORTYPE_RES_NTC = exports.Y_SENSORTYPE_RES_NTC = 12;
const Y_SENSORTYPE_RES_LINEAR = exports.Y_SENSORTYPE_RES_LINEAR = 13;
const Y_SENSORTYPE_INVALID = exports.Y_SENSORTYPE_INVALID = -1;
const Y_COMMAND_INVALID = exports.Y_COMMAND_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of YTemperature definitions)

//--- (YTemperature class start)
/**
 * YTemperature Class: Temperature function interface
 *
 * The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 * This class adds the ability to configure some specific parameters for some
 * sensors (connection type, temperature mapping table).
 */
//--- (end of YTemperature class start)

class YTemperature extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YTemperature constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Temperature';
        /** @member {number} **/
        this._sensorType = Y_SENSORTYPE_INVALID;
        /** @member {string} **/
        this._command = Y_COMMAND_INVALID;
        this.imm_setConst({
            SENSORTYPE_DIGITAL: 0,
            SENSORTYPE_TYPE_K: 1,
            SENSORTYPE_TYPE_E: 2,
            SENSORTYPE_TYPE_J: 3,
            SENSORTYPE_TYPE_N: 4,
            SENSORTYPE_TYPE_R: 5,
            SENSORTYPE_TYPE_S: 6,
            SENSORTYPE_TYPE_T: 7,
            SENSORTYPE_PT100_4WIRES: 8,
            SENSORTYPE_PT100_3WIRES: 9,
            SENSORTYPE_PT100_2WIRES: 10,
            SENSORTYPE_RES_OHM: 11,
            SENSORTYPE_RES_NTC: 12,
            SENSORTYPE_RES_LINEAR: 13,
            SENSORTYPE_INVALID: -1,
            COMMAND_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of YTemperature constructor)
    }

    //--- (YTemperature implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'sensorType':
                this._sensorType = parseInt(val);
                return 1;
            case 'command':
                this._command = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Changes the measuring unit for the measured temperature. That unit is a string.
     * If that strings end with the letter F all temperatures values will returned in
     * Fahrenheit degrees. If that String ends with the letter K all values will be
     * returned in Kelvin degrees. If that string ends with the letter C all values will be
     * returned in Celsius degrees.  If the string ends with any other character the
     * change will be ignored. Remember to call the
     * saveToFlash() method of the module if the modification must be kept.
     * WARNING: if a specific calibration is defined for the temperature function, a
     * unit system change will probably break it.
     *
     * @param newval {string} : a string corresponding to the measuring unit for the measured temperature
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_unit(newval) {
        var _this = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this._setAttr('unit', rest_val);
        })();
    }

    /**
     * Returns the temperature sensor type.
     *
     * @return {number} a value among YTemperature.SENSORTYPE_DIGITAL, YTemperature.SENSORTYPE_TYPE_K,
     * YTemperature.SENSORTYPE_TYPE_E, YTemperature.SENSORTYPE_TYPE_J, YTemperature.SENSORTYPE_TYPE_N,
     * YTemperature.SENSORTYPE_TYPE_R, YTemperature.SENSORTYPE_TYPE_S, YTemperature.SENSORTYPE_TYPE_T,
     * YTemperature.SENSORTYPE_PT100_4WIRES, YTemperature.SENSORTYPE_PT100_3WIRES,
     * YTemperature.SENSORTYPE_PT100_2WIRES, YTemperature.SENSORTYPE_RES_OHM,
     * YTemperature.SENSORTYPE_RES_NTC and YTemperature.SENSORTYPE_RES_LINEAR corresponding to the
     * temperature sensor type
     *
     * On failure, throws an exception or returns YTemperature.SENSORTYPE_INVALID.
     */
    get_sensorType() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SENSORTYPE_INVALID;
                }
            }
            return _this2._sensorType;
        })();
    }

    /**
     * Modifies the temperature sensor type.  This function is used
     * to define the type of thermocouple (K,E...) used with the device.
     * It has no effect if module is using a digital sensor or a thermistor.
     * Remember to call the saveToFlash() method of the module if the
     * modification must be kept.
     *
     * @param newval {number} : a value among YTemperature.SENSORTYPE_DIGITAL,
     * YTemperature.SENSORTYPE_TYPE_K, YTemperature.SENSORTYPE_TYPE_E, YTemperature.SENSORTYPE_TYPE_J,
     * YTemperature.SENSORTYPE_TYPE_N, YTemperature.SENSORTYPE_TYPE_R, YTemperature.SENSORTYPE_TYPE_S,
     * YTemperature.SENSORTYPE_TYPE_T, YTemperature.SENSORTYPE_PT100_4WIRES,
     * YTemperature.SENSORTYPE_PT100_3WIRES, YTemperature.SENSORTYPE_PT100_2WIRES,
     * YTemperature.SENSORTYPE_RES_OHM, YTemperature.SENSORTYPE_RES_NTC and YTemperature.SENSORTYPE_RES_LINEAR
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_sensorType(newval) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this3._setAttr('sensorType', rest_val);
        })();
    }

    get_command() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COMMAND_INVALID;
                }
            }
            return _this4._command;
        })();
    }

    set_command(newval) {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this5._setAttr('command', rest_val);
        })();
    }

    /**
     * Retrieves a temperature sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the temperature sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YTemperature.isOnline() to test if the temperature sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a temperature sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the temperature sensor
     *
     * @return {YTemperature} a YTemperature object allowing you to drive the temperature sensor.
     */
    static FindTemperature(func) {
        /** @type {YTemperature} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Temperature', func);
        if (obj == null) {
            obj = new YTemperature(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Temperature', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a temperature sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the temperature sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YTemperature.isOnline() to test if the temperature sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a temperature sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the temperature sensor
     *
     * @return {YTemperature} a YTemperature object allowing you to drive the temperature sensor.
     */
    static FindTemperatureInContext(yctx, func) {
        /** @type {YTemperature} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Temperature', func);
        if (obj == null) {
            obj = new YTemperature(yctx, func);
            _yocto_api.YFunction._AddToCache('Temperature', func, obj);
        }
        return obj;
    }

    /**
     * Configure NTC thermistor parameters in order to properly compute the temperature from
     * the measured resistance. For increased precision, you can enter a complete mapping
     * table using set_thermistorResponseTable. This function can only be used with a
     * temperature sensor based on thermistors.
     *
     * @param res25 {number} : thermistor resistance at 25 degrees Celsius
     * @param beta {number} : Beta value
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_ntcParameters(res25, beta) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let t0;
            /** @type {number} **/
            let t1;
            /** @type {number} **/
            let res100;
            /** @type {number[]} **/
            let tempValues = [];
            /** @type {number[]} **/
            let resValues = [];
            t0 = 25.0 + 275.15;
            t1 = 100.0 + 275.15;
            res100 = res25 * Math.exp(beta * (1.0 / t1 - 1.0 / t0));
            tempValues.length = 0;
            resValues.length = 0;
            tempValues.push(25.0);
            resValues.push(res25);
            tempValues.push(100.0);
            resValues.push(res100);
            return yield _this6.set_thermistorResponseTable(tempValues, resValues);
        })();
    }

    /**
     * Records a thermistor response table, in order to interpolate the temperature from
     * the measured resistance. This function can only be used with a temperature
     * sensor based on thermistors.
     *
     * @param tempValues {number[]} : array of floating point numbers, corresponding to all
     *         temperatures (in degrees Celcius) for which the resistance of the
     *         thermistor is specified.
     * @param resValues {number[]} : array of floating point numbers, corresponding to the resistance
     *         values (in Ohms) for each of the temperature included in the first
     *         argument, index by index.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_thermistorResponseTable(tempValues, resValues) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let siz;
            /** @type {number} **/
            let res;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let found;
            /** @type {number} **/
            let prev;
            /** @type {number} **/
            let curr;
            /** @type {number} **/
            let currTemp;
            /** @type {number} **/
            let idxres;
            siz = tempValues.length;
            if (!(siz >= 2)) {
                return _this7._throw(YAPI_INVALID_ARGUMENT, 'thermistor response table must have at least two points', YAPI_INVALID_ARGUMENT);
            }
            if (!(siz == resValues.length)) {
                return _this7._throw(YAPI_INVALID_ARGUMENT, 'table sizes mismatch', YAPI_INVALID_ARGUMENT);
            }
            // may throw an exception
            res = yield _this7.set_command('Z');
            if (!(res == _yocto_api.YAPI_SUCCESS)) {
                return _this7._throw(YAPI_IO_ERROR, 'unable to reset thermistor parameters', YAPI_IO_ERROR);
            }
            // add records in growing resistance value
            found = 1;
            prev = 0.0;
            while (found > 0) {
                found = 0;
                curr = 99999999.0;
                currTemp = -999999.0;
                idx = 0;
                while (idx < siz) {
                    idxres = resValues[idx];
                    if (idxres > prev && idxres < curr) {
                        curr = idxres;
                        currTemp = tempValues[idx];
                        found = 1;
                    }
                    idx = idx + 1;
                }
                if (found > 0) {
                    res = yield _this7.set_command('m' + String(Math.round(Math.round(1000 * curr))) + ':' + String(Math.round(Math.round(1000 * currTemp))));
                    if (!(res == _yocto_api.YAPI_SUCCESS)) {
                        return _this7._throw(YAPI_IO_ERROR, 'unable to reset thermistor parameters', YAPI_IO_ERROR);
                    }
                    prev = curr;
                }
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Retrieves the thermistor response table previously configured using the
     * set_thermistorResponseTable function. This function can only be used with a
     * temperature sensor based on thermistors.
     *
     * @param tempValues {number[]} : array of floating point numbers, that is filled by the function
     *         with all temperatures (in degrees Celcius) for which the resistance
     *         of the thermistor is specified.
     * @param resValues {number[]} : array of floating point numbers, that is filled by the function
     *         with the value (in Ohms) for each of the temperature included in the
     *         first argument, index by index.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    loadThermistorResponseTable(tempValues, resValues) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let id;
            /** @type {Uint8Array} **/
            let bin_json;
            /** @type {string[]} **/
            let paramlist = [];
            /** @type {number[]} **/
            let templist = [];
            /** @type {number} **/
            let siz;
            /** @type {number} **/
            let idx;
            /** @type {number} **/
            let temp;
            /** @type {number} **/
            let found;
            /** @type {number} **/
            let prev;
            /** @type {number} **/
            let curr;
            /** @type {number} **/
            let currRes;
            tempValues.length = 0;
            resValues.length = 0;
            // may throw an exception
            id = yield _this8.get_functionId();
            id = id.substr(11, id.length - 11);
            bin_json = yield _this8._download('extra.json?page=' + id);
            paramlist = _this8.imm_json_get_array(bin_json);
            // first convert all temperatures to float
            siz = paramlist.length >> 1;
            templist.length = 0;
            idx = 0;
            while (idx < siz) {
                temp = parseFloat(paramlist[2 * idx + 1]) / 1000.0;
                templist.push(temp);
                idx = idx + 1;
            }
            // then add records in growing temperature value
            tempValues.length = 0;
            resValues.length = 0;
            found = 1;
            prev = -999999.0;
            while (found > 0) {
                found = 0;
                curr = 999999.0;
                currRes = -999999.0;
                idx = 0;
                while (idx < siz) {
                    temp = templist[idx];
                    if (temp > prev && temp < curr) {
                        curr = temp;
                        currRes = parseFloat(paramlist[2 * idx]) / 1000.0;
                        found = 1;
                    }
                    idx = idx + 1;
                }
                if (found > 0) {
                    tempValues.push(curr);
                    resValues.push(currRes);
                    prev = curr;
                }
            }
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Continues the enumeration of temperature sensors started using yFirstTemperature().
     *
     * @return {YTemperature} a pointer to a YTemperature object, corresponding to
     *         a temperature sensor currently online, or a null pointer
     *         if there are no more temperature sensors to enumerate.
     */
    /* */nextTemperature() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YTemperature.FindTemperatureInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of temperature sensors currently accessible.
     * Use the method YTemperature.nextTemperature() to iterate on
     * next temperature sensors.
     *
     * @return {YTemperature} a pointer to a YTemperature object, corresponding to
     *         the first temperature sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstTemperature() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Temperature');
        if (next_hwid == null) return null;
        return YTemperature.FindTemperature(next_hwid);
    }

    /**
     * Starts the enumeration of temperature sensors currently accessible.
     * Use the method YTemperature.nextTemperature() to iterate on
     * next temperature sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YTemperature} a pointer to a YTemperature object, corresponding to
     *         the first temperature sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstTemperatureInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Temperature');
        if (next_hwid == null) return null;
        return YTemperature.FindTemperatureInContext(yctx, next_hwid);
    }

    //--- (end of YTemperature implementation)
}

exports.YTemperature = YTemperature; //--- (Temperature functions)

/**
 * comment from .yc definition
 */

function yFindTemperature(func) {
    return YTemperature.FindTemperature(func);
}

/**
 * comment from .yc definition
 */
function yFirstTemperature() {
    return YTemperature.FirstTemperature();
}

//--- (end of Temperature functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Tilt functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YTilt = exports.Y_AXIS_INVALID = exports.Y_AXIS_Z = exports.Y_AXIS_Y = exports.Y_AXIS_X = undefined;
exports.yFindTilt = yFindTilt;
exports.yFirstTilt = yFirstTilt;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YTilt return codes)
//--- (end of YTilt return codes)
//--- (YTilt definitions)
const Y_AXIS_X = exports.Y_AXIS_X = 0;
const Y_AXIS_Y = exports.Y_AXIS_Y = 1;
const Y_AXIS_Z = exports.Y_AXIS_Z = 2;
const Y_AXIS_INVALID = exports.Y_AXIS_INVALID = -1;
//--- (end of YTilt definitions)

//--- (YTilt class start)
/**
 * YTilt Class: Tilt function interface
 *
 * The YSensor class is the parent class for all Yoctopuce sensors. It can be
 * used to read the current value and unit of any sensor, read the min/max
 * value, configure autonomous recording frequency and access recorded data.
 * It also provide a function to register a callback invoked each time the
 * observed value changes, or at a predefined interval. Using this class rather
 * than a specific subclass makes it possible to create generic applications
 * that work with any Yoctopuce sensor, even those that do not yet exist.
 * Note: The YAnButton class is the only analog input which does not inherit
 * from YSensor.
 */
//--- (end of YTilt class start)

class YTilt extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YTilt constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Tilt';
        /** @member {number} **/
        this._axis = Y_AXIS_INVALID;
        this.imm_setConst({
            AXIS_X: 0,
            AXIS_Y: 1,
            AXIS_Z: 2,
            AXIS_INVALID: -1
        });
        //--- (end of YTilt constructor)
    }

    //--- (YTilt implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'axis':
                this._axis = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    get_axis() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_AXIS_INVALID;
                }
            }
            return _this._axis;
        })();
    }

    /**
     * Retrieves a tilt sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the tilt sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YTilt.isOnline() to test if the tilt sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a tilt sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the tilt sensor
     *
     * @return {YTilt} a YTilt object allowing you to drive the tilt sensor.
     */
    static FindTilt(func) {
        /** @type {YTilt} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Tilt', func);
        if (obj == null) {
            obj = new YTilt(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Tilt', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a tilt sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the tilt sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YTilt.isOnline() to test if the tilt sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a tilt sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the tilt sensor
     *
     * @return {YTilt} a YTilt object allowing you to drive the tilt sensor.
     */
    static FindTiltInContext(yctx, func) {
        /** @type {YTilt} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Tilt', func);
        if (obj == null) {
            obj = new YTilt(yctx, func);
            _yocto_api.YFunction._AddToCache('Tilt', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of tilt sensors started using yFirstTilt().
     *
     * @return {YTilt} a pointer to a YTilt object, corresponding to
     *         a tilt sensor currently online, or a null pointer
     *         if there are no more tilt sensors to enumerate.
     */
    /* */nextTilt() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YTilt.FindTiltInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of tilt sensors currently accessible.
     * Use the method YTilt.nextTilt() to iterate on
     * next tilt sensors.
     *
     * @return {YTilt} a pointer to a YTilt object, corresponding to
     *         the first tilt sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstTilt() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Tilt');
        if (next_hwid == null) return null;
        return YTilt.FindTilt(next_hwid);
    }

    /**
     * Starts the enumeration of tilt sensors currently accessible.
     * Use the method YTilt.nextTilt() to iterate on
     * next tilt sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YTilt} a pointer to a YTilt object, corresponding to
     *         the first tilt sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstTiltInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Tilt');
        if (next_hwid == null) return null;
        return YTilt.FindTiltInContext(yctx, next_hwid);
    }

    //--- (end of YTilt implementation)
}

exports.YTilt = YTilt; //--- (Tilt functions)

/**
 * comment from .yc definition
 */

function yFindTilt(func) {
    return YTilt.FindTilt(func);
}

/**
 * comment from .yc definition
 */
function yFirstTilt() {
    return YTilt.FirstTilt();
}

//--- (end of Tilt functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Voc functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YVoc = undefined;
exports.yFindVoc = yFindVoc;
exports.yFirstVoc = yFirstVoc;

var _yocto_api = require('lib/yocto_api');

//--- (YVoc return codes)
//--- (end of YVoc return codes)
//--- (YVoc definitions)
//--- (end of YVoc definitions)

//--- (YVoc class start)
/**
 * YVoc Class: Voc function interface
 *
 * The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic
 * Compound sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YVoc class start)

class YVoc extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YVoc constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Voc';
        //--- (end of YVoc constructor)
    }

    //--- (YVoc implementation)

    /**
     * Retrieves a Volatile Organic Compound sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the Volatile Organic Compound sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YVoc.isOnline() to test if the Volatile Organic Compound sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a Volatile Organic Compound sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the Volatile Organic Compound sensor
     *
     * @return {YVoc} a YVoc object allowing you to drive the Volatile Organic Compound sensor.
     */
    static FindVoc(func) {
        /** @type {YVoc} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Voc', func);
        if (obj == null) {
            obj = new YVoc(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Voc', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a Volatile Organic Compound sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the Volatile Organic Compound sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YVoc.isOnline() to test if the Volatile Organic Compound sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a Volatile Organic Compound sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the Volatile Organic Compound sensor
     *
     * @return {YVoc} a YVoc object allowing you to drive the Volatile Organic Compound sensor.
     */
    static FindVocInContext(yctx, func) {
        /** @type {YVoc} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Voc', func);
        if (obj == null) {
            obj = new YVoc(yctx, func);
            _yocto_api.YFunction._AddToCache('Voc', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of Volatile Organic Compound sensors started using yFirstVoc().
     *
     * @return {YVoc} a pointer to a YVoc object, corresponding to
     *         a Volatile Organic Compound sensor currently online, or a null pointer
     *         if there are no more Volatile Organic Compound sensors to enumerate.
     */
    /* */nextVoc() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YVoc.FindVocInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of Volatile Organic Compound sensors currently accessible.
     * Use the method YVoc.nextVoc() to iterate on
     * next Volatile Organic Compound sensors.
     *
     * @return {YVoc} a pointer to a YVoc object, corresponding to
     *         the first Volatile Organic Compound sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstVoc() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Voc');
        if (next_hwid == null) return null;
        return YVoc.FindVoc(next_hwid);
    }

    /**
     * Starts the enumeration of Volatile Organic Compound sensors currently accessible.
     * Use the method YVoc.nextVoc() to iterate on
     * next Volatile Organic Compound sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YVoc} a pointer to a YVoc object, corresponding to
     *         the first Volatile Organic Compound sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstVocInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Voc');
        if (next_hwid == null) return null;
        return YVoc.FindVocInContext(yctx, next_hwid);
    }

    //--- (end of YVoc implementation)
}

exports.YVoc = YVoc; //--- (Voc functions)

/**
 * comment from .yc definition
 */

function yFindVoc(func) {
    return YVoc.FindVoc(func);
}

/**
 * comment from .yc definition
 */
function yFirstVoc() {
    return YVoc.FirstVoc();
}

//--- (end of Voc functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Voltage functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YVoltage = undefined;
exports.yFindVoltage = yFindVoltage;
exports.yFirstVoltage = yFirstVoltage;

var _yocto_api = require('lib/yocto_api');

//--- (YVoltage return codes)
//--- (end of YVoltage return codes)
//--- (YVoltage definitions)
//--- (end of YVoltage definitions)

//--- (YVoltage class start)
/**
 * YVoltage Class: Voltage function interface
 *
 * The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage
 * sensors. It inherits from YSensor class the core functions to read measurements,
 * register callback functions, access to the autonomous datalogger.
 */
//--- (end of YVoltage class start)

class YVoltage extends _yocto_api.YSensor {
    constructor(obj_yapi, str_func) {
        //--- (YVoltage constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Voltage';
        //--- (end of YVoltage constructor)
    }

    //--- (YVoltage implementation)

    /**
     * Retrieves a voltage sensor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the voltage sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YVoltage.isOnline() to test if the voltage sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a voltage sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the voltage sensor
     *
     * @return {YVoltage} a YVoltage object allowing you to drive the voltage sensor.
     */
    static FindVoltage(func) {
        /** @type {YVoltage} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Voltage', func);
        if (obj == null) {
            obj = new YVoltage(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Voltage', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a voltage sensor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the voltage sensor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YVoltage.isOnline() to test if the voltage sensor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a voltage sensor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the voltage sensor
     *
     * @return {YVoltage} a YVoltage object allowing you to drive the voltage sensor.
     */
    static FindVoltageInContext(yctx, func) {
        /** @type {YVoltage} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Voltage', func);
        if (obj == null) {
            obj = new YVoltage(yctx, func);
            _yocto_api.YFunction._AddToCache('Voltage', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of voltage sensors started using yFirstVoltage().
     *
     * @return {YVoltage} a pointer to a YVoltage object, corresponding to
     *         a voltage sensor currently online, or a null pointer
     *         if there are no more voltage sensors to enumerate.
     */
    /* */nextVoltage() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YVoltage.FindVoltageInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of voltage sensors currently accessible.
     * Use the method YVoltage.nextVoltage() to iterate on
     * next voltage sensors.
     *
     * @return {YVoltage} a pointer to a YVoltage object, corresponding to
     *         the first voltage sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstVoltage() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Voltage');
        if (next_hwid == null) return null;
        return YVoltage.FindVoltage(next_hwid);
    }

    /**
     * Starts the enumeration of voltage sensors currently accessible.
     * Use the method YVoltage.nextVoltage() to iterate on
     * next voltage sensors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YVoltage} a pointer to a YVoltage object, corresponding to
     *         the first voltage sensor currently online, or a null pointer
     *         if there are none.
     */
    static FirstVoltageInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Voltage');
        if (next_hwid == null) return null;
        return YVoltage.FindVoltageInContext(yctx, next_hwid);
    }

    //--- (end of YVoltage implementation)
}

exports.YVoltage = YVoltage; //--- (Voltage functions)

/**
 * comment from .yc definition
 */

function yFindVoltage(func) {
    return YVoltage.FindVoltage(func);
}

/**
 * comment from .yc definition
 */
function yFirstVoltage() {
    return YVoltage.FirstVoltage();
}

//--- (end of Voltage functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for WakeUpMonitor functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YWakeUpMonitor = exports.Y_RTCTIME_INVALID = exports.Y_NEXTWAKEUP_INVALID = exports.Y_SLEEPCOUNTDOWN_INVALID = exports.Y_POWERDURATION_INVALID = exports.Y_WAKEUPSTATE_INVALID = exports.Y_WAKEUPSTATE_AWAKE = exports.Y_WAKEUPSTATE_SLEEPING = exports.Y_WAKEUPREASON_INVALID = exports.Y_WAKEUPREASON_SCHEDULE2 = exports.Y_WAKEUPREASON_SCHEDULE1 = exports.Y_WAKEUPREASON_EXTSIG1 = exports.Y_WAKEUPREASON_ENDOFSLEEP = exports.Y_WAKEUPREASON_EXTPOWER = exports.Y_WAKEUPREASON_USBPOWER = undefined;
exports.yFindWakeUpMonitor = yFindWakeUpMonitor;
exports.yFirstWakeUpMonitor = yFirstWakeUpMonitor;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YWakeUpMonitor return codes)
//--- (end of YWakeUpMonitor return codes)
//--- (YWakeUpMonitor definitions)
const Y_WAKEUPREASON_USBPOWER = exports.Y_WAKEUPREASON_USBPOWER = 0;
const Y_WAKEUPREASON_EXTPOWER = exports.Y_WAKEUPREASON_EXTPOWER = 1;
const Y_WAKEUPREASON_ENDOFSLEEP = exports.Y_WAKEUPREASON_ENDOFSLEEP = 2;
const Y_WAKEUPREASON_EXTSIG1 = exports.Y_WAKEUPREASON_EXTSIG1 = 3;
const Y_WAKEUPREASON_SCHEDULE1 = exports.Y_WAKEUPREASON_SCHEDULE1 = 4;
const Y_WAKEUPREASON_SCHEDULE2 = exports.Y_WAKEUPREASON_SCHEDULE2 = 5;
const Y_WAKEUPREASON_INVALID = exports.Y_WAKEUPREASON_INVALID = -1;
const Y_WAKEUPSTATE_SLEEPING = exports.Y_WAKEUPSTATE_SLEEPING = 0;
const Y_WAKEUPSTATE_AWAKE = exports.Y_WAKEUPSTATE_AWAKE = 1;
const Y_WAKEUPSTATE_INVALID = exports.Y_WAKEUPSTATE_INVALID = -1;
const Y_POWERDURATION_INVALID = exports.Y_POWERDURATION_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_SLEEPCOUNTDOWN_INVALID = exports.Y_SLEEPCOUNTDOWN_INVALID = _yocto_api.YAPI.INVALID_INT;
const Y_NEXTWAKEUP_INVALID = exports.Y_NEXTWAKEUP_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_RTCTIME_INVALID = exports.Y_RTCTIME_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YWakeUpMonitor definitions)

//--- (YWakeUpMonitor class start)
/**
 * YWakeUpMonitor Class: WakeUpMonitor function interface
 *
 * The WakeUpMonitor function handles globally all wake-up sources, as well
 * as automated sleep mode.
 */
//--- (end of YWakeUpMonitor class start)

class YWakeUpMonitor extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YWakeUpMonitor constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'WakeUpMonitor';
        /** @member {number} **/
        this._powerDuration = Y_POWERDURATION_INVALID;
        /** @member {number} **/
        this._sleepCountdown = Y_SLEEPCOUNTDOWN_INVALID;
        /** @member {number} **/
        this._nextWakeUp = Y_NEXTWAKEUP_INVALID;
        /** @member {number} **/
        this._wakeUpReason = Y_WAKEUPREASON_INVALID;
        /** @member {number} **/
        this._wakeUpState = Y_WAKEUPSTATE_INVALID;
        /** @member {number} **/
        this._rtcTime = Y_RTCTIME_INVALID;
        /** @member {number} **/
        this._endOfTime = 2145960000;
        this.imm_setConst({
            POWERDURATION_INVALID: _yocto_api.YAPI.INVALID_INT,
            SLEEPCOUNTDOWN_INVALID: _yocto_api.YAPI.INVALID_INT,
            NEXTWAKEUP_INVALID: _yocto_api.YAPI.INVALID_LONG,
            WAKEUPREASON_USBPOWER: 0,
            WAKEUPREASON_EXTPOWER: 1,
            WAKEUPREASON_ENDOFSLEEP: 2,
            WAKEUPREASON_EXTSIG1: 3,
            WAKEUPREASON_SCHEDULE1: 4,
            WAKEUPREASON_SCHEDULE2: 5,
            WAKEUPREASON_INVALID: -1,
            WAKEUPSTATE_SLEEPING: 0,
            WAKEUPSTATE_AWAKE: 1,
            WAKEUPSTATE_INVALID: -1,
            RTCTIME_INVALID: _yocto_api.YAPI.INVALID_LONG
        });
        //--- (end of YWakeUpMonitor constructor)
    }

    //--- (YWakeUpMonitor implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'powerDuration':
                this._powerDuration = parseInt(val);
                return 1;
            case 'sleepCountdown':
                this._sleepCountdown = parseInt(val);
                return 1;
            case 'nextWakeUp':
                this._nextWakeUp = parseInt(val);
                return 1;
            case 'wakeUpReason':
                this._wakeUpReason = parseInt(val);
                return 1;
            case 'wakeUpState':
                this._wakeUpState = parseInt(val);
                return 1;
            case 'rtcTime':
                this._rtcTime = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the maximal wake up time (in seconds) before automatically going to sleep.
     *
     * @return {number} an integer corresponding to the maximal wake up time (in seconds) before
     * automatically going to sleep
     *
     * On failure, throws an exception or returns YWakeUpMonitor.POWERDURATION_INVALID.
     */
    get_powerDuration() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_POWERDURATION_INVALID;
                }
            }
            return _this._powerDuration;
        })();
    }

    /**
     * Changes the maximal wake up time (seconds) before automatically going to sleep.
     *
     * @param newval {number} : an integer corresponding to the maximal wake up time (seconds) before
     * automatically going to sleep
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_powerDuration(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('powerDuration', rest_val);
        })();
    }

    /**
     * Returns the delay before the  next sleep period.
     *
     * @return {number} an integer corresponding to the delay before the  next sleep period
     *
     * On failure, throws an exception or returns YWakeUpMonitor.SLEEPCOUNTDOWN_INVALID.
     */
    get_sleepCountdown() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SLEEPCOUNTDOWN_INVALID;
                }
            }
            return _this3._sleepCountdown;
        })();
    }

    /**
     * Changes the delay before the next sleep period.
     *
     * @param newval {number} : an integer corresponding to the delay before the next sleep period
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_sleepCountdown(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('sleepCountdown', rest_val);
        })();
    }

    /**
     * Returns the next scheduled wake up date/time (UNIX format)
     *
     * @return {number} an integer corresponding to the next scheduled wake up date/time (UNIX format)
     *
     * On failure, throws an exception or returns YWakeUpMonitor.NEXTWAKEUP_INVALID.
     */
    get_nextWakeUp() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NEXTWAKEUP_INVALID;
                }
            }
            return _this5._nextWakeUp;
        })();
    }

    /**
     * Changes the days of the week when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the days of the week when a wake up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_nextWakeUp(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('nextWakeUp', rest_val);
        })();
    }

    /**
     * Returns the latest wake up reason.
     *
     * @return {number} a value among YWakeUpMonitor.WAKEUPREASON_USBPOWER,
     * YWakeUpMonitor.WAKEUPREASON_EXTPOWER, YWakeUpMonitor.WAKEUPREASON_ENDOFSLEEP,
     * YWakeUpMonitor.WAKEUPREASON_EXTSIG1, YWakeUpMonitor.WAKEUPREASON_SCHEDULE1 and
     * YWakeUpMonitor.WAKEUPREASON_SCHEDULE2 corresponding to the latest wake up reason
     *
     * On failure, throws an exception or returns YWakeUpMonitor.WAKEUPREASON_INVALID.
     */
    get_wakeUpReason() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_WAKEUPREASON_INVALID;
                }
            }
            return _this7._wakeUpReason;
        })();
    }

    /**
     * Returns  the current state of the monitor
     *
     * @return {number} either YWakeUpMonitor.WAKEUPSTATE_SLEEPING or YWakeUpMonitor.WAKEUPSTATE_AWAKE,
     * according to  the current state of the monitor
     *
     * On failure, throws an exception or returns YWakeUpMonitor.WAKEUPSTATE_INVALID.
     */
    get_wakeUpState() {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            if (_this8._cacheExpiration <= _this8._yapi.GetTickCount()) {
                if ((yield _this8.load(_this8._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_WAKEUPSTATE_INVALID;
                }
            }
            return _this8._wakeUpState;
        })();
    }

    set_wakeUpState(newval) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this9._setAttr('wakeUpState', rest_val);
        })();
    }

    get_rtcTime() {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            if (_this10._cacheExpiration <= _this10._yapi.GetTickCount()) {
                if ((yield _this10.load(_this10._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RTCTIME_INVALID;
                }
            }
            return _this10._rtcTime;
        })();
    }

    /**
     * Retrieves a monitor for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the monitor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWakeUpMonitor.isOnline() to test if the monitor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a monitor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the monitor
     *
     * @return {YWakeUpMonitor} a YWakeUpMonitor object allowing you to drive the monitor.
     */
    static FindWakeUpMonitor(func) {
        /** @type {YWakeUpMonitor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('WakeUpMonitor', func);
        if (obj == null) {
            obj = new YWakeUpMonitor(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('WakeUpMonitor', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a monitor for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the monitor is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWakeUpMonitor.isOnline() to test if the monitor is
     * indeed online at a given time. In case of ambiguity when looking for
     * a monitor by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the monitor
     *
     * @return {YWakeUpMonitor} a YWakeUpMonitor object allowing you to drive the monitor.
     */
    static FindWakeUpMonitorInContext(yctx, func) {
        /** @type {YWakeUpMonitor} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'WakeUpMonitor', func);
        if (obj == null) {
            obj = new YWakeUpMonitor(yctx, func);
            _yocto_api.YFunction._AddToCache('WakeUpMonitor', func, obj);
        }
        return obj;
    }

    /**
     * Forces a wake up.
     */
    wakeUp() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            return yield _this11.set_wakeUpState(Y_WAKEUPSTATE_AWAKE);
        })();
    }

    /**
     * Goes to sleep until the next wake up condition is met,  the
     * RTC time must have been set before calling this function.
     *
     * @param secBeforeSleep {number} : number of seconds before going into sleep mode,
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    sleep(secBeforeSleep) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let currTime;
            currTime = yield _this12.get_rtcTime();
            if (!(currTime != 0)) {
                return _this12._throw(YAPI_RTC_NOT_READY, 'RTC time not set', YAPI_RTC_NOT_READY);
            }
            yield _this12.set_nextWakeUp(_this12._endOfTime);
            yield _this12.set_sleepCountdown(secBeforeSleep);
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Goes to sleep for a specific duration or until the next wake up condition is met, the
     * RTC time must have been set before calling this function. The count down before sleep
     * can be canceled with resetSleepCountDown.
     *
     * @param secUntilWakeUp {number} : number of seconds before next wake up
     * @param secBeforeSleep {number} : number of seconds before going into sleep mode
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    sleepFor(secUntilWakeUp, secBeforeSleep) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let currTime;
            currTime = yield _this13.get_rtcTime();
            if (!(currTime != 0)) {
                return _this13._throw(YAPI_RTC_NOT_READY, 'RTC time not set', YAPI_RTC_NOT_READY);
            }
            yield _this13.set_nextWakeUp(currTime + secUntilWakeUp);
            yield _this13.set_sleepCountdown(secBeforeSleep);
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Go to sleep until a specific date is reached or until the next wake up condition is met, the
     * RTC time must have been set before calling this function. The count down before sleep
     * can be canceled with resetSleepCountDown.
     *
     * @param wakeUpTime {number} : wake-up datetime (UNIX format)
     * @param secBeforeSleep {number} : number of seconds before going into sleep mode
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    sleepUntil(wakeUpTime, secBeforeSleep) {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let currTime;
            currTime = yield _this14.get_rtcTime();
            if (!(currTime != 0)) {
                return _this14._throw(YAPI_RTC_NOT_READY, 'RTC time not set', YAPI_RTC_NOT_READY);
            }
            yield _this14.set_nextWakeUp(wakeUpTime);
            yield _this14.set_sleepCountdown(secBeforeSleep);
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Resets the sleep countdown.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *         On failure, throws an exception or returns a negative error code.
     */
    resetSleepCountDown() {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            yield _this15.set_sleepCountdown(0);
            yield _this15.set_nextWakeUp(0);
            return _yocto_api.YAPI_SUCCESS;
        })();
    }

    /**
     * Continues the enumeration of monitors started using yFirstWakeUpMonitor().
     *
     * @return {YWakeUpMonitor} a pointer to a YWakeUpMonitor object, corresponding to
     *         a monitor currently online, or a null pointer
     *         if there are no more monitors to enumerate.
     */
    /* */nextWakeUpMonitor() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YWakeUpMonitor.FindWakeUpMonitorInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of monitors currently accessible.
     * Use the method YWakeUpMonitor.nextWakeUpMonitor() to iterate on
     * next monitors.
     *
     * @return {YWakeUpMonitor} a pointer to a YWakeUpMonitor object, corresponding to
     *         the first monitor currently online, or a null pointer
     *         if there are none.
     */
    static FirstWakeUpMonitor() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('WakeUpMonitor');
        if (next_hwid == null) return null;
        return YWakeUpMonitor.FindWakeUpMonitor(next_hwid);
    }

    /**
     * Starts the enumeration of monitors currently accessible.
     * Use the method YWakeUpMonitor.nextWakeUpMonitor() to iterate on
     * next monitors.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YWakeUpMonitor} a pointer to a YWakeUpMonitor object, corresponding to
     *         the first monitor currently online, or a null pointer
     *         if there are none.
     */
    static FirstWakeUpMonitorInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('WakeUpMonitor');
        if (next_hwid == null) return null;
        return YWakeUpMonitor.FindWakeUpMonitorInContext(yctx, next_hwid);
    }

    //--- (end of YWakeUpMonitor implementation)
}

exports.YWakeUpMonitor = YWakeUpMonitor; //--- (WakeUpMonitor functions)

/**
 * comment from .yc definition
 */

function yFindWakeUpMonitor(func) {
    return YWakeUpMonitor.FindWakeUpMonitor(func);
}

/**
 * comment from .yc definition
 */
function yFirstWakeUpMonitor() {
    return YWakeUpMonitor.FirstWakeUpMonitor();
}

//--- (end of WakeUpMonitor functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for WakeUpSchedule functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YWakeUpSchedule = exports.Y_NEXTOCCURENCE_INVALID = exports.Y_MONTHS_INVALID = exports.Y_MONTHDAYS_INVALID = exports.Y_WEEKDAYS_INVALID = exports.Y_HOURS_INVALID = exports.Y_MINUTESB_INVALID = exports.Y_MINUTESA_INVALID = undefined;
exports.yFindWakeUpSchedule = yFindWakeUpSchedule;
exports.yFirstWakeUpSchedule = yFirstWakeUpSchedule;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YWakeUpSchedule return codes)
//--- (end of YWakeUpSchedule return codes)
//--- (YWakeUpSchedule definitions)
const Y_MINUTESA_INVALID = exports.Y_MINUTESA_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_MINUTESB_INVALID = exports.Y_MINUTESB_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_HOURS_INVALID = exports.Y_HOURS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_WEEKDAYS_INVALID = exports.Y_WEEKDAYS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_MONTHDAYS_INVALID = exports.Y_MONTHDAYS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_MONTHS_INVALID = exports.Y_MONTHS_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_NEXTOCCURENCE_INVALID = exports.Y_NEXTOCCURENCE_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YWakeUpSchedule definitions)

//--- (YWakeUpSchedule class start)
/**
 * YWakeUpSchedule Class: WakeUpSchedule function interface
 *
 * The WakeUpSchedule function implements a wake up condition. The wake up time is
 * specified as a set of months and/or days and/or hours and/or minutes when the
 * wake up should happen.
 */
//--- (end of YWakeUpSchedule class start)

class YWakeUpSchedule extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YWakeUpSchedule constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'WakeUpSchedule';
        /** @member {number} **/
        this._minutesA = Y_MINUTESA_INVALID;
        /** @member {number} **/
        this._minutesB = Y_MINUTESB_INVALID;
        /** @member {number} **/
        this._hours = Y_HOURS_INVALID;
        /** @member {number} **/
        this._weekDays = Y_WEEKDAYS_INVALID;
        /** @member {number} **/
        this._monthDays = Y_MONTHDAYS_INVALID;
        /** @member {number} **/
        this._months = Y_MONTHS_INVALID;
        /** @member {number} **/
        this._nextOccurence = Y_NEXTOCCURENCE_INVALID;
        this.imm_setConst({
            MINUTESA_INVALID: _yocto_api.YAPI.INVALID_UINT,
            MINUTESB_INVALID: _yocto_api.YAPI.INVALID_UINT,
            HOURS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            WEEKDAYS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            MONTHDAYS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            MONTHS_INVALID: _yocto_api.YAPI.INVALID_UINT,
            NEXTOCCURENCE_INVALID: _yocto_api.YAPI.INVALID_LONG
        });
        //--- (end of YWakeUpSchedule constructor)
    }

    //--- (YWakeUpSchedule implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'minutesA':
                this._minutesA = parseInt(val);
                return 1;
            case 'minutesB':
                this._minutesB = parseInt(val);
                return 1;
            case 'hours':
                this._hours = parseInt(val);
                return 1;
            case 'weekDays':
                this._weekDays = parseInt(val);
                return 1;
            case 'monthDays':
                this._monthDays = parseInt(val);
                return 1;
            case 'months':
                this._months = parseInt(val);
                return 1;
            case 'nextOccurence':
                this._nextOccurence = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the minutes in the 00-29 interval of each hour scheduled for wake up.
     *
     * @return {number} an integer corresponding to the minutes in the 00-29 interval of each hour
     * scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.MINUTESA_INVALID.
     */
    get_minutesA() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MINUTESA_INVALID;
                }
            }
            return _this._minutesA;
        })();
    }

    /**
     * Changes the minutes in the 00-29 interval when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the minutes in the 00-29 interval when a wake
     * up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_minutesA(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('minutesA', rest_val);
        })();
    }

    /**
     * Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.
     *
     * @return {number} an integer corresponding to the minutes in the 30-59 intervalof each hour scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.MINUTESB_INVALID.
     */
    get_minutesB() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MINUTESB_INVALID;
                }
            }
            return _this3._minutesB;
        })();
    }

    /**
     * Changes the minutes in the 30-59 interval when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the minutes in the 30-59 interval when a wake
     * up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_minutesB(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('minutesB', rest_val);
        })();
    }

    /**
     * Returns the hours scheduled for wake up.
     *
     * @return {number} an integer corresponding to the hours scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.HOURS_INVALID.
     */
    get_hours() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_HOURS_INVALID;
                }
            }
            return _this5._hours;
        })();
    }

    /**
     * Changes the hours when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the hours when a wake up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_hours(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('hours', rest_val);
        })();
    }

    /**
     * Returns the days of the week scheduled for wake up.
     *
     * @return {number} an integer corresponding to the days of the week scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.WEEKDAYS_INVALID.
     */
    get_weekDays() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_WEEKDAYS_INVALID;
                }
            }
            return _this7._weekDays;
        })();
    }

    /**
     * Changes the days of the week when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the days of the week when a wake up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_weekDays(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('weekDays', rest_val);
        })();
    }

    /**
     * Returns the days of the month scheduled for wake up.
     *
     * @return {number} an integer corresponding to the days of the month scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.MONTHDAYS_INVALID.
     */
    get_monthDays() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MONTHDAYS_INVALID;
                }
            }
            return _this9._monthDays;
        })();
    }

    /**
     * Changes the days of the month when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the days of the month when a wake up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_monthDays(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('monthDays', rest_val);
        })();
    }

    /**
     * Returns the months scheduled for wake up.
     *
     * @return {number} an integer corresponding to the months scheduled for wake up
     *
     * On failure, throws an exception or returns YWakeUpSchedule.MONTHS_INVALID.
     */
    get_months() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MONTHS_INVALID;
                }
            }
            return _this11._months;
        })();
    }

    /**
     * Changes the months when a wake up must take place.
     *
     * @param newval {number} : an integer corresponding to the months when a wake up must take place
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_months(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this12._setAttr('months', rest_val);
        })();
    }

    /**
     * Returns the date/time (seconds) of the next wake up occurence
     *
     * @return {number} an integer corresponding to the date/time (seconds) of the next wake up occurence
     *
     * On failure, throws an exception or returns YWakeUpSchedule.NEXTOCCURENCE_INVALID.
     */
    get_nextOccurence() {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            if (_this13._cacheExpiration <= _this13._yapi.GetTickCount()) {
                if ((yield _this13.load(_this13._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_NEXTOCCURENCE_INVALID;
                }
            }
            return _this13._nextOccurence;
        })();
    }

    /**
     * Retrieves a wake up schedule for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the wake up schedule is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWakeUpSchedule.isOnline() to test if the wake up schedule is
     * indeed online at a given time. In case of ambiguity when looking for
     * a wake up schedule by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the wake up schedule
     *
     * @return {YWakeUpSchedule} a YWakeUpSchedule object allowing you to drive the wake up schedule.
     */
    static FindWakeUpSchedule(func) {
        /** @type {YWakeUpSchedule} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('WakeUpSchedule', func);
        if (obj == null) {
            obj = new YWakeUpSchedule(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('WakeUpSchedule', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a wake up schedule for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the wake up schedule is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWakeUpSchedule.isOnline() to test if the wake up schedule is
     * indeed online at a given time. In case of ambiguity when looking for
     * a wake up schedule by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the wake up schedule
     *
     * @return {YWakeUpSchedule} a YWakeUpSchedule object allowing you to drive the wake up schedule.
     */
    static FindWakeUpScheduleInContext(yctx, func) {
        /** @type {YWakeUpSchedule} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'WakeUpSchedule', func);
        if (obj == null) {
            obj = new YWakeUpSchedule(yctx, func);
            _yocto_api.YFunction._AddToCache('WakeUpSchedule', func, obj);
        }
        return obj;
    }

    /**
     * Returns all the minutes of each hour that are scheduled for wake up.
     */
    get_minutes() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            /** @type {number} **/
            let res;
            // may throw an exception
            res = yield _this14.get_minutesB();
            res = res << 30;
            res = res + (yield _this14.get_minutesA());
            return res;
        })();
    }

    /**
     * Changes all the minutes where a wake up must take place.
     *
     * @param bitmap {number} : Minutes 00-59 of each hour scheduled for wake up.
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_minutes(bitmap) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            yield _this15.set_minutesA(bitmap & 0x3fffffff);
            bitmap = bitmap >> 30;
            return yield _this15.set_minutesB(bitmap & 0x3fffffff);
        })();
    }

    /**
     * Continues the enumeration of wake up schedules started using yFirstWakeUpSchedule().
     *
     * @return {YWakeUpSchedule} a pointer to a YWakeUpSchedule object, corresponding to
     *         a wake up schedule currently online, or a null pointer
     *         if there are no more wake up schedules to enumerate.
     */
    /* */nextWakeUpSchedule() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YWakeUpSchedule.FindWakeUpScheduleInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of wake up schedules currently accessible.
     * Use the method YWakeUpSchedule.nextWakeUpSchedule() to iterate on
     * next wake up schedules.
     *
     * @return {YWakeUpSchedule} a pointer to a YWakeUpSchedule object, corresponding to
     *         the first wake up schedule currently online, or a null pointer
     *         if there are none.
     */
    static FirstWakeUpSchedule() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('WakeUpSchedule');
        if (next_hwid == null) return null;
        return YWakeUpSchedule.FindWakeUpSchedule(next_hwid);
    }

    /**
     * Starts the enumeration of wake up schedules currently accessible.
     * Use the method YWakeUpSchedule.nextWakeUpSchedule() to iterate on
     * next wake up schedules.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YWakeUpSchedule} a pointer to a YWakeUpSchedule object, corresponding to
     *         the first wake up schedule currently online, or a null pointer
     *         if there are none.
     */
    static FirstWakeUpScheduleInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('WakeUpSchedule');
        if (next_hwid == null) return null;
        return YWakeUpSchedule.FindWakeUpScheduleInContext(yctx, next_hwid);
    }

    //--- (end of YWakeUpSchedule implementation)
}

exports.YWakeUpSchedule = YWakeUpSchedule; //--- (WakeUpSchedule functions)

/**
 * comment from .yc definition
 */

function yFindWakeUpSchedule(func) {
    return YWakeUpSchedule.FindWakeUpSchedule(func);
}

/**
 * comment from .yc definition
 */
function yFirstWakeUpSchedule() {
    return YWakeUpSchedule.FirstWakeUpSchedule();
}

//--- (end of WakeUpSchedule functions)
/*********************************************************************
 *
 * $Id: pic24config.php 22503 2015-12-22 15:34:43Z mvuilleu $
 *
 * Implements the high-level API for Watchdog functions
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
 *  non-exclusive license to use, modify, copy and integrate this
 *  file into your software for the sole purpose of interfacing
 *  with Yoctopuce products.
 *
 *  You may reproduce and distribute copies of this file in
 *  source or object form, as long as the sole purpose of this
 *  code is to interface with Yoctopuce products. You must retain
 *  this notice in the distributed source file.
 *
 *  You should refer to Yoctopuce General Terms and Conditions
 *  for additional information regarding your rights and
 *  obligations.
 *
 *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED 'AS IS' WITHOUT
 *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *  WARRANTY, OR OTHERWISE.
 *
 *********************************************************************/

'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YWatchdog = exports.Y_TRIGGERDURATION_INVALID = exports.Y_TRIGGERDELAY_INVALID = exports.Y_COUNTDOWN_INVALID = exports.Y_DELAYEDPULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = exports.Y_MAXTIMEONSTATEB_INVALID = exports.Y_MAXTIMEONSTATEA_INVALID = exports.Y_RUNNING_INVALID = exports.Y_RUNNING_ON = exports.Y_RUNNING_OFF = exports.Y_AUTOSTART_INVALID = exports.Y_AUTOSTART_ON = exports.Y_AUTOSTART_OFF = exports.Y_OUTPUT_INVALID = exports.Y_OUTPUT_ON = exports.Y_OUTPUT_OFF = exports.Y_STATEATPOWERON_INVALID = exports.Y_STATEATPOWERON_B = exports.Y_STATEATPOWERON_A = exports.Y_STATEATPOWERON_UNCHANGED = exports.Y_STATE_INVALID = exports.Y_STATE_B = exports.Y_STATE_A = undefined;
exports.yFindWatchdog = yFindWatchdog;
exports.yFirstWatchdog = yFirstWatchdog;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

//--- (YWatchdog return codes)
//--- (end of YWatchdog return codes)
//--- (YWatchdog definitions)
const Y_STATE_A = exports.Y_STATE_A = 0;
const Y_STATE_B = exports.Y_STATE_B = 1;
const Y_STATE_INVALID = exports.Y_STATE_INVALID = -1;
const Y_STATEATPOWERON_UNCHANGED = exports.Y_STATEATPOWERON_UNCHANGED = 0;
const Y_STATEATPOWERON_A = exports.Y_STATEATPOWERON_A = 1;
const Y_STATEATPOWERON_B = exports.Y_STATEATPOWERON_B = 2;
const Y_STATEATPOWERON_INVALID = exports.Y_STATEATPOWERON_INVALID = -1;
const Y_OUTPUT_OFF = exports.Y_OUTPUT_OFF = 0;
const Y_OUTPUT_ON = exports.Y_OUTPUT_ON = 1;
const Y_OUTPUT_INVALID = exports.Y_OUTPUT_INVALID = -1;
const Y_AUTOSTART_OFF = exports.Y_AUTOSTART_OFF = 0;
const Y_AUTOSTART_ON = exports.Y_AUTOSTART_ON = 1;
const Y_AUTOSTART_INVALID = exports.Y_AUTOSTART_INVALID = -1;
const Y_RUNNING_OFF = exports.Y_RUNNING_OFF = 0;
const Y_RUNNING_ON = exports.Y_RUNNING_ON = 1;
const Y_RUNNING_INVALID = exports.Y_RUNNING_INVALID = -1;
const Y_MAXTIMEONSTATEA_INVALID = exports.Y_MAXTIMEONSTATEA_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_MAXTIMEONSTATEB_INVALID = exports.Y_MAXTIMEONSTATEB_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_PULSETIMER_INVALID = exports.Y_PULSETIMER_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_DELAYEDPULSETIMER_INVALID = exports.Y_DELAYEDPULSETIMER_INVALID = null;
const Y_COUNTDOWN_INVALID = exports.Y_COUNTDOWN_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_TRIGGERDELAY_INVALID = exports.Y_TRIGGERDELAY_INVALID = _yocto_api.YAPI.INVALID_LONG;
const Y_TRIGGERDURATION_INVALID = exports.Y_TRIGGERDURATION_INVALID = _yocto_api.YAPI.INVALID_LONG;
//--- (end of YWatchdog definitions)

//--- (YWatchdog class start)
/**
 * YWatchdog Class: Watchdog function interface
 *
 * The watchog function works like a relay and can cause a brief power cut
 * to an appliance after a preset delay to force this appliance to
 * reset. The Watchdog must be called from time to time to reset the
 * timer and prevent the appliance reset.
 * The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch
 * off an appliance for a given duration.
 */
//--- (end of YWatchdog class start)

class YWatchdog extends _yocto_api.YFunction {
    constructor(obj_yapi, str_func) {
        //--- (YWatchdog constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Watchdog';
        /** @member {number} **/
        this._state = Y_STATE_INVALID;
        /** @member {number} **/
        this._stateAtPowerOn = Y_STATEATPOWERON_INVALID;
        /** @member {number} **/
        this._maxTimeOnStateA = Y_MAXTIMEONSTATEA_INVALID;
        /** @member {number} **/
        this._maxTimeOnStateB = Y_MAXTIMEONSTATEB_INVALID;
        /** @member {number} **/
        this._output = Y_OUTPUT_INVALID;
        /** @member {number} **/
        this._pulseTimer = Y_PULSETIMER_INVALID;
        /** @member {YDelayedPulse} **/
        this._delayedPulseTimer = Y_DELAYEDPULSETIMER_INVALID;
        /** @member {number} **/
        this._countdown = Y_COUNTDOWN_INVALID;
        /** @member {number} **/
        this._autoStart = Y_AUTOSTART_INVALID;
        /** @member {number} **/
        this._running = Y_RUNNING_INVALID;
        /** @member {number} **/
        this._triggerDelay = Y_TRIGGERDELAY_INVALID;
        /** @member {number} **/
        this._triggerDuration = Y_TRIGGERDURATION_INVALID;
        this.imm_setConst({
            STATE_A: 0,
            STATE_B: 1,
            STATE_INVALID: -1,
            STATEATPOWERON_UNCHANGED: 0,
            STATEATPOWERON_A: 1,
            STATEATPOWERON_B: 2,
            STATEATPOWERON_INVALID: -1,
            MAXTIMEONSTATEA_INVALID: _yocto_api.YAPI.INVALID_LONG,
            MAXTIMEONSTATEB_INVALID: _yocto_api.YAPI.INVALID_LONG,
            OUTPUT_OFF: 0,
            OUTPUT_ON: 1,
            OUTPUT_INVALID: -1,
            PULSETIMER_INVALID: _yocto_api.YAPI.INVALID_LONG,
            COUNTDOWN_INVALID: _yocto_api.YAPI.INVALID_LONG,
            AUTOSTART_OFF: 0,
            AUTOSTART_ON: 1,
            AUTOSTART_INVALID: -1,
            RUNNING_OFF: 0,
            RUNNING_ON: 1,
            RUNNING_INVALID: -1,
            TRIGGERDELAY_INVALID: _yocto_api.YAPI.INVALID_LONG,
            TRIGGERDURATION_INVALID: _yocto_api.YAPI.INVALID_LONG
        });
        //--- (end of YWatchdog constructor)
    }

    //--- (YWatchdog implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'state':
                this._state = parseInt(val);
                return 1;
            case 'stateAtPowerOn':
                this._stateAtPowerOn = parseInt(val);
                return 1;
            case 'maxTimeOnStateA':
                this._maxTimeOnStateA = parseInt(val);
                return 1;
            case 'maxTimeOnStateB':
                this._maxTimeOnStateB = parseInt(val);
                return 1;
            case 'output':
                this._output = parseInt(val);
                return 1;
            case 'pulseTimer':
                this._pulseTimer = parseInt(val);
                return 1;
            case 'delayedPulseTimer':
                this._delayedPulseTimer = val;
                return 1;
            case 'countdown':
                this._countdown = parseInt(val);
                return 1;
            case 'autoStart':
                this._autoStart = parseInt(val);
                return 1;
            case 'running':
                this._running = parseInt(val);
                return 1;
            case 'triggerDelay':
                this._triggerDelay = parseInt(val);
                return 1;
            case 'triggerDuration':
                this._triggerDuration = parseInt(val);
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the state of the watchdog (A for the idle position, B for the active position).
     *
     * @return {number} either YWatchdog.STATE_A or YWatchdog.STATE_B, according to the state of the
     * watchdog (A for the idle position, B for the active position)
     *
     * On failure, throws an exception or returns YWatchdog.STATE_INVALID.
     */
    get_state() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STATE_INVALID;
                }
            }
            return _this._state;
        })();
    }

    /**
     * Changes the state of the watchdog (A for the idle position, B for the active position).
     *
     * @param newval {number} : either YWatchdog.STATE_A or YWatchdog.STATE_B, according to the state of
     * the watchdog (A for the idle position, B for the active position)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_state(newval) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this2._setAttr('state', rest_val);
        })();
    }

    /**
     * Returns the state of the watchdog at device startup (A for the idle position, B for the active
     * position, UNCHANGED for no change).
     *
     * @return {number} a value among YWatchdog.STATEATPOWERON_UNCHANGED, YWatchdog.STATEATPOWERON_A and
     * YWatchdog.STATEATPOWERON_B corresponding to the state of the watchdog at device startup (A for the
     * idle position, B for the active position, UNCHANGED for no change)
     *
     * On failure, throws an exception or returns YWatchdog.STATEATPOWERON_INVALID.
     */
    get_stateAtPowerOn() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_STATEATPOWERON_INVALID;
                }
            }
            return _this3._stateAtPowerOn;
        })();
    }

    /**
     * Preset the state of the watchdog at device startup (A for the idle position,
     * B for the active position, UNCHANGED for no modification). Remember to call the matching module saveToFlash()
     * method, otherwise this call will have no effect.
     *
     * @param newval {number} : a value among YWatchdog.STATEATPOWERON_UNCHANGED,
     * YWatchdog.STATEATPOWERON_A and YWatchdog.STATEATPOWERON_B
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_stateAtPowerOn(newval) {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this4._setAttr('stateAtPowerOn', rest_val);
        })();
    }

    /**
     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
     * switching back in to B state. Zero means no maximum time.
     *
     * @return {number} an integer
     *
     * On failure, throws an exception or returns YWatchdog.MAXTIMEONSTATEA_INVALID.
     */
    get_maxTimeOnStateA() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MAXTIMEONSTATEA_INVALID;
                }
            }
            return _this5._maxTimeOnStateA;
        })();
    }

    /**
     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically
     * switching back in to B state. Use zero for no maximum time.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_maxTimeOnStateA(newval) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this6._setAttr('maxTimeOnStateA', rest_val);
        })();
    }

    /**
     * Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
     * switching back in to A state. Zero means no maximum time.
     *
     * @return {number} an integer
     *
     * On failure, throws an exception or returns YWatchdog.MAXTIMEONSTATEB_INVALID.
     */
    get_maxTimeOnStateB() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            if (_this7._cacheExpiration <= _this7._yapi.GetTickCount()) {
                if ((yield _this7.load(_this7._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MAXTIMEONSTATEB_INVALID;
                }
            }
            return _this7._maxTimeOnStateB;
        })();
    }

    /**
     * Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically
     * switching back in to A state. Use zero for no maximum time.
     *
     * @param newval {number} : an integer
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_maxTimeOnStateB(newval) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this8._setAttr('maxTimeOnStateB', rest_val);
        })();
    }

    /**
     * Returns the output state of the watchdog, when used as a simple switch (single throw).
     *
     * @return {number} either YWatchdog.OUTPUT_OFF or YWatchdog.OUTPUT_ON, according to the output state
     * of the watchdog, when used as a simple switch (single throw)
     *
     * On failure, throws an exception or returns YWatchdog.OUTPUT_INVALID.
     */
    get_output() {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            if (_this9._cacheExpiration <= _this9._yapi.GetTickCount()) {
                if ((yield _this9.load(_this9._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_OUTPUT_INVALID;
                }
            }
            return _this9._output;
        })();
    }

    /**
     * Changes the output state of the watchdog, when used as a simple switch (single throw).
     *
     * @param newval {number} : either YWatchdog.OUTPUT_OFF or YWatchdog.OUTPUT_ON, according to the
     * output state of the watchdog, when used as a simple switch (single throw)
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_output(newval) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this10._setAttr('output', rest_val);
        })();
    }

    /**
     * Returns the number of milliseconds remaining before the watchdog is returned to idle position
     * (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.
     *
     * @return {number} an integer corresponding to the number of milliseconds remaining before the
     * watchdog is returned to idle position
     *         (state A), during a measured pulse generation
     *
     * On failure, throws an exception or returns YWatchdog.PULSETIMER_INVALID.
     */
    get_pulseTimer() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            if (_this11._cacheExpiration <= _this11._yapi.GetTickCount()) {
                if ((yield _this11.load(_this11._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_PULSETIMER_INVALID;
                }
            }
            return _this11._pulseTimer;
        })();
    }

    set_pulseTimer(newval) {
        var _this12 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this12._setAttr('pulseTimer', rest_val);
        })();
    }

    /**
     * Sets the relay to output B (active) for a specified duration, then brings it
     * automatically back to output A (idle state).
     *
     * @param ms_duration {number} : pulse duration, in millisecondes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    pulse(ms_duration) {
        var _this13 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(ms_duration);
            return yield _this13._setAttr('pulseTimer', rest_val);
        })();
    }

    get_delayedPulseTimer() {
        var _this14 = this;

        return _asyncToGenerator(function* () {
            if (_this14._cacheExpiration <= _this14._yapi.GetTickCount()) {
                if ((yield _this14.load(_this14._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_DELAYEDPULSETIMER_INVALID;
                }
            }
            return _this14._delayedPulseTimer;
        })();
    }

    set_delayedPulseTimer(newval) {
        var _this15 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval.target) + ':' + String(newval.ms);
            return yield _this15._setAttr('delayedPulseTimer', rest_val);
        })();
    }

    /**
     * Schedules a pulse.
     *
     * @param ms_delay {number} : waiting time before the pulse, in millisecondes
     * @param ms_duration {number} : pulse duration, in millisecondes
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    delayedPulse(ms_delay, ms_duration) {
        var _this16 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(ms_delay) + ':' + String(ms_duration);
            return yield _this16._setAttr('delayedPulseTimer', rest_val);
        })();
    }

    /**
     * Returns the number of milliseconds remaining before a pulse (delayedPulse() call)
     * When there is no scheduled pulse, returns zero.
     *
     * @return {number} an integer corresponding to the number of milliseconds remaining before a pulse
     * (delayedPulse() call)
     *         When there is no scheduled pulse, returns zero
     *
     * On failure, throws an exception or returns YWatchdog.COUNTDOWN_INVALID.
     */
    get_countdown() {
        var _this17 = this;

        return _asyncToGenerator(function* () {
            if (_this17._cacheExpiration <= _this17._yapi.GetTickCount()) {
                if ((yield _this17.load(_this17._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_COUNTDOWN_INVALID;
                }
            }
            return _this17._countdown;
        })();
    }

    /**
     * Returns the watchdog runing state at module power on.
     *
     * @return {number} either YWatchdog.AUTOSTART_OFF or YWatchdog.AUTOSTART_ON, according to the
     * watchdog runing state at module power on
     *
     * On failure, throws an exception or returns YWatchdog.AUTOSTART_INVALID.
     */
    get_autoStart() {
        var _this18 = this;

        return _asyncToGenerator(function* () {
            if (_this18._cacheExpiration <= _this18._yapi.GetTickCount()) {
                if ((yield _this18.load(_this18._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_AUTOSTART_INVALID;
                }
            }
            return _this18._autoStart;
        })();
    }

    /**
     * Changes the watchdog runningsttae at module power on. Remember to call the
     * saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param newval {number} : either YWatchdog.AUTOSTART_OFF or YWatchdog.AUTOSTART_ON, according to the
     * watchdog runningsttae at module power on
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_autoStart(newval) {
        var _this19 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this19._setAttr('autoStart', rest_val);
        })();
    }

    /**
     * Returns the watchdog running state.
     *
     * @return {number} either YWatchdog.RUNNING_OFF or YWatchdog.RUNNING_ON, according to the watchdog running state
     *
     * On failure, throws an exception or returns YWatchdog.RUNNING_INVALID.
     */
    get_running() {
        var _this20 = this;

        return _asyncToGenerator(function* () {
            if (_this20._cacheExpiration <= _this20._yapi.GetTickCount()) {
                if ((yield _this20.load(_this20._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_RUNNING_INVALID;
                }
            }
            return _this20._running;
        })();
    }

    /**
     * Changes the running state of the watchdog.
     *
     * @param newval {number} : either YWatchdog.RUNNING_OFF or YWatchdog.RUNNING_ON, according to the
     * running state of the watchdog
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_running(newval) {
        var _this21 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this21._setAttr('running', rest_val);
        })();
    }

    /**
     * Resets the watchdog. When the watchdog is running, this function
     * must be called on a regular basis to prevent the watchog to
     * trigger
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    resetWatchdog() {
        var _this22 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = '1';
            return yield _this22._setAttr('running', rest_val);
        })();
    }

    /**
     * Returns  the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.
     *
     * @return {number} an integer corresponding to  the waiting duration before a reset is automatically
     * triggered by the watchdog, in milliseconds
     *
     * On failure, throws an exception or returns YWatchdog.TRIGGERDELAY_INVALID.
     */
    get_triggerDelay() {
        var _this23 = this;

        return _asyncToGenerator(function* () {
            if (_this23._cacheExpiration <= _this23._yapi.GetTickCount()) {
                if ((yield _this23.load(_this23._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TRIGGERDELAY_INVALID;
                }
            }
            return _this23._triggerDelay;
        })();
    }

    /**
     * Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.
     *
     * @param newval {number} : an integer corresponding to the waiting delay before a reset is triggered
     * by the watchdog, in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_triggerDelay(newval) {
        var _this24 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this24._setAttr('triggerDelay', rest_val);
        })();
    }

    /**
     * Returns the duration of resets caused by the watchdog, in milliseconds.
     *
     * @return {number} an integer corresponding to the duration of resets caused by the watchdog, in milliseconds
     *
     * On failure, throws an exception or returns YWatchdog.TRIGGERDURATION_INVALID.
     */
    get_triggerDuration() {
        var _this25 = this;

        return _asyncToGenerator(function* () {
            if (_this25._cacheExpiration <= _this25._yapi.GetTickCount()) {
                if ((yield _this25.load(_this25._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_TRIGGERDURATION_INVALID;
                }
            }
            return _this25._triggerDuration;
        })();
    }

    /**
     * Changes the duration of resets caused by the watchdog, in milliseconds.
     *
     * @param newval {number} : an integer corresponding to the duration of resets caused by the watchdog,
     * in milliseconds
     *
     * @return {number} YAPI.SUCCESS if the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    set_triggerDuration(newval) {
        var _this26 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = String(newval);
            return yield _this26._setAttr('triggerDuration', rest_val);
        })();
    }

    /**
     * Retrieves a watchdog for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the watchdog is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWatchdog.isOnline() to test if the watchdog is
     * indeed online at a given time. In case of ambiguity when looking for
     * a watchdog by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the watchdog
     *
     * @return {YWatchdog} a YWatchdog object allowing you to drive the watchdog.
     */
    static FindWatchdog(func) {
        /** @type {YWatchdog} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Watchdog', func);
        if (obj == null) {
            obj = new YWatchdog(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Watchdog', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a watchdog for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the watchdog is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWatchdog.isOnline() to test if the watchdog is
     * indeed online at a given time. In case of ambiguity when looking for
     * a watchdog by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the watchdog
     *
     * @return {YWatchdog} a YWatchdog object allowing you to drive the watchdog.
     */
    static FindWatchdogInContext(yctx, func) {
        /** @type {YWatchdog} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Watchdog', func);
        if (obj == null) {
            obj = new YWatchdog(yctx, func);
            _yocto_api.YFunction._AddToCache('Watchdog', func, obj);
        }
        return obj;
    }

    /**
     * Continues the enumeration of watchdog started using yFirstWatchdog().
     *
     * @return {YWatchdog} a pointer to a YWatchdog object, corresponding to
     *         a watchdog currently online, or a null pointer
     *         if there are no more watchdog to enumerate.
     */
    /* */nextWatchdog() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YWatchdog.FindWatchdogInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of watchdog currently accessible.
     * Use the method YWatchdog.nextWatchdog() to iterate on
     * next watchdog.
     *
     * @return {YWatchdog} a pointer to a YWatchdog object, corresponding to
     *         the first watchdog currently online, or a null pointer
     *         if there are none.
     */
    static FirstWatchdog() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Watchdog');
        if (next_hwid == null) return null;
        return YWatchdog.FindWatchdog(next_hwid);
    }

    /**
     * Starts the enumeration of watchdog currently accessible.
     * Use the method YWatchdog.nextWatchdog() to iterate on
     * next watchdog.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YWatchdog} a pointer to a YWatchdog object, corresponding to
     *         the first watchdog currently online, or a null pointer
     *         if there are none.
     */
    static FirstWatchdogInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Watchdog');
        if (next_hwid == null) return null;
        return YWatchdog.FindWatchdogInContext(yctx, next_hwid);
    }

    //--- (end of YWatchdog implementation)
}

exports.YWatchdog = YWatchdog; //--- (Watchdog functions)

/**
 * comment from .yc definition
 */

function yFindWatchdog(func) {
    return YWatchdog.FindWatchdog(func);
}

/**
 * comment from .yc definition
 */
function yFirstWatchdog() {
    return YWatchdog.FirstWatchdog();
}

//--- (end of Watchdog functions)
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YWireless = exports.Y_WLANCONFIG_INVALID = exports.Y_MESSAGE_INVALID = exports.Y_CHANNEL_INVALID = exports.Y_SSID_INVALID = exports.Y_LINKQUALITY_INVALID = exports.Y_SECURITY_INVALID = exports.Y_SECURITY_WPA2 = exports.Y_SECURITY_WPA = exports.Y_SECURITY_WEP = exports.Y_SECURITY_OPEN = exports.Y_SECURITY_UNKNOWN = undefined;
exports.yFindWireless = yFindWireless;
exports.yFirstWireless = yFirstWireless;

var _yocto_api = require('lib/yocto_api');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; } /*********************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * $Id: yocto_wireless.js 21680 2015-10-02 13:42:44Z seb $
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * Implements yFindWireless(), the high-level API for Wireless functions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              * - - - - - - - - - License information: - - - - - - - - - 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  Yoctopuce Sarl (hereafter Licensor) grants to you a perpetual
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  non-exclusive license to use, modify, copy and integrate this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  file into your software for the sole purpose of interfacing 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  with Yoctopuce products. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You may reproduce and distribute copies of this file in 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  source or object form, as long as the sole purpose of this
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  code is to interface with Yoctopuce products. You must retain 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  this notice in the distributed source file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  You should refer to Yoctopuce General Terms and Conditions
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  for additional information regarding your rights and 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  obligations.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *  WARRANTY, OR OTHERWISE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                                                                                                                                              *********************************************************************/

//--- (generated code: YWireless definitions)
const Y_SECURITY_UNKNOWN = exports.Y_SECURITY_UNKNOWN = 0;
const Y_SECURITY_OPEN = exports.Y_SECURITY_OPEN = 1;
const Y_SECURITY_WEP = exports.Y_SECURITY_WEP = 2;
const Y_SECURITY_WPA = exports.Y_SECURITY_WPA = 3;
const Y_SECURITY_WPA2 = exports.Y_SECURITY_WPA2 = 4;
const Y_SECURITY_INVALID = exports.Y_SECURITY_INVALID = -1;
const Y_LINKQUALITY_INVALID = exports.Y_LINKQUALITY_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_SSID_INVALID = exports.Y_SSID_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_CHANNEL_INVALID = exports.Y_CHANNEL_INVALID = _yocto_api.YAPI.INVALID_UINT;
const Y_MESSAGE_INVALID = exports.Y_MESSAGE_INVALID = _yocto_api.YAPI.INVALID_STRING;
const Y_WLANCONFIG_INVALID = exports.Y_WLANCONFIG_INVALID = _yocto_api.YAPI.INVALID_STRING;
//--- (end of generated code: YWireless definitions)

//--- (generated code: YWlanRecord definitions)
//--- (end of generated code: YWlanRecord definitions)

//--- (generated code: YWlanRecord class start)
/**
 * YWlanRecord Class: Description of a wireless network
 *
 *
 */
//--- (end of generated code: YWlanRecord class start)
class YWlanRecord {
    constructor(str_json) {
        //--- (generated code: YWlanRecord constructor)
        /** @member {string} **/
        this._ssid = '';
        /** @member {number} **/
        this._channel = 0;
        /** @member {string} **/
        this._sec = '';
        /** @member {number} **/
        this._rssi = 0;
        //--- (end of generated code: YWlanRecord constructor)

        var loadval = JSON.parse(str_json);
        this._ssid = loadval.ssid;
        this._channel = loadval.channel;
        this._sec = loadval.sec;
        this._rssi = loadval.rssi;
    }

    //--- (generated code: YWlanRecord implementation)

    /* */get_ssid() {
        return this._ssid;
    }

    /* */get_channel() {
        return this._channel;
    }

    /* */get_security() {
        return this._sec;
    }

    /* */get_linkQuality() {
        return this._rssi;
    }

    //--- (end of generated code: YWlanRecord implementation)
}

//--- (generated code: YWireless class start)
/**
 * YWireless Class: Wireless function interface
 *
 * YWireless functions provides control over wireless network parameters
 * and status for devices that are wireless-enabled.
 */
//--- (end of generated code: YWireless class start)
class YWireless extends _yocto_api.YFunction {
    constructor(str_func) {
        //--- (generated code: YWireless constructor)
        super(obj_yapi, str_func);
        /** @member {string} **/
        this._className = 'Wireless';
        /** @member {number} **/
        this._linkQuality = Y_LINKQUALITY_INVALID;
        /** @member {string} **/
        this._ssid = Y_SSID_INVALID;
        /** @member {number} **/
        this._channel = Y_CHANNEL_INVALID;
        /** @member {number} **/
        this._security = Y_SECURITY_INVALID;
        /** @member {string} **/
        this._message = Y_MESSAGE_INVALID;
        /** @member {string} **/
        this._wlanConfig = Y_WLANCONFIG_INVALID;
        this.imm_setConst({
            LINKQUALITY_INVALID: _yocto_api.YAPI.INVALID_UINT,
            SSID_INVALID: _yocto_api.YAPI.INVALID_STRING,
            CHANNEL_INVALID: _yocto_api.YAPI.INVALID_UINT,
            SECURITY_UNKNOWN: 0,
            SECURITY_OPEN: 1,
            SECURITY_WEP: 2,
            SECURITY_WPA: 3,
            SECURITY_WPA2: 4,
            SECURITY_INVALID: -1,
            MESSAGE_INVALID: _yocto_api.YAPI.INVALID_STRING,
            WLANCONFIG_INVALID: _yocto_api.YAPI.INVALID_STRING
        });
        //--- (end of generated code: YWireless constructor)
    }

    //--- (generated code: YWireless implementation)

    imm_parseAttr(name, val) {
        switch (name) {
            case 'linkQuality':
                this._linkQuality = parseInt(val);
                return 1;
            case 'ssid':
                this._ssid = val;
                return 1;
            case 'channel':
                this._channel = parseInt(val);
                return 1;
            case 'security':
                this._security = parseInt(val);
                return 1;
            case 'message':
                this._message = val;
                return 1;
            case 'wlanConfig':
                this._wlanConfig = val;
                return 1;
        }
        return super.imm_parseAttr(name, val);
    }

    /**
     * Returns the link quality, expressed in percent.
     *
     * @return {number} an integer corresponding to the link quality, expressed in percent
     *
     * On failure, throws an exception or returns YWireless.LINKQUALITY_INVALID.
     */
    get_linkQuality() {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this._cacheExpiration <= _this._yapi.GetTickCount()) {
                if ((yield _this.load(_this._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_LINKQUALITY_INVALID;
                }
            }
            return _this._linkQuality;
        })();
    }

    /**
     * Returns the wireless network name (SSID).
     *
     * @return {string} a string corresponding to the wireless network name (SSID)
     *
     * On failure, throws an exception or returns YWireless.SSID_INVALID.
     */
    get_ssid() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            if (_this2._cacheExpiration <= _this2._yapi.GetTickCount()) {
                if ((yield _this2.load(_this2._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SSID_INVALID;
                }
            }
            return _this2._ssid;
        })();
    }

    /**
     * Returns the 802.11 channel currently used, or 0 when the selected network has not been found.
     *
     * @return {number} an integer corresponding to the 802.11 channel currently used, or 0 when the
     * selected network has not been found
     *
     * On failure, throws an exception or returns YWireless.CHANNEL_INVALID.
     */
    get_channel() {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            if (_this3._cacheExpiration <= _this3._yapi.GetTickCount()) {
                if ((yield _this3.load(_this3._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_CHANNEL_INVALID;
                }
            }
            return _this3._channel;
        })();
    }

    /**
     * Returns the security algorithm used by the selected wireless network.
     *
     * @return {number} a value among YWireless.SECURITY_UNKNOWN, YWireless.SECURITY_OPEN,
     * YWireless.SECURITY_WEP, YWireless.SECURITY_WPA and YWireless.SECURITY_WPA2 corresponding to the
     * security algorithm used by the selected wireless network
     *
     * On failure, throws an exception or returns YWireless.SECURITY_INVALID.
     */
    get_security() {
        var _this4 = this;

        return _asyncToGenerator(function* () {
            if (_this4._cacheExpiration <= _this4._yapi.GetTickCount()) {
                if ((yield _this4.load(_this4._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_SECURITY_INVALID;
                }
            }
            return _this4._security;
        })();
    }

    /**
     * Returns the latest status message from the wireless interface.
     *
     * @return {string} a string corresponding to the latest status message from the wireless interface
     *
     * On failure, throws an exception or returns YWireless.MESSAGE_INVALID.
     */
    get_message() {
        var _this5 = this;

        return _asyncToGenerator(function* () {
            if (_this5._cacheExpiration <= _this5._yapi.GetTickCount()) {
                if ((yield _this5.load(_this5._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_MESSAGE_INVALID;
                }
            }
            return _this5._message;
        })();
    }

    get_wlanConfig() {
        var _this6 = this;

        return _asyncToGenerator(function* () {
            if (_this6._cacheExpiration <= _this6._yapi.GetTickCount()) {
                if ((yield _this6.load(_this6._yapi.defaultCacheValidity)) != _yocto_api.YAPI_SUCCESS) {
                    return Y_WLANCONFIG_INVALID;
                }
            }
            return _this6._wlanConfig;
        })();
    }

    set_wlanConfig(newval) {
        var _this7 = this;

        return _asyncToGenerator(function* () {
            /** @type {string} **/
            let rest_val;
            rest_val = newval;
            return yield _this7._setAttr('wlanConfig', rest_val);
        })();
    }

    /**
     * Retrieves a wireless lan interface for a given identifier.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the wireless lan interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWireless.isOnline() to test if the wireless lan interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a wireless lan interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param func {string} : a string that uniquely characterizes the wireless lan interface
     *
     * @return {YWireless} a YWireless object allowing you to drive the wireless lan interface.
     */
    static FindWireless(func) {
        /** @type {YWireless} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCache('Wireless', func);
        if (obj == null) {
            obj = new YWireless(_yocto_api.YAPI, func);
            _yocto_api.YFunction._AddToCache('Wireless', func, obj);
        }
        return obj;
    }

    /**
     * Retrieves a wireless lan interface for a given identifier in a YAPI context.
     * The identifier can be specified using several formats:
     * <ul>
     * <li>FunctionLogicalName</li>
     * <li>ModuleSerialNumber.FunctionIdentifier</li>
     * <li>ModuleSerialNumber.FunctionLogicalName</li>
     * <li>ModuleLogicalName.FunctionIdentifier</li>
     * <li>ModuleLogicalName.FunctionLogicalName</li>
     * </ul>
     *
     * This function does not require that the wireless lan interface is online at the time
     * it is invoked. The returned object is nevertheless valid.
     * Use the method YWireless.isOnline() to test if the wireless lan interface is
     * indeed online at a given time. In case of ambiguity when looking for
     * a wireless lan interface by logical name, no error is notified: the first instance
     * found is returned. The search is performed first by hardware name,
     * then by logical name.
     *
     * @param yctx {YAPIContext} : a YAPI context
     * @param func {string} : a string that uniquely characterizes the wireless lan interface
     *
     * @return {YWireless} a YWireless object allowing you to drive the wireless lan interface.
     */
    static FindWirelessInContext(yctx, func) {
        /** @type {YWireless} **/
        let obj;
        obj = _yocto_api.YFunction._FindFromCacheInContext(yctx, 'Wireless', func);
        if (obj == null) {
            obj = new YWireless(yctx, func);
            _yocto_api.YFunction._AddToCache('Wireless', func, obj);
        }
        return obj;
    }

    /**
     * Changes the configuration of the wireless lan interface to connect to an existing
     * access point (infrastructure mode).
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param ssid {string} : the name of the network to connect to
     * @param securityKey {string} : the network key, as a character string
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    joinNetwork(ssid, securityKey) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
            return yield _this8.set_wlanConfig('INFRA:' + ssid + '\\' + securityKey);
        })();
    }

    /**
     * Changes the configuration of the wireless lan interface to create an ad-hoc
     * wireless network, without using an access point. On the YoctoHub-Wireless-g,
     * it is best to use softAPNetworkInstead(), which emulates an access point
     * (Soft AP) which is more efficient and more widely supported than ad-hoc networks.
     *
     * When a security key is specified for an ad-hoc network, the network is protected
     * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
     * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
     * using 26 hexadecimal digits to maximize security.
     * Remember to call the saveToFlash() method and then to reboot the module
     * to apply this setting.
     *
     * @param ssid {string} : the name of the network to connect to
     * @param securityKey {string} : the network key, as a character string
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    adhocNetwork(ssid, securityKey) {
        var _this9 = this;

        return _asyncToGenerator(function* () {
            return yield _this9.set_wlanConfig('ADHOC:' + ssid + '\\' + securityKey);
        })();
    }

    /**
     * Changes the configuration of the wireless lan interface to create a new wireless
     * network by emulating a WiFi access point (Soft AP). This function can only be
     * used with the YoctoHub-Wireless-g.
     *
     * When a security key is specified for a SoftAP network, the network is protected
     * by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters
     * or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key
     * using 26 hexadecimal digits to maximize security.
     * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
     *
     * @param ssid {string} : the name of the network to connect to
     * @param securityKey {string} : the network key, as a character string
     *
     * @return {number} YAPI.SUCCESS when the call succeeds.
     *
     * On failure, throws an exception or returns a negative error code.
     */
    softAPNetwork(ssid, securityKey) {
        var _this10 = this;

        return _asyncToGenerator(function* () {
            return yield _this10.set_wlanConfig('SOFTAP:' + ssid + '\\' + securityKey);
        })();
    }

    /**
     * Returns a list of YWlanRecord objects that describe detected Wireless networks.
     * This list is not updated when the module is already connected to an acces point (infrastructure mode).
     * To force an update of this list, adhocNetwork() must be called to disconnect
     * the module from the current network. The returned list must be unallocated by the caller.
     *
     * @return {YWlanRecord[]} a list of YWlanRecord objects, containing the SSID, channel,
     *         link quality and the type of security of the wireless network.
     *
     * On failure, throws an exception or returns an empty list.
     */
    get_detectedWlans() {
        var _this11 = this;

        return _asyncToGenerator(function* () {
            /** @type {Uint8Array} **/
            let json;
            /** @type {string[]} **/
            let wlanlist = [];
            /** @type {YWlanRecord[]} **/
            let res = [];
            // may throw an exception
            json = yield _this11._download('wlan.json?by=name');
            wlanlist = _this11.imm_json_get_array(json);
            res.length = 0;
            for (let ii in wlanlist) {
                res.push(new YWlanRecord(wlanlist[ii]));
            }
            return res;
        })();
    }

    /**
     * Continues the enumeration of wireless lan interfaces started using yFirstWireless().
     *
     * @return {YWireless} a pointer to a YWireless object, corresponding to
     *         a wireless lan interface currently online, or a null pointer
     *         if there are no more wireless lan interfaces to enumerate.
     */
    /* */nextWireless() {
        /** @type {object} **/
        let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
        if (resolve.errorType != _yocto_api.YAPI_SUCCESS) return null;
        /** @type {string|null} **/
        let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
        if (next_hwid == null) return null;
        return YWireless.FindWirelessInContext(this._yapi, next_hwid);
    }

    /**
     * Starts the enumeration of wireless lan interfaces currently accessible.
     * Use the method YWireless.nextWireless() to iterate on
     * next wireless lan interfaces.
     *
     * @return {YWireless} a pointer to a YWireless object, corresponding to
     *         the first wireless lan interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstWireless() {
        /** @type {string|null} **/
        let next_hwid = _yocto_api.YAPI.imm_getFirstHardwareId('Wireless');
        if (next_hwid == null) return null;
        return YWireless.FindWireless(next_hwid);
    }

    /**
     * Starts the enumeration of wireless lan interfaces currently accessible.
     * Use the method YWireless.nextWireless() to iterate on
     * next wireless lan interfaces.
     *
     * @param yctx {YAPIContext} : a YAPI context.
     *
     * @return {YWireless} a pointer to a YWireless object, corresponding to
     *         the first wireless lan interface currently online, or a null pointer
     *         if there are none.
     */
    static FirstWirelessInContext(yctx) {
        /** @type {string|null} **/
        let next_hwid = yctx.imm_getFirstHardwareId('Wireless');
        if (next_hwid == null) return null;
        return YWireless.FindWirelessInContext(yctx, next_hwid);
    }

    //--- (end of generated code: YWireless implementation)
}

exports.YWireless = YWireless; //--- (generated code: Wireless functions)

/**
 * comment from .yc definition
 */

function yFindWireless(func) {
    return YWireless.FindWireless(func);
}

/**
 * comment from .yc definition
 */
function yFirstWireless() {
    return YWireless.FirstWireless();
}

//--- (end of generated code: Wireless functions)
